{"pages":[{"title":"tags","text":"","link":"/tags/index-1.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"Guide &amp;&amp; About","text":"GuideOJ-Counter 轻量级 OJ 过题数统计站点 Blog 个人博客 HEU选课脚本 暂不开源，有需要私聊 About咸鱼，全网基本都一个id。。。 Email：bakapiano@outlook.com QQ：2514965141 Github：https://github.com/bakapiano Codeforces: https://codeforces.com/profile/Bakapiano","link":"/about/index.html"}],"posts":[{"title":"面试算法题*2","text":"题目描述背景 $k$ 聚类，可能和实际题目有出入。。。 T1二维平面上有一个中心点 p_{0} ，你可以在上面添加一些点，但对于任意添加的两点 $p_{i}，p_{j}$，需满足 $dis(p_{i},p_{0}) &lt;=dis(p_{i},p_{j})$ 且 $dis(p_{j},p_{0}) &lt; dis(p_{i},p_{j})$ T2二维平面上有 $n+m$ 个两两不同的点，其中 $n$ 个点我们称其为待分类点，其余的 $m$ 个点称为中心点（分类的中心点），将一个待分类点分给中心点的代价为两点的距离。 现在给定这 $n+m$ 个点，并且第 $i$ 个分类只能容纳 $[l_{i},r_{i}]$ 个点，请你设计一种算法求出最小总代价最小。 My solution for T1猜了一个等分圆，列个柿子：$2PIr/n&gt;r$ 解出 $n$ 最多 $6$。 My solution for T2答了个上下界费用流，建图类似二分图带权匹配。","link":"/2021/03/16/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98-2/"},{"title":"Ubuntu 下搭建 mirai + mirai-api-http","text":"mirai提供 QQ Android 协议支持的高效率机器人库 mirai 使用 iTXTech MCL Installer 获取 mcliTXTech MCL Installer 新建目录 12mkdir mclcd mcl 根据系统和架构选择对应文件：release 123curl -LJO https://github.com/iTXTech/mcl-installer/releases/download/2827601/mcl-installer-2827601-linux-amd64chmod +x mcl-installer-2827601-linux-amd64./mcl-installer-2827601-linux-amd64 无特殊需求可一路回车，mcl就装好啦 使用 mcl 安装 mirai-api-http1./mcl --update-package net.mamoe:mirai-api-http --channel stable --type plugin 测试 http api： 12./mcllogin qq号 qq密码 如果要求滑块验证请看下一步 手动完成滑动验证参考自 mirai-login-solver-selenium 退出控制台，在 mirai 运行时中添加 JVM 属性 mirai.slider.captcha.supported 以启用手动验证 修改文件 mcl vim mcl 为如下内容： 123#!/usr/bin/env shexport JAVA_BINARY=&quot;/root/mcl/java/bin/java&quot;$JAVA_BINARY -Dmirai.slider.captcha.supported -jar mcl.jar $* 再次打开 mcl 并登录，用有桌面系统的电脑打开验证地址 F12 打开 DevTools，切换运行模式为 Android 切换到 Console，复制 captcha.inject.js 的内容全部复制至 Console 中并运行 复制传回的 ticket 并在 mcl 中输入，流程正确的话就能完成登陆了 验证 api使用了 python sdk Graia Application 安装： 1pip install graia-application-mirai 运行 Python 代码： 123456789101112131415161718192021222324252627282930313233from graia.broadcast import Broadcastfrom graia.application import GraiaMiraiApplication, Sessionfrom graia.application.message.chain import MessageChainimport asynciofrom graia.application.message.elements.internal import Plainfrom graia.application.friend import Friendloop = asyncio.get_event_loop()bcc = Broadcast(loop=loop)app = GraiaMiraiApplication( broadcast=bcc, connect_info=Session( host=&quot;http://localhost:8080&quot;, # 填入 httpapi 服务运行的地址 authKey=&quot;0123456789&quot;, # 填入在setting.yml中设置的authKey account=88888888, # 你的机器人的 qq 号 websocket=True # Graia 已经可以根据所配置的消息接收的方式来保证消息接收部分的正常运作. ))@bcc.receiver(&quot;FriendMessage&quot;)async def friend_message_listener(message: MessageChain, friend: Friend, app: GraiaMiraiApplication): msg = message.asDisplay() if msg.startswith(&quot;.help&quot;): await app.sendFriendMessage(friend, MessageChain(__root__=[Plain(&quot;.help\\t显示帮助指令\\r\\n.copy\\t复读&quot;)])) elif msg.startswith(&quot;.copy &quot;): msg = msg[6:] await app.sendFriendMessage(friend, MessageChain(__root__=[Plain(msg)])) else: await app.sendFriendMessage(friend, MessageChain(__root__=[Plain(&quot;收到!&quot;)]))app.launch_blocking() 最后尝试给机器人发消息，收到回复就测试成功了","link":"/2021/03/15/Ubuntu-%E4%B8%8B%E6%90%AD%E5%BB%BA-mirai-mirai-api-http/"},{"title":"2020杭电多校","text":"打星为 upsolve Round 1rank 524 (1/12) 棒子，我x你仙人.jpg 1004签到 n&gt;=3 都是 abcabacabc… *1005为什么你们都会二次剩余啊 考虑 fib 通项，将根号五用二次剩余化成常数 二项式定理展开，每一项等比求和 卡卡常，幂次对 MOD-1 取模 *1006分块 好题 考虑将度数大于 $\\sqrt{n}$ 的点记作特殊点，易知特殊点最多 $\\sqrt{n}$ 个 由于其他点度数不超过 $\\sqrt(n)$ 询问直接暴力 同时维护特殊点的相邻点的权值信息，这里我用了分块来保证整体复杂度在 $n\\sqrt{n}$ 级别 修改一个点权值的时候只需要更新其相邻特殊点的信息即可，由于特殊点不超过 $\\sqrt{n}$ 个，暴力更新的复杂度也能保证 *1009首先按 p sort一下，用单调栈筛出 a 单调递减的所有机器人 之后按照 p 递增的顺序考虑，维护一个可行的（有机会成为领先的）机器人的集合，可以发现这是一个下凸包 新加入一条线的时候，如果和最后一条直线的交点的横坐标（时间） &gt; 最后两个直线的交点的横坐标，就踢掉最后最后一个直线 类似于维护凸包，最后栈的大小就是答案 小心维护 p a 都相等的点，即带入构建凸包，但不算答案 *1011字符串，我的后缀自动机卡不过去 Round 2rank 50 (6/12) 1001按权值 sort 一下，从后往前并查集 1005费用流，保留每个工人极值点左右 50 个点的机器，之后费用流 每次新加边增广就行，不用重新建图 1006取个模数算一下，O(n) 验证 1007二分答案 + dp 二分直径长度 limit，考虑 dp $f[u][k]$ 表示 $u$ 这颗子树选 $k$ 个边反转时 叶子到 $u$ 的最长路径的长度 合并时若两条路径 &gt; limit 则不能转移，最后看 $f[1][k]$ 是否有值 $O(kn\\log{n})$ *1009暴力 注意到对于每行一定经过偶数次，记录每次经过的 y 坐标，sort 后 $[y_{i}+1,y_{i+1}] (i = 0,2,4….)$ 就是这行经过的格子 然后暴力 1010暴搜 1012dp 观察答案为 $(r-l+1) + m - 2*lcs$ 考虑 $f[i][j][k]$ 表示 $S[1-i]$ 匹配长度为 $j$ 的子序列，子序列在 $T$ 串的结尾为 $k$ 时子序列起点在 $S[1-i]$ 中最靠右的位置 用前缀和做一个 $O(n*m^2)$ 的 dp 即可","link":"/2020/07/24/2020%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"},{"title":"平面图转对偶图求网络流","text":"牛客多校出了个题，补下知识点 参考资料网络流（平面图转对偶图） ysner 简介狼抓兔子 将左上角看作源点，右下为汇，连双向边之后就是一个最小割问题了，但网络流的复杂度无法胜任本题。 注意到最终建出来的图是一个平面图，画一条从左上到右下对角线将最外的无限平面割成两个，求一下对偶图（即平面看作是点，原图中的边看作是连接新图中两个平面的边） 例如下图 转成对偶图就是： 观察原图的任意一个割都可以表示为新图上从 $S’$ 出发到 $T’$ 的一条路径，所以性感理解一下，原图的最大流和最小割就等于新图的最短路。。。 有向图的话，我们可以把所有边按顺(逆)时针转 90° 就得到了新图上的边 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849EDGE(N,N);int S,T,cnt=0,n,m;int id[MAXN][MAXN][2];LL dis[N];LL solve(){ priority_queue&lt;lpr,vector&lt;lpr&gt;,greater&lt;lpr&gt;&gt; q; fp(i,1,cnt)dis[i]=linf; dis[S]=0,q.push({0,S}); while(!q.empty()) { int u=q.top().se; LL d=q.top().fi; q.pop(); if(d!=dis[u])continue; if(u==T)break; gow(u)if(dis[u]+w&lt;dis[v]) dis[v]=dis[u]+w,q.push({dis[v],v}); } return dis[T];}void con(int u,int v,int w){ addedge(u,v,w),addedge(v,u,w); // cout &lt;&lt; dbgs3(u,v,w) &lt;&lt; endl;}int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); fp(i,1,n-1)fp(j,1,m-1)id[i][j][0]=++cnt,id[i][j][1]=++cnt; S=++cnt,T=++cnt; fp(i,1,n)fp(j,1,m-1) { int w;scanf(&quot;%d&quot;,&amp;w); if(i==1)con(S,id[i][j][0],w); else if(i==n) con(id[i-1][j][1],T,w); else con(id[i-1][j][1],id[i][j][0],w); } fp(i,1,n-1)fp(j,1,m) { int w;scanf(&quot;%d&quot;,&amp;w); if(j==1)con(id[i][j][1],T,w); else if(j==m)con(S,id[i][j-1][0],w); else con(id[i][j][1],id[i][j-1][0],w); } fp(i,1,n-1)fp(j,1,m-1) { int w;scanf(&quot;%d&quot;,&amp;w); con(id[i][j][0],id[i][j][1],w); } return printf(&quot;%lld\\n&quot;,solve());} 练习[NOI2010]海拔先大力来一波结论，每个点的高度就是 0/1，并且高度为 1 的点都与右下的点联通，且 1-&gt;0 的边构成原图的一个割 然后应用上述技巧，求个最短路即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960EDGE(N,N*4);int n,m,S,T,cnt;int c[MAXN][MAXN][2]; //0-left 1-downint id[MAXN][MAXN];LL dis[N];LL solve(){ priority_queue&lt;lpr,vector&lt;lpr&gt;,greater&lt;lpr&gt;&gt; q; fp(i,1,cnt)dis[i]=linf; dis[S]=0,q.push({0,S}); while(!q.empty()) { int u=q.top().se; LL d=q.top().fi; q.pop(); if(d!=dis[u])continue; if(u==T)break; gow(u)if(dis[u]+w&lt;dis[v]) dis[v]=dis[u]+w,q.push({dis[v],v}); } return dis[T]==linf?-1:dis[T];}void add(int u,int v,int w){ // cout &lt;&lt; dbgs3(u,v,w) &lt;&lt; endl; addedge(u,v,w);}int work(){ scanf(&quot;%d&quot;,&amp;n); fp(i,1,n)fp(j,1,n)id[i][j]=++cnt; S=++cnt,T=++cnt; fp(i,1,n+1)fp(j,1,n) { int w;scanf(&quot;%d&quot;,&amp;w); int u=(i==1)?T:id[i-1][j]; int v=(i==n+1)?S:id[i][j]; add(u,v,w); } fp(i,1,n)fp(j,1,n+1) { int w;scanf(&quot;%d&quot;,&amp;w); int u=(j==n+1)?T:id[i][j]; int v=(j==1)?S:id[i][j-1]; add(u,v,w); } fp(i,1,n+1)fp(j,1,n) { int w;scanf(&quot;%d&quot;,&amp;w); int u=(i==n+1)?S:id[i][j]; int v=(i==1)?T:id[i-1][j]; add(u,v,w); } fp(i,1,n)fp(j,1,n+1) { int w;scanf(&quot;%d&quot;,&amp;w); int u=(j==1)?S:id[i][j-1]; int v=(j==n+1)?T:id[i][j]; add(u,v,w); } swap(S,T); return printf(&quot;%lld\\n&quot;,solve());} 牛客多校2020 Day2 Interval把所有 $[i,i]$ 都看作一个点，那么问题等价于求 $[1,1]$ 到汇点的一个最小割 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758EDGE(N,N*4);int n,m,S,T,cnt;int c[MAXN][MAXN][2]; //0-left 1-downint id[MAXN][MAXN];LL dis[N];LL solve(){ priority_queue&lt;lpr,vector&lt;lpr&gt;,greater&lt;lpr&gt;&gt; q; fp(i,1,cnt)dis[i]=linf; dis[S]=0,q.push({0,S}); while(!q.empty()) { int u=q.top().se; LL d=q.top().fi; q.pop(); if(d!=dis[u])continue; if(u==T)break; gow(u)if(dis[u]+w&lt;dis[v]) dis[v]=dis[u]+w,q.push({dis[v],v}); } return dis[T]==linf?-1:dis[T];}void add(int u,int v,int w){ // cout &lt;&lt; dbgs3(u,v,w) &lt;&lt; endl; addedge(u,v,w),addedge(v,u,w);}int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); fp(i,1,n)fp(j,1,n)c[i][j][0]=c[i][j][1]=inf; fp(i,1,m) { int l,r,w; char dir; scanf(&quot;%d %d %c %d&quot;,&amp;l,&amp;r,&amp;dir,&amp;w); if(dir=='L')c[l][r][1]=min(c[l][r][1],w); else c[l][r][0]=min(c[l][r][0],w); } fp(i,1,n-1)fd(j,n,i+1)id[i][j]=++cnt; S=++cnt,T=++cnt; // fp(i,1,n-1)fd(j,n,i+1)cout &lt;&lt; dbgs3(i,j,id[i][j]) &lt;&lt; endl; cout &lt;&lt; dbgs2(S,T) &lt;&lt; endl; fp(i,1,n-1)fd(j,n,i+1) { //0-left if(c[i][j][0]!=inf) { int u=(i==1)?S:id[i-1][j]; int v=id[i][j]; add(u,v,c[i][j][0]); } if(c[i][j][1]!=inf) { int u=(j==n)?T:id[i][j+1]; int v=id[i][j]; add(u,v,c[i][j][1]); } } return printf(&quot;%lld\\n&quot;,solve());}","link":"/2020/07/14/%E5%B9%B3%E9%9D%A2%E5%9B%BE%E8%BD%AC%E5%AF%B9%E5%81%B6%E5%9B%BE%E6%B1%82%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"title":"2020牛客多校","text":"打星为 upsolve Round 1好多论文题。。自闭 rank 99 (3/10) *A后缀数组，卡常 F签到，扩两倍下标取模比较下 H预处理费用分段函数，讨论 JOEIS 牛逼 Round 2再也不做构造系列 rank 85 (5/11) *A对于每个字符串枚举前缀 $s[1]$ … $s[i]$，设有 $cnt[i]$ 个后缀和他相同，但这样会重复计算，如字符串 $aba$ 和后缀 $aba$，同一字符串的后缀被计了两次数 考虑去重，从前往后 $cnt[next[i]]-=cnt[i]$，然后计算答案即可。 B三点定圆，考虑枚举 $(0,0)$ 外的另外 $2$ 点，算出圆心去重统计答案，注意精度。 C赵哥狂日$20$发 题解做法：所有叶子按 dfs 序 sort, $l_{1} - l_{s/2+1}$, $l_{2} - l_{s/2+2}$ $…$ $l_{s/2} - l_{n}$ D签到 *E待补 FWT F两维分别单调队列，这里求 $gcd$ 可以记忆化去掉一个 $log$ *G依出题人的说法，这种 $m$ 是 4万的数据应该往 $bitset$ 上靠。。。 $n*m$ 在 1e9 左右的题都可以考虑一下 $bitset$，复杂度会除个 $64$ 做法类似于 $shift-and$，首先对于每个 $a[i]$ 处理出他在 $b$ 数组中能匹配的位置 $s[i]$，这个用个 bitset 存下。 注意到本质不同的 $s$ 最多 $m$ 种，对于每个 $b[j]$ 求下 $s$ 即可 剩下的做法和 $shift-and$ 一致了，$f[i][j]$ 表示结尾为 $i$ 的子区间是否能匹配上 $b[1$~$j]$，记作 $cur$，转移：cur = (cur &lt;&lt; 1 &amp; s[i]) | 1 *H赛中差一点调出，爆了 int 。。。 考虑三种情况： $a &lt; b &lt; x$，a 和 b 取 x 的两个前驱最优 $a &lt; x &lt; b$，a 和 b 分别取 x 的前驱和后继最优 $x &lt; a &lt; b$，首先 a 和 b 一定是连续的，其次考虑能组成三角形时的条件：$x+a&gt;b$ 即 $x&gt;b-a$，因此维护有序序列，权值为相邻两项的差，求 $&gt;x$ 权值的 $min$ 即可 1 和 2 开个 $set$ 搞一搞就行 3: 请选择你喜欢的数据结构.jpg *I网络流平面图转对偶图 J *K待补，几何 给队友了。。。 Round 3rank 62 (8/12) 好，dreamoon牛逼 A贪心，有🐟就抓，倒序累计可以用鱼饵抓鱼的时间点 B 平衡树 模拟 手玩观察规律，护偏移量就行 C几何，zyy牛逼 D构造，zyy牛逼 先构造一个正方形，每次向右上挪点 ans+=2,变成一条链后拆两端的点，每次 ans+=2 Edp，zzq牛逼 先sort，观察发现偶数 &gt;=4 联通快内最优解为 2*(a[r]-a[l])，之后dp F数论，zzq牛逼 a b 不互质直接构造 分解 b，若 b 为 p^k 则无解 否则分解 b 为 p^k * b/p^k，exgcd解两个解 G数据结构 并查集维护联通情况，vector 维护边集，启发式合并 list 可以做到 O(1) 合并 H数据结构，每次找 [l,r] 中 p 最小的位置分治，笛卡尔树做到线性 *I待补 *J待补 *K待补 L签到 Round 4rank 84 (4/10) 题不错，就是人太菜 *A考虑 k 固定，二分答案记作 dis，每次贪心找叶子的 dis 级祖先并割掉这颗子树 一个性质若答案为 dis，则关键点数至少为 n/dis 级别的（考虑一条链） 那么总关键点数就是一个调和级数，对于每个 dis 用线段树模拟割子树的过程总复杂度两个 log B简单数论 *C牛逼串串题 题面好难读 把后缀全丢到 Trie 上总点数为 10N 级别的 然后问题变成了求 Trie 上串本质不同字串个数，广义SAM *D待补 *E待补 F签到不会系列 *G待补，搬砖题？？ H数论，原题了 除了 1 和 &gt; n/2 的质数外都能匹上 一种构造： 倒序考虑所有质数 p，处理他的所有未匹配的倍数，假设有 num 个 若 num 为偶数，则两两匹配，若为奇数，则留下 2*p 最后将所有留下的所有 2*pi 两两匹配 I魔 幻 调 参 每次找一个未归类的点，假设他所有的话都是真的，扩一波点 然后以多数人原则来判断组内是否有错加入的点，及当 &gt;cnt 的人认为他是一组时就认为是真的 然后做 bfs 扩点，同样也用同样的原则辨别真假 最后 cnt 调成 当前组内点数/2 过了。。。 *J据说是分块，补一下","link":"/2020/07/13/2020%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"},{"title":"回滚莫队","text":"介绍在一些用莫队处理的问题中，扩展区间容易但收缩区间不好处理，这时可以考虑使用回滚莫队的技巧，以达到区间只增不减的效果。 具体步骤 对询问离线并排序，以左端点所在块号为第一关键字，右端点大小为第二关键字进行排序 以块号递增的顺序处理询问，每次只考虑左端点在该块内的询问 暴力回答所有左右端点都在块内的询问 记当前块号为 $k$，区间为 $[st[k],ed[k]]$，考虑剩下的询问，显然询问的右端点都大于 $ed[k]$ 并且递增 记当前已求得答案的区间为 $[l,r]$，答案为 $pre$，若该询问是该块内的第一次询问则初始化区间为 $[l=ed[k]+1, r=ed[k]]$ 扩展 $r$ 至当前询问的右边界，并更新答案 $pre$ 建立临时变量 $ans=pre$，扩展 $l$ 至当前询问的左边界，并更新答案 $ans$，扩展完毕后用 $ans$ 回答当前询问 回撤左端点 $l$ 至 $ed[k]+1$，并撤销扩展 $l$ 时对辅助变量的更改，保留 $pre$ 用于下次询问（即回撤区间至 $[ed[k],r]$） 这样我们就实现了区间只增不减的莫队，步骤 8 中撤销左边界的具体实现视所用辅助变量而定，例如桶的话就 $cnt[value]—$，并查集的话用按秩合以支持撤销操作。 分析下复杂度，假定 $n$ 和 $m$ 同数量级，取块大小 $B = \\sqrt{n}$，暴力处理块内询问 $O(\\sqrt{n})$，每个块内右端点至多扩展 $n$ 次 $O(n\\sqrt{n})$，左端点每次最多扩展和撤销 $\\sqrt{n}$ 次，因此总复杂度仍为 $O(n\\sqrt{n})$。 模板AtCoder1219 历史研究 扩展右端点：cnt[x]++,pre=max(pre,cnt[x]*x) 扩展右端点：cnt[x]++,ans=max(ans,cnt[x]*x) 回撤左端点：cnt[x]-- 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const int SZ = sqrt(MAXN);vector&lt;int&gt; X;int n,m,z;int a[MAXN],b[MAXN],cnt[MAXN],id[MAXN],st[MAXN],ed[MAXN],t[MAXN];struct query{ int l,r,i; LL ans; bool operator &lt;(const query &amp;t)const { if(id[t.l]!=id[l])return id[l]&lt;id[t.l]; return r&lt;t.r; }}q[MAXN];inline LL baoli(int l,int r){ LL ans=0; fp(i,l,r)t[b[i]]++,ans=max(ans,1LL*t[b[i]]*a[i]); fp(i,l,r)t[b[i]]--; return ans;}int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); fp(i,1,n)scanf(&quot;%d&quot;,&amp;a[i]),X.pb(a[i]); fp(i,1,n)id[i]=(i-1)/SZ+1; z=id[n]; fp(i,1,n)if(!st[id[i]])st[id[i]]=i; fd(i,n,1)if(!ed[id[i]])ed[id[i]]=i; sort(all(X)),unq(X); fp(i,1,n)b[i]=lb(all(X),a[i])-X.begin()+1; fp(i,1,m)scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r),q[i].i=i; sort(q+1,q+1+m); LL ans=0,pre=0; for(int i=1,l,r;i&lt;=m;i++) { int k=id[q[i].l]; if(id[q[i].l]!=id[q[i-1].l])mst(cnt,0),ans=pre=0,r=ed[k],l=ed[k]+1; if(id[q[i].l]==id[q[i].r])q[i].ans=baoli(q[i].l,q[i].r); else { while(l&lt;=ed[k])cnt[b[l]]--,l++; while(r&lt;q[i].r)r++,cnt[b[r]]++,pre=max(pre,1LL*cnt[b[r]]*a[r]); ans=pre; while(l&gt;q[i].l)l--,cnt[b[l]]++,ans=max(ans,1LL*cnt[b[l]]*a[l]); q[i].ans=ans; } } sort(q+1,q+1+m,[](const query &amp;a,const query &amp;b){return a.i&lt;b.i;}); fp(i,1,m)printf(&quot;%lld\\n&quot;,q[i].ans); return 0;} 练习Luogu P5906 【模板】回滚莫队&amp;不删除莫队扩展右端点再更新答案的同时记录每个数的最右出现位置，扩展左端点时用区间内最靠右的位置更新答案。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const int SZ = sqrt(MAXN);int n,m;int a[MAXN],t[MAXN],s1[MAXN],s2[MAXN];int id[MAXN],st[MAXN],ed[MAXN];struct query{int l,r,i,ans;}q[MAXN];vector&lt;int&gt; X;int baoli(int l,int r){ int ans=0; fp(i,l,r) if(!t[a[i]]) t[a[i]]=i; else ans=max(ans,i-t[a[i]]); fp(i,l,r)t[a[i]]=0; return ans;}int work(){ scanf(&quot;%d&quot;,&amp;n); fp(i,1,n)scanf(&quot;%d&quot;,&amp;a[i]),X.pb(a[i]); fp(i,1,n)id[i]=(i-1)/SZ+1; fp(i,1,n)if(!st[id[i]])st[id[i]]=i; fd(i,n,1)if(!ed[id[i]])ed[id[i]]=i; sort(all(X)),unq(X); fp(i,1,n)a[i]=lb(all(X),a[i])-X.begin()+1; scanf(&quot;%d&quot;,&amp;m); fp(i,1,m)scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r),q[i].i=i; sort(q+1,q+1+m,[](const query &amp;a,const query &amp;b) { if(id[a.l]!=id[b.l])return id[a.l]&lt;id[b.l]; return a.r&lt;b.r; }); int pre=0,ans=0,l,r; fp(i,1,m) { int k=id[q[i].l]; if(id[q[i].l]!=id[q[i-1].l]) { r=ed[k],l=ed[k]+1,ans=pre=0,mst(s1,0),mst(s2,0); } if(id[q[i].l]==id[q[i].r])q[i].ans=baoli(q[i].l,q[i].r); else { while(r&lt;q[i].r) { r++,s2[a[r]]=r; if(!s1[a[r]])s1[a[r]]=r; else pre=max(pre,r-s1[a[r]]); } ans=pre; while(l&gt;q[i].l) { l--; if(!t[a[l]])t[a[l]]=l; else ans=max(ans,t[a[l]]-l); if(s2[a[l]])ans=max(ans,s2[a[l]]-l); } while(l&lt;=ed[k])t[a[l]]=0,l++; q[i].ans=ans; } } sort(q+1,q+1+m,[](const query &amp;a,const query &amp;b){return a.i&lt;b.i;}); fp(i,1,m)printf(&quot;%d\\n&quot;,q[i].ans); return 0;} ICPC2017北京C显然扩展区间时用并查集可以很简单的维护答案，实现并查集撤销后应用回滚莫队即可 这题有点玄学，理论上来说应该按度数分块，因为扩展区间的复杂度并不是 $O(1)$ 的，而是取决于该点向区间内的连边数。那么应该保证块内总度数在 $\\sqrt{m}$ 的数量级内。。。但这么分块会 TLE，估计数据的连边都是随机的，每个块内的边数都在 $\\sqrt{n}$ 左右吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798const int B = sqrt(50000);struct dsu{ struct info{int fa,sz;}t[MAXN]; vector&lt;pair&lt;int,info&gt;&gt; v; void init(int n) { fp(i,1,n)t[i]={i,1}; v.clear(); } int find(int x){return t[x].fa==x?x:find(t[x].fa);} LL merge(int a,int b) { int fa=find(a),fb=find(b); LL ans=0; v.pb({fa,t[fa]}); v.pb({fb,t[fb]}); if(fa!=fb) { if(t[fa].sz&gt;t[fb].sz)swap(fa,fb); ans=1LL*t[fa].sz*t[fb].sz; t[fa].fa=fb; t[fb].sz+=t[fa].sz; } return ans; } void undo() { t[v.back().fi]=v.back().se,v.ppb(); t[v.back().fi]=v.back().se,v.ppb(); }}S,T;int n,m,q;int id[MAXN],st[MAXN],ed[MAXN];vector&lt;int&gt; G[MAXN];struct edge{int u,v;}e[MAXN];struct query{int l,r;LL ans;int i;}a[MAXN];void add(int i,int l,int r,dsu &amp;d,LL &amp;ans,int &amp;cnt){ auto it = lb(all(G[i]),l), ed = ub(all(G[i]),r); for(;it!=ed;it++) { int j=*it; ans+=d.merge(i,j); cnt++; }}LL baoli(int l,int r){ int cnt=0; LL ans=0; fp(i,l,r)add(i,l,r,T,ans,cnt); while(cnt--)T.undo(); return ans;}int work(){ MC { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); S.init(n),T.init(n); fp(i,1,n)G[i].clear(); fp(i,1,n)id[i]=(i-1)/B+1,st[id[i]]=ed[id[i]]=0; fp(i,1,n)if(!st[id[i]])st[id[i]]=i; fd(i,n,1)if(!ed[id[i]])ed[id[i]]=i; fp(i,1,m)scanf(&quot;%d%d&quot;,&amp;e[i].u,&amp;e[i].v); fp(i,1,q)scanf(&quot;%d%d&quot;,&amp;a[i].l,&amp;a[i].r),a[i].i=i; sort(a+1,a+1+q,[](const query &amp;a,const query &amp;b) { if(id[a.l]!=id[b.l])return id[a.l]&lt;id[b.l]; return a.r&lt;b.r; }); fp(i,1,m)G[e[i].u].pb(e[i].v),G[e[i].v].pb(e[i].u); fp(i,1,n)sort(all(G[i])); int l,r; LL ans=0,pre=0; fp(i,1,q) { int k=id[a[i].l]; if(id[a[i].l]!=id[a[i-1].l])S.init(n),ans=pre=0,r=ed[k],l=ed[k]+1; if(id[a[i].l]==id[a[i].r])a[i].ans=baoli(a[i].l,a[i].r); else { int cnt=0; while(r&lt;a[i].r)r++,add(r,l,r,S,pre,cnt); cnt=0,ans=pre; while(l&gt;a[i].l)l--,add(l,l,r,S,ans,cnt); a[i].ans=ans,l=ed[k]+1; while(cnt--)S.undo(); } } fp(i,1,n)G[i].clear(); sort(a+1,a+1+q,[](const query &amp;a,const query &amp;b) { return a.i&lt;b.i; }); fp(i,1,q)printf(&quot;%lld\\n&quot;,a[i].ans); } return 0;}","link":"/2020/07/07/%E5%9B%9E%E6%BB%9A%E8%8E%AB%E9%98%9F/"},{"title":"2020校队预选赛A-字符矩阵-题解","text":"关于本次比赛首先道个歉，卡掉了时空复杂度为 $n^3$ 的 $dp$ 做法确实是不应该，零基础的话能自学到掌握基本 $dp$ 的程度应该是很优秀的水平了。 而本次组题问题也很多，包括没有一个总的命题人来把握整体难度 和 “祖安” 一题出现意料外的解法(正则表达式)等。再次对我们命题工作的不当导致大家不好的比赛体验道个歉。 但每个题所涉及的知识点多为算法竞赛中实用的算法或技巧，数据也经过多次验证，欢迎大家赛后补题。 题目来源Div.1 #517 B 的简化版本 题解回到本题，题目大意为给你一个 $n*n$ 大小的矩阵，每个位置上有一个小写字母，从 $(1,1)$ 开始每次向右或向下移动到达 $(n,n)$ 并按顺序取走路径上的字符来形成一个字符串，请你求出其中字典序最小的解。 O(n^3)考虑使用动态规划，$f[i][j]$ 表示从 $(1,1)$ 出发到 $(i,j)$ 所能形成的字典序最小的字符串，转移方程为: f[i][j] = min(f[i-1][j],f[i][j-1]) + s[i][j];其中 $s[i][j]$ 表示矩阵 $(i,j)$ 位置的字符，$”+”$ 表示字符串的拼接。 这个 $dp$ 看起来状态只有 $n^2$，但转移实际上是 $O(n)$ 的，因为字符串字典序的比较(包括std::string)是 $O(n)$ 的，因此总体时间复杂度为 $O(n^3)$，$n=2000$ 时计算次数约为 $8e9$，而较快的评测机大概 5s 可以跑 $1e9$，无法通过本题，而且空间复杂度也为 $O(n^3)$，交上去会 $MLE$。 123456789101112131415161718192021222324int n;string f[MAXN][MAXN];char s[MAXN][MAXN];int work(){ scanf(&quot;%d&quot;,&amp;n); fp(i,1,n)scanf(&quot;%s&quot;,s[i]+1); f[1][1]=s[1][1]; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { if(i!=1||j!=1) { if(i==1)f[i][j]=f[i][j-1]; else if(j==1)f[i][j]=f[i-1][j]; else f[i][j]=min(f[i-1][j],f[i][j-1]); f[i][j].pb(s[i][j]); } } } printf(&quot;%s&quot;,f[n][n].c_str()); return 0;} O(n^2)考虑一个朴素的贪心算法，由于字典序比较的特殊性，我们需要让靠前的字母尽量的小，因此从 $(1,1)$ 出发每次选择较小的字符进行转移。 但考虑 bbabbbbbb 的情况，我们无法确定从 $(1,1)$ 开始下一步应该转移到哪里，如果使用 $dfs$ 的话复杂度也是 $n!$ 级别。 但实际上对于这种无法确定的转移一定是在同一对角线上的(对应的字符串长度相同)，我们可以去重后全部保留，这种转移数总级别是 $O(n^2)$ 级别的，考虑到扩展一个字符是 $O(1)$的，因此我们可以得到一个 $O(n^2)$ 的算法： 顺序考虑字符串第 $i$ 位的字符 $(1&lt;=i&lt;=2*n-1)$: 1. 建立一个待扩展队列，初始时只有 (1,1) 2. 查找待扩展队列中最小的字符，记 c，同时为答案末尾添加上 c 3. 保留队列中 s[i][j]==c 的 (i,j) 4. 对于保留下来的 (i,j)，添加 (i+1,j) 和 (i,j+1) 到新扩展队列中 5. 将旧扩展队列替换为新扩展队列 6. 若没到达 (n,n) 从第二步开始重复 实际写法类似于 $bfs$，时空复杂度均为 $O(n^2)$ 可以通过本题。 12345678910111213141516171819202122232425262728293031int n;vector&lt;pr&gt; v,t;string ans;char s[MAXN][MAXN];bool vis[MAXN][MAXN];int main(){ cin &gt;&gt; n; fp(i,1,n)fp(j,1,n)cin &gt;&gt; s[i][j]; ans.clear(),v.clear(),t.clear(),t.push_back({1,1}),vis[1][1]=1; while(1) { char c='z'+1; for(auto p:t)c=min(s[p.fi][p.se],c); ans.push_back(c); if(t.front().fi==n&amp;&amp;t.front().se==n)break; v.clear(); for(auto p:t)if(s[p.fi][p.se]==c) { if(p.fi!=n&amp;&amp;!vis[p.fi+1][p.se]) v.push_back({p.fi+1,p.se}), vis[p.fi+1][p.se]=1; if(p.se!=n&amp;&amp;!vis[p.fi][p.se+1]) v.push_back({p.fi,p.se+1}), vis[p.fi][p.se+1]=1; } swap(v,t); } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2020/06/14/2020%E6%A0%A1%E9%98%9F%E9%A2%84%E9%80%89%E8%B5%9BA-%E5%AD%97%E7%AC%A6%E7%9F%A9%E9%98%B5-%E9%A2%98%E8%A7%A3/"},{"title":"决策单调性优化dp","text":"用来存下板子。。。证明或详细讲解请参考其他blog 决策单调性可离线分治 例：CF321E 123456789void solve(int s,int l=1,int r=n,int nl=0,int nr=n-1){ if(l&gt;r) return; int m = mid,from; f[s][m]=inf; fp(i,nl,min(nr,m-1)) if(f[s-1][i]+cost(i+1,m)&lt;f[s][m]) f[s][m]=f[s-1][i]+cost(i+1,m),from=i; solve(s,l,m-1,nl,from),solve(s,m+1,r,from,nr);} 不可离线写法参考自：浅析1D1D动态规划的优化 确定 $f[3]$ 之前所有状态的最优决策表： 1111111111111222222222222 加入 $f[3]$ 后决策表只能有三种类型 1111111111111222222222222 不变 1111111111111222223333333 占据 $2$ 的一部分 1111113333333333333333333 完全覆盖 $2$ 考虑使用栈来维护每个 $i$ 作为决策点的起始位置 设老决策的起点为 $j$，从栈顶向下依次考虑： 若新决策在 $j$ 优于老决策，则退栈并抛弃老决策 否则，转折点一定在当前这个老决策的区间中，二分这个位置 新决策入栈 例： [NOI2009]诗人小G 12345678910111213141516171819pr s[MAXN]; int h=0;LL calc(int i,int j){return f[j]+cost(i,j);}fp(i,1,n){ pr t=*(ub(s+1,s+h+1,mp(i,inf))-1); f[i]=calc(i,t.se),from[i]=t.se; if(i==n||calc(n,s[h].se)&lt;calc(n,i))continue; while(h&amp;&amp;s[h].fi&gt;i&amp;&amp;calc(s[h].fi,s[h].se)&gt;calc(s[h].fi,i))h--; int l=max(i+1,s[h].fi),r=n,ans=n; while(l&lt;=r) { if(calc(mid,s[h].se)&gt;calc(mid,i))ans=mid,r=mid-1; else l=mid+1; } s[++h]={ans,i};}","link":"/2020/05/25/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7%E4%BC%98%E5%8C%96dp/"},{"title":"kruskal重构树","text":"Kruskal重构树资料Kruskal重构树入门 自为风月马前卒 模板构建方法：初始时有 $n$ 个叶子节点，运行 $kruskal$ 最小生成树算法，对于用边权为 $w$ 连接两个节点 $(u,v)$, 新建一个权值为 $w$ 的节点 $x$，并连边 $(x,root(u))$ 和 $(x,root(v))$, 并将 $x$ 置为这颗树的根节点。 这样建出来的其实是一个大根堆，可以用来求从点 $x$ 出发只走边权 $&lt;=w$ 的边能到达的点的极大集合 做法就是从 $x$ 倍增往上面跳直到点权 $&gt;w$，设跳到的点为 $u$，那么 $u$ 的所有叶子就是所求的极大集合 还有一个性质是：任意两个点路径上边权的最大值为它们的LCA的点权 例题Peaks加强版 在Bytemountains有N座山峰，每座山峰有他的高度hi。 有些山峰之间有双向道路相连，共M条路径，每条路径有一个困难值，这个值越大表示越难走. 现在有Q组询问，每组询问询问从点v开始只经过困难值小于等于x的路径所能到达的山峰中第k高的山峰，如果无解输出−1 kruskal重构树 + 主席树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556vector&lt;int&gt; X;EDGE(MAXN,MAXN*2);int n,m,q,cnt,last=-1;int h[MAXN],a[MAXN],b[MAXN],fa[MAXN],st[MAXN],ed[MAXN],f[MAXN][21];struct temp{int u,v,w;}edg[N];int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}void dfs(int u,int fa){ st[u]=++cnt,b[cnt]=h[u],f[u][0]=fa; go(u)if(v!=fa)dfs(v,u); ed[u]=cnt;}int root[MAXN],s[MAXN*10],ls[MAXN*10],rs[MAXN*10],cnt_;void update(int pre,int &amp;rt,int l,int r,int pos){ if(!rt)rt=++cnt_; s[rt]=s[pre]+1; if(l==r)return; if(pos&lt;=mid)update(ls[pre],ls[rt],l,mid,pos),rs[rt]=rs[pre]; else update(rs[pre],rs[rt],mid+1,r,pos),ls[rt]=ls[pre];}void query(int pre,int rt,int l,int r,int k){ if(l==r){printf(&quot;%d\\n&quot;,X[l-1]),last=X[l-1];return;} int sum=s[rs[rt]]-s[rs[pre]]; if(sum&gt;=k)query(rs[pre],rs[rt],mid+1,r,k); else query(ls[pre],ls[rt],l,mid,k-sum);}bool cmp(const temp &amp;a,const temp &amp;b){return a.w&lt;b.w;}int work(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); fp(i,1,n)scanf(&quot;%d&quot;,&amp;h[i]),X.pb(h[i]); sort(all(X)),unq(X); fp(i,1,n)h[i]=lb(all(X),h[i])-X.begin()+1; fp(i,1,2*n)fa[i]=i; fp(i,1,m)scanf(&quot;%d%d%d&quot;,&amp;edg[i].u,&amp;edg[i].v,&amp;edg[i].w); sort(edg+1,edg+1+m,cmp); fp(i,1,m)if(find(edg[i].u)!=find(edg[i].v)) { a[++n]=edg[i].w; int fu=find(edg[i].u),fv=find(edg[i].v); addedge(n,fu),addedge(n,fv),fa[fu]=fa[fv]=n; } fp(i,1,n)if(!st[i])dfs(find(i),0); fp(j,1,20)fp(i,1,n)f[i][j]=f[f[i][j-1]][j-1]; fp(i,1,n) if(b[i])update(root[i-1],root[i],1,X.size(),b[i]); else root[i]=root[i-1]; while(q--) { int u,x,k;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;x,&amp;k); if(last!=-1)u^=last,x^=last,k^=last; fd(i,20,0)if(f[u][i]&amp;&amp;a[f[u][i]]&lt;=x)u=f[u][i]; int l=st[u],r=ed[u]; if(s[root[r]]-s[root[l-1]]&lt;k)printf(&quot;-1\\n&quot;),last=-1; else query(root[l-1],root[r],1,X.size(),k); } return 0;}","link":"/2020/05/25/kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"},{"title":"线段树合并 线段树分裂 线段树优化建图(线段树三连)","text":"线段树合并参考资料线段树的合并 简介默认使用动态开点的线段树 考虑如下问题：现在有两棵值域相同的权值线段树，你需要将两颗线段树对应节点的信息合并，得到一颗新的线段树 显然可以启发式合并做到 $O(lognlogn)$，即把叶子数小的依次插入到另一颗线段树中，在保证总点数是 $n$ 的级别下可以做到两个 $log$ 由此引出一个线段树的小技巧：线段树合并 代码大概长这样 1234567func merge(a,b): if a,b中有一个为空: 返回另一个 else if a,b都为叶子: 合并a,b merge_leaf(a,b)并返回结果 else: 返回 merge(a-ls,b-&gt;ls) 和 merge(a-&gt;rs,b-&gt;rs) 连接而成的树 分析下复杂度，单次合并操作的复杂度取决于两棵树公共节点(叶子)的个数，可大可小 ($O(1)$ ~ $O(nlogn)$) 假设我们有 $n$ 颗一个元素的线段树，分析下把他合并成一个的复杂度：$O(nlogn)$，因此在保证总点数的情况下复杂度是均摊 $logn$ 的 但实际用起来不一定比两个 $log$ 快。。 12345678int merge(int x,int y,int l,int r){ if(x*y==0)return x+y; if(l==r){mx[x]+=mx[y];return x;} ls[x]=merge(ls[x],ls[y],l,mid); rs[x]=merge(rs[x],rs[y],mid+1,r); up(x);return x;} 例题1. [HNOI2012]永无乡并查集+启发式合并可以做到两个 $log$，线段树合并的话在并查集每次合并的时候（$a-&gt;b,fa[b]=a$）合并根节点的线段树：$root[b]=merge(root[b],root[a])$ 即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int n,m,q;int fa[MAXN],a[MAXN],id[MAXN];vector&lt;int&gt; X;namespace seg{ int root[MAXN],ls[N],rs[N],s[N],cnt; void insert(int &amp;x,int l,int r,int val) { if(!x)x=++cnt; s[x]++; if(l==r)return; if(val&lt;=mid)insert(ls[x],l,mid,val); else insert(rs[x],mid+1,r,val); } int merge(int x,int y,int l,int r) { if(!(x*y))return x+y; if(l==r)return s[x]+=s[y],x; ls[x]=merge(ls[x],ls[y],l,mid); rs[x]=merge(rs[x],rs[y],mid+1,r); s[x]=s[ls[x]]+s[rs[x]]; return x; } void query(int x,int l,int r,int k) { if(k&gt;s[x]){printf(&quot;-1\\n&quot;);return;} if(l==r){printf(&quot;%d\\n&quot;,id[l]);return;} int num=s[ls[x]]; if(num&gt;=k)query(ls[x],l,mid,k); else query(rs[x],mid+1,r,k-num); }}int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}void merge(int x,int y){ x=find(x),y=find(y); if(seg::s[seg::root[x]]&gt;seg::s[seg::root[y]])swap(x,y); fa[x]=y,seg::root[y]=seg::merge(seg::root[y],seg::root[x],1,n);}int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); fp(i,1,n)scanf(&quot;%d&quot;,&amp;a[i]),X.pb(a[i]); sort(all(X)); fp(i,1,n)a[i]=lb(all(X),a[i])-X.begin()+1,id[a[i]]=i; fp(i,1,n)fa[i]=i,seg::insert(seg::root[i],1,n,a[i]); fp(i,1,m) { int u,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v); if(find(u)!=find(v))merge(u,v); } scanf(&quot;%d&quot;,&amp;q); while(q--) { char opt[5]; int x,y; scanf(&quot;%s%d%d&quot;,opt,&amp;x,&amp;y); if(opt[0]=='Q')seg::query(seg::root[find(x)],1,n,y); if(opt[0]=='B')if(find(x)!=find(y))merge(x,y); } return 0;} 2. CF600E Lomsat gelral自底向上合并线段树即可，线段树上维护每个颜色的最大出现次数和答案 比 $dsu$ 的解法快一点点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152GE(MAXN,MAXN*2);int n,cnt;int a[MAXN],root[MAXN];LL ans[MAXN];int ls[N],rs[N],mx[N];LL sum[N];void up(int x){ mx[x]=max(mx[ls[x]],mx[rs[x]]); if(mx[ls[x]]==mx[rs[x]])sum[x]=sum[ls[x]]+sum[rs[x]]; else if(mx[ls[x]]&gt;mx[rs[x]])sum[x]=sum[ls[x]]; else sum[x]=sum[rs[x]];}void build(int &amp;x,int l,int r,int val){ x=++cnt; if(l==r){mx[x]=1,sum[x]=l;return;} if(val&lt;=mid)build(ls[x],l,mid,val); else build(rs[x],mid+1,r,val); up(x);}int merge(int x,int y,int l,int r){ if(x*y==0)return x+y; if(l==r){mx[x]+=mx[y];return x;} ls[x]=merge(ls[x],ls[y],l,mid); rs[x]=merge(rs[x],rs[y],mid+1,r); up(x); return x;}void debug(int x,int l,int r){ if(x==0)return; cout &lt;&lt; dbgs3(x,l,r) &lt;&lt; &quot; &quot; &lt;&lt; dbgs2(mx[x],sum[x]) &lt;&lt; endl; if(l==r)return; debug(ls[x],l,mid); debug(rs[x],mid+1,r);}void dfs(int u,int fa){ build(root[u],1,n,a[u]); go(u)if(v!=fa)dfs(v,u),root[u]=merge(root[u],root[v],1,n); ans[u]=sum[root[u]];}int work(){ scanf(&quot;%d&quot;,&amp;n); fp(i,1,n)scanf(&quot;%d&quot;,&amp;a[i]); fp(i,1,n-1) { int u,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v),addedge(v,u); } dfs(1,0); fp(i,1,n)printf(&quot;%lld &quot;,ans[i]); return 0;} 3. [Vani有约会]雨天的尾巴 /【模板】线段树合并如果只有一种颜色，显然做一下树上差分1s[u]++,s[v]++,s[lca]--,s[fa[lca]]--然后自底向上合并 s[ ] 即可。 扩展到多种颜色：为每个节点 $u$ 开一个数组 $f[u][color]$，在颜色对应的位置 ++ 或 — 然后每个节点都开一个线段树来维护这个 $f[u]$ 数组，自底向上合并线段树就可以得到每个点的救济粮分发情况 在差分之后也可以沿用 $dsu$ 的解法，复杂度同样是一个 $log$，这里就练一下线段树合并啦 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int n,m;int root[MAXN],a[MAXN];int mx[N],ans[N],ls[N],rs[N],cnt;void up(int x){ if(mx[ls[x]]&gt;=mx[rs[x]])mx[x]=mx[ls[x]],ans[x]=ans[ls[x]]; else mx[x]=mx[rs[x]],ans[x]=ans[rs[x]];}void insert(int &amp;x,int l,int r,int pos,int add){ if(!x)x=++cnt; if(l==r){mx[x]+=add,ans[x]=l;return;} if(pos&lt;=mid)insert(ls[x],l,mid,pos,add); else insert(rs[x],mid+1,r,pos,add); up(x);}int merge(int x,int y,int l,int r){ if(x*y==0)return x+y; if(l==r){mx[x]+=mx[y];return x;} ls[x]=merge(ls[x],ls[y],l,mid); rs[x]=merge(rs[x],rs[y],mid+1,r); up(x);return x;}void dfs(int u,int fa){ go(u)if(v!=fa) dfs(v,u),root[u]=merge(root[u],root[v],1,M); a[u]=mx[root[u]]?ans[root[u]]:0;}int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); fp(i,1,n-1) { int u,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v),addedge(v,u); } lca::init(1); while(m--) { int u,v,z;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;z); int l=lca::query(u,v); insert(root[u],1,M,z,1); insert(root[v],1,M,z,1); insert(root[l],1,M,z,-1); if(lca::fa[l])insert(root[lca::fa[l]],1,M,z,-1); } dfs(1,0); fp(i,1,n)printf(&quot;%d\\n&quot;,a[i]); return 0;} 线段树分裂线段树优化建图依旧由一个问题来引入：[PA2011]Journeys 考虑如何实现区间连边 首先建两棵线段树 $in$ 和 $out$ ，$in$ 中父亲向儿子连边权为 $0$ 的有向边，out 中儿子向父亲连边权为 $0$ 的有向边，两颗树的叶子节点对应着由 $in$ 向 $out$ 连边权为 $0$ 的边 一个 $[1,4]$ 的例子如下： 区间 $[a,b]$ 向 $[c,d]$ 连边的话，首先新建两个节点 $P1$ $P2$，$P1$ 向 $P2$ 连边权为 $1$ 的边，在 $out$ 树上找到 $[a,b]$ 对应的区间并分别向 $P1$ 连边权为 $0$ 的边，$in$ 树同理，$P2$ 分别向 $[c,d]$ 所表示的区间连边 一个 $[1,3]$ 向 $[3,4]$ 连边的例子： 会了这个这个题就很裸了，建完图跑遍最短路即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//点数 n*4*2+m*2*2//边数 n*4*2+n+(1+logn)*m*2EDGE(N,M);int n,m,S,node=0;int in[MAXN*4],out[MAXN*4],dis[N];bool v[MAXN];vector&lt;int&gt; q1,q2;void build(int l,int r,int cnt){ in[cnt]=++node,out[cnt]=++node; if(cnt/2) { addedge(in[cnt/2],in[cnt],0); addedge(out[cnt],out[cnt/2],0); } if(l==r){addedge(in[cnt],out[cnt],0);return;} else build(l,mid,ls),build(mid+1,r,rs);}void query(int l,int r,int nl,int nr,int id[],vector&lt;int&gt; &amp;v,int cnt){ if(l==nl&amp;&amp;r==nr){v.pb(id[cnt]);return;} if(nr&lt;=mid)query(l,mid,nl,nr,id,v,ls); else if(nl&gt;mid)query(mid+1,r,nl,nr,id,v,rs); else query(l,mid,nl,mid,id,v,ls),query(mid+1,r,mid+1,nr,id,v,rs);}void link(int a,int b,int c,int d){ query(1,n,a,b,out,q1,1),query(1,n,c,d,in,q2,1); int t1=++node,t2=++node; addedge(t1,t2,1); for(auto x:q1)addedge(x,t1,0); for(auto x:q2)addedge(t2,x,0); q1.clear(),q2.clear();}void bfs(){ query(1,n,S,S,in,q1,1); S=q1.back(); deque&lt;int&gt; q; mst(dis,-1); dis[S]=0,q.pb(S); while(!q.empty()) { int u=q.front(); q.ppf(); if(v[u])continue; else v[u]=1; gow(u)if(dis[v]==-1||dis[u]+w&lt;dis[v]) dis[v]=dis[u]+w,(w?q.pb(v):q.pf(v)); }}void print(int l,int r,int cnt){ if(l==r){printf(&quot;%d\\n&quot;,dis[in[cnt]]);return;} print(l,mid,ls),print(mid+1,r,rs);}int work(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;S); build(1,n,1); while(m--) { int a,b,c,d;scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d); link(a,b,c,d),link(c,d,a,b); } bfs(),print(1,n,1); return 0;}","link":"/2020/05/01/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E8%A3%82-%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE-%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%89%E8%BF%9E/"},{"title":"COT1 &amp;&amp; COT2 简要题解","text":"COT1COT - Count on a tree 题意求树上某个路径 $(u,v)$ 上所有数中的第 $k$ 大 SOL类似于序列上的做法，对于每个点 $u$ 维护它到根路径上所有数的权值线段树 $tree[u]$，路径 $(u,v)$ 上所有数构成的权值线段树可以看作是 $tree[u] + tree[v] - tree[lca] + val[lca]$$，求 $k$ 大的方法同序列。 1234567891011121314151617181920212223242526272829303132333435363738394041vector&lt;int&gt; X;int n,m,L;int a[MAXN],fa[MAXN];int s[N],ls[N],rs[N],cnt,root[MAXN];void insert(int pre,int &amp;rt,int l,int r,int val){ if(!rt)rt=++cnt; s[rt]=s[pre]+1; if(l==r)return; if(val&lt;=mid)insert(ls[pre],ls[rt],l,mid,val),rs[rt]=rs[pre]; else insert(rs[pre],rs[rt],mid+1,r,val),ls[rt]=ls[pre];}int query(int pre,int rt1,int rt2,int l,int r,int k){ if(l==r)return l; int t=s[ls[rt1]]+s[ls[rt2]]-2*s[ls[pre]]+(a[L]&gt;=l&amp;&amp;a[L]&lt;=mid); if(t&gt;=k)return query(ls[pre],ls[rt1],ls[rt2],l,mid,k); else return query(rs[pre],rs[rt1],rs[rt2],mid+1,r,k-t);}void dfs(int u,int par=0){ fa[u]=par,insert(root[par],root[u],1,X.size(),a[u]); go(u)if(v!=par)dfs(v,u);}int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); fp(i,1,n)scanf(&quot;%d&quot;,&amp;a[i]),X.pb(a[i]); sort(all(X)),unq(X); fp(i,1,n)a[i]=lb(all(X),a[i])-X.begin()+1; fp(i,1,n-1) { int u,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v),addedge(v,u); } dfs(1,0),lca::init(n); while(m--) { int u,v,k;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;k),L=lca::query(u,v); printf(&quot;%d\\n&quot;,X[query(root[L],root[u],root[v],1,X.size(),k)-1]); } return 0;} COT2题意每个点有个颜色 $a[u]$，求树上某个路径 $(u,v)$ 上的颜色种类数 SOL1 在线做法 树分块 可持久化块状数组前置技能1: 可持久化块状数组前置技能2: 树分块SOL2 离线做法 树上莫队坑","link":"/2020/03/31/COT1-COT2-%E7%AE%80%E8%A6%81%E9%A2%98%E8%A7%A3/"},{"title":"刷题记录","text":"问就是鸽了 2020.3.25CF EDU 84 (7/7)A 简单数学B 暴力C 构造全移动到一个点后走遍整个棋盘即可，总步数 $n-1+m-1+n*m$ D 暴力 数学每一个环分别处理，记它的长度为 $len$ 暴力可知，只有 $p^k$ 的 $k$ 是 $len$ 因子时才会分裂 枚举因子暴力 check 即可 复杂度 $O(n*sqrt(n))$ E 数学枚举 Block 的长度算一算 F DP感谢彭爹教我dp 位与位之间独立，总方案数就是每一位的答案乘起来 考虑第 $i$ 个限制，若 $x_{i}$ 这一位是 $1$，那么 $[l_{i},r_{i}]$ 只能放 $1$ 是 $0$ 那么说明 $[l_{i},r_{i}]$ 上至少有一个 $0$，暂时叫他 $0$ 限制 记 $f[i][0/1]$ 表示所有 $r_{i}&lt;=i$ 的限制都已经满足 且 第 $i$ 位是 $0/1$ 的方案数 若第 $i$ 位有强制是 $1$ 的限制： f[i][0]=0否则第 $i$ 是 $0$ 总是合法的 ： f[i][0]=f[i-1][0]+f[i-1][1]若第 $i$ 位放 $1$，那么必定有一个 $j(j&lt;=i)$ 是 $0$ 来满足那些 $r_{i}$ 在 $[j,i]$ 范围内的 $0$ 限制 考虑枚举所有符合条件的 $j$ 进行转移，即第 $j$ 位是 $0$，$[j+1,i]$ 位都是 $1$ 但后缀 $1$ 也不能无限制的放，因为可能会将 $0$ 限制的区间占满 记 $s0_{i}$ 为所有 $r_{i}&lt;=i$ 的0限制的 $l_{i}$ 的最大值，可以发现后缀 $1$ 最左可以放到 $s0_{i}$ 因此: f[i][1]=\\sum_{j=s0_{i}}^{i-1} f[j][0]用前缀和可以优化到线性 O(n) G AC自动机 状压 DP优化首先考虑暴力dp，$f[i][j][s]$ 表示构造了长度为 $i$ 的字符串，匹配到了 AC自动机上的 $j$ 节点，$s$ 是二进制串，表示问号用过了那些字符 第一维可以滚掉，但复杂度不降 注意到问号最多 $14$ 个，即大多数转移都是固定的，贡献也是固定的，可以提前算出非问号段的转移方向和贡献，从而加速dp 所以总复杂度是 $O(1410002^{14}+1000*4e5)$ 2020.3.26CF Global Round 4 (8/9)A 暴力B 前缀(后缀)和 dpC 数学答案是 $2^{n+m}$，快速幂 D 构造给定点数 $n$，构造一个总边数是质数，且每个点的度数都是质数的图 我的做法是连成一个环，找一些度数为 2 的连互连凑到最近的质数 E 暴力 性质给一个长度为 $n$ 只包含 abc 三种字符的字符串，且保证相邻字符不相同，请你找一个长度至少为 $\\lfloor \\frac{n}{2} \\rfloor$ 的回文子序列 考虑字符串的头两个字符和后两个字符，一定存在两个字符相等，把这对找出来加到回文子序列里 即每 $4$ 的长度至少贡献 $2$ 长度的回文，所以答案永远存在 F1 区间 dpF2 区间 dp plusG 凸壳 dfs序 分块抄了题解 维护 $ans=(A_{i}+x)*B_{i}$ 的区间最大值，支持 $x$ 的区间加操作 分块，维护块上加法标记 块内维护凸壳 CF1326F1 Wise Men (Easy Version)meet in mid 状压 dp 冲不过。。抄了题解 2020.3.27CF 629 Div.3E 树lca首先拿儿子一定没有拿父亲更优，因此标记所有询问节点的父亲，在判断一下是否在一条链上 我判链的方法是所有节点按深度排序，判相邻两节点的lca是否在他们俩之间 F 暴力 前缀和最后相等的 $k$ 个数一定是某个 $a_{i}$ 枚举算一算 BZOJ 1260 [CQOI2007]涂色paint 区间dpHDU 2476 区间dp上面那题加强版 CF 522 Div.2 (5/7)A 读题 暴力B 暴力C DP 记录方案D 几何A B 两点可唯一确定一个矩形，求出矩形与直线的交点后暴力算一算，答案取 min E DP 数学只有两种数的情况特判掉 否则答案选的一定是一些重量相等的数 $dp[i][j]$ 选 $i$ 个数和为 $j$ 的方案数，dp搞一搞 考虑各种情况下能唯一确定，记 $cnt[i]$ 为重量 $i$ 出现的次数 当 (j % i == 0) &amp;&amp; dp[i][j] == C(cnt[j/i],i) 的时候可以唯一确定 符合条件的取个 max 即是答案 2020.3.28牛客 NC204019 序列自动机CF1183H 序列自动机牛客 NC204272 dsu on treeLuogu P2742 几何 凸包这题数据好弱。。。我用正方形卡了自己的AC代码 zoj 3537 几何 区间dp最优三角剖分 将凸多边形顺时针编号，$f[l][r]$ 代表将 $l…r$ 组成的多边形全割成三角形的最小代价 在最优割法中，边 $l-r$ 一定属于某个三角形之中，枚举三角形的第三个顶点 $k (l+1&lt;=k&lt;=r+1)$，转移方程为 $f[l][r] = min\\{f[l][k]+f[k][r]+w(l,k)+w(k,r)\\}$ LightOJ 1422 区间 dp有点像刷字符串那个题，乍一看和区间 dp 没啥关系 $f[l][r]$ 表示以 $l…r$ 顺序排列时的答案 考虑第 $r$ 件是否可以和某一个共享: f[l][r] = min\\{f[l][i]+f[i+1][r-1]+(a[i]!=a[k])\\}CF 149D 区间dp恶心 $f[l][r][cl(0…2)][cr(0…2)]$ 表示为区间 $l…r$ 染色，括号 $l$ 的颜色为 $c1$，括号 $r$ 的颜色为 $c2$ 的方案数 若 $l$ 与 $r$ 匹配，则要先判断颜色是否合法，再枚举与他相邻的括号的颜色进行转移 f[l][r][cl][cr] = \\sum_{}f[l+1][r-1][cl'][cr']否则，分别枚举与他们匹配的括号的颜色，这样 $l…r$ 就被分成了三段，分别 dp 计数乘在一起就行 2020.3.29牛客 NC13221 数位dp 数论分块为什么我会写数论的题 HDU 4283 区间dp难，抄了题解，枚举 $f[l][r]$ 枚举 $l$ 是第 $k$ 个进入房间然后转移： f[l][r] = min\\{f[l+1][l+k-1]+f[l+k][r]+(k-1)*a[i]+sum(l+k,r)*k\\}ZOJ 3469 区间dp同 Luogu P1220 关路灯 费用计算上的技巧 poj 1651 区间dp和某场训练赛杀狼那个猎人的题一样。。。 NOIP2000 乘积最大 dp练练python。。。才不是在水题 BZOJ 1090 区间dp$f[l][r]$ 表示 $s[l…r]$ 能缩成的最短字符串 拼一拼： f[l][r] = min\\{f[l][i]+f[i+1][r]\\}缩一缩： $f[l][r] = min\\{f[l][l+len-1]+cost(l,r,len)\\}$ BZOJ 1068 区间dp注意 M-R 组成的区间不能相交，其他的和上面差不多 BZOJ 1055 区间dp$f[l][r][k]$ 表示字符串 $s[l…r]$ 是否能合成单个字符 $k$ 转移枚举断点即可 f[l][r][k]|=(f[l][i][c1]\\&\\&f[i+1][r][c2])区间dp先刷到这里。。刷了 hzwer 和 kuangbin 的题单 2020.3.30BZOJ 1086 王室联邦一种树分快 学习 再补几道，from 【动态规划3】区间与环形动态规划 CF607B 区间dpluogu P3205 区间dpluogu P3146 区间dpluogu P3146 区间dpspoj COT1 主席树spoj COT2 树分快 可持久化块状数组2020.3.31BZOJ 2589同 spoj COT2，强制在线 卡了卡常 。。下午颓废。。 CF 630 div2$Nanako$ 做 $tester$ 的 场，兹磁一下 你妈的还说不是 math round A 数学判掉 x1=x=x2 &amp;&amp; (a||b) 和 y1=y=y2 &amp;&amp; (c||d) 的情况，然后判一下最终位置会不会越界 B 数学$\\sqrt{1000}$ 以内的质数最多 $11$ 个，暴力分一分 C 暴力 贪心$s[1]$ 一定和 $s[k]$ 相同，暴力统计所有循环该位置上的字母个数，保留出现位置最多的字母。 D 构造设 $k$ 的最高位 $1$ 在第 $mx$ 位(从 $0$ 开始编号)，构造答案矩阵 $2*3$： 令 $t=1&lt;&lt;(mx+1)$ $t+k,k,0$ $t,t+k,k$ E 数学 矩阵ksm设奇数为 $1$，偶数为 $0$，推一推可以发现合法的方案一定满足 (有偶数个0 || 有偶数个1)，因为如果有偶数个 0/1 一定可以通过不断改变位置最后碰到一起消掉 设 $f[i][0/1][0/1]$ 表示 $i$ 个格子，$0$ 有奇数/偶数个，$1$ 有奇数/偶数个，枚举最后一个格子放 $0/1$ 转移 显然是个线性递推式，矩阵ksm搞一搞，AC没烦恼 F 树上dp先转化一下题意，如果把不选也看成染一种颜色($0$)的话，这题等价于求： 给每个点染色 $(0/1/2)$-(在独立集中/不在独立集中/没选) 后选一些边，需满足不存在孤立的 $1/2$ 颜色的点，$1$ 颜色之间的点不能连边，求方案数。 定义状态： $f[u][0]$ u 点为颜色 $1$ 且不存在孤立点的方案数 $f[u][1]$ u 点为颜色 $2$ 且不存在孤立点的方案数 $f[u][2]$ u 点为颜色 $1$ 且 $u$ 是孤立点的方案数 $f[u][3]$ u 点为颜色 $2$ 且 $u$ 是孤立点的方案书数 $f[u][4]$ u 点为颜色 $0$ 的方案数 两棵树通过 $(u,v)$ 边来进行合并答案： dp[0] = f[u][0]*(f[v][0]+f[v][1]*2+f[v][3]+f[v][4]) + f[u][2]*(f[v][1]+f[v][3])$dp[1]=f[u][1](f[v][0]2+f[v][1]2+f[v][2]+f[v][3]+f[v][4])+f[u][3](f[v][0]+f[v][1]+f[v][2]+f[v][3])$ dp[2]=f[u][2]*(f[v][0]+f[v][1]+f[v][4])dp[3]=f[u][3]*(f[v][0]+f[v][1]+f[v][4])dp[4]=f[u][4]*(f[v][0]+f[v][1]+f[v][4])2020.4.1上午。。操作系统还是听听好 SPOJ COT2 树上莫队学了下树上莫队的做法，会专门开一篇写 WC2013 糖果公园 带修树上莫队CF 愚人节round不务正业草 A NoB 分解质因数C 二进制换位D 判奇偶E 画图染色 图像处理黑白F 判字符串能否被化学元素组成 dp2020.4.2luogu P4198 楼房重建 分块bzoj 3295 动态逆序对 分块/cdq之前用树状数组套动态开点A过了，补下其他几种做法 分块：每个块维护个vector，删除某个点时同一块内逆序对的暴力统计，其他块二分 cdq:坑着 bzoj 3744 区间逆序对 强制在线 分块类似蒲公英，块与块之间的答案 $ans[L][R]$ 先预处理出来，询问时在考虑不完整块的贡献 bzoj 4028 [HEOI2015]公约数数列 分块 暴力很妙。。。抄了题解 首先前缀 $gcd$ 这个东西有个很好的性质，即它最多有 $\\log_{2}{x}$ 种不同的取值(CF某树上 $gcd$ 也用了这个性质) 考虑分块，当某个块内的前缀 $gcd$ 相等的时候，我们只需要查块内是否存在前缀 $xor$ 和等于 $x/g$ 的位置 $i$ 假设当前是第 $k$ 块，那么块内某个位置 $i$ 的前缀 $xor$ 和又可以分为 (前 $k-1$ 块的 $xor$ 和)^(第 $k$ 块首部到 $i$ 的 $xor$ 和) 两部分，而当 $k$ 确定时前者是个定值，因此只需维护每个位置的块内前缀 $xor$ 和即可 因此对于每个块，我们维护以下几个值： $lgcd$：块左端点的前缀 $gcd$ 值 $rgcd$：块右端点的前缀 $gcd$ 值 $sgcd$：块内所有数的 $gcd$ $sxor$：块内所有数的 $xor$ 和 $set(S)$：块内所有位置的前缀 $xor$ 和组成的 $set$ 对于查询操作，我们从头枚举每个块，当块的 $lgcd$ == $rgcd$ 时，我们只需在 $set$ 里 $find$ 一下是否存在符合条件的位置 $i$；当块的 $lgcd$ != $rgcd$ 时我们大力枚举块内的每一个位置来查找答案。 由于前缀 $gcd$ 最多有 $\\log_{2}{x}$ 种取值，所以 $lgcd$ != $rgcd$ 的块最多有 $\\log_{2}{x} + 1$ 个，复杂度有保证 对于单点修改操作，我们只需暴力重建 $x$ 所在的块，并更新后面所有块的 $lgcd$ 与 $rgcd$ 即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const int SZ = 500;int n,m;int id[MAXN];LL a[MAXN];struct block{ int l,r; LL lgcd,rgcd,sgcd,sxor; vector&lt;LL&gt; v; inline bool find(LL x) { vector&lt;LL&gt;::iterator it = lb(all(v),x); return it!=v.end()&amp;&amp;*it==x; }}b[MAXN/SZ+5];void build(int k){ b[k].v.clear(); LL pre=0,g=a[b[k].l]; fp(i,b[k].l,b[k].r)pre^=a[i],b[k].v.pb(pre),g=__gcd(g,a[i]); sort(all(b[k].v)); b[k].sxor=pre; b[k].lgcd=k?__gcd(b[k-1].rgcd,a[b[k].l]):a[b[k].l]; b[k].sgcd=g; b[k].rgcd=__gcd(b[k].lgcd,b[k].sgcd);}int work(){ scanf(&quot;%d&quot;,&amp;n); fp(i,1,n)scanf(&quot;%lld&quot;,&amp;a[i]); fp(i,1,n)id[i]=(i-1)/SZ+1; fp(i,1,n)if(!b[id[i]].l)b[id[i]].l=i; fd(i,n,1)if(!b[id[i]].r)b[id[i]].r=i; fp(k,1,id[n])build(k); scanf(&quot;%d&quot;,&amp;m); while(m--) { char s[10]; scanf(&quot;%s&quot;,s+1); LL x,y; if(s[1]=='M') { scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y),x++,a[x]=y,build(id[x]); LL g=b[id[x]].rgcd; fp(k,id[x]+1,id[n]) { b[k].lgcd=__gcd(g,a[b[k].l]); b[k].rgcd=__gcd(g,b[k].sgcd); g=__gcd(g,b[k].sgcd); } } else { scanf(&quot;%lld&quot;,&amp;x); LL sxor=0,sgcd=a[1];bool flag=0; fp(k,1,id[n]) { if(b[k].lgcd!=b[k].rgcd||(x%b[k].lgcd==0&amp;&amp;b[k].find((x/b[k].lgcd)^sxor))) { LL s=0,g=a[b[k].l]; fp(i,b[k].l,b[k].r) { s^=a[i],g=__gcd(g,a[i]); if((s^sxor)*__gcd(g,sgcd)==x) {printf(&quot;%d\\n&quot;,i-1);flag=1;break;} } } sxor^=b[k].sxor,sgcd=__gcd(sgcd,b[k].sgcd); if(flag)break; } if(!flag)puts(&quot;no&quot;); } } return 0;} 2020.4.3bzoj 1926 二分 莫队CF 631 div.2I_LOVE_DREAMOON ABC 贪心D 数学 dp2020.4.4GCJ 资格赛A 模拟B 每次选一段区间减去最小值C 二分图D 交互$B = 10$ 有手就行 $B = 20$ 考虑四种操作其实对 $i$ 和 $B-i+1$ 的关系(相等/不相等)没有影响，$20$ 次询问每一对 $(i,B-i+1)$，最后在一组内问出数组的一半，另一半根据相等/不等关系推得 $B = 100$ 先找 E 只会暴力bzoj 4129 树上待修mex 树上待修莫队 分块打打板子 spoj qtree1 树剖spoj qtree2 倍增倍增可以干的事还挺多的。。 spoj qtree3 树剖 set树剖的原理就是把树剖成若干链，同一链内的节点标号连续 同理 $1$ ~ $u$ 的路径也可以拆成若干重链(不一定完整)，用 $set$ 维护每个链内黑点，按深度排序 跳重链询问的时候注意只有深度 &lt;=d[x] 的点才可以更新答案，不然有可能不在路径上 2020.4.5颓废++ luogu P4332 LCTbzoj 2959 LCT 并查集如果加边保证原图一直是一棵树，那么 $a$ -&gt; $b$ 的路径显然是唯一的 如果加边出现了环，这个环内的所有 $a_{i}$ 我们都可以拿到，并且可在任意一点进入/出去，相当于环缩成了一个点 考虑使用 $lct$ 维护这个过程，把 $a$ -&gt; $b$ 的路径拿出来后暴力把他们的编号映射成一个新的点，连接到路径上的虚边可以不用动，这一步可以用并查集来实现 注意缩点以后每个点真实的 $fa[x]$ 都要在并查集里 $find$ 一下 2020.4.6颓废++++ 少做水题.. bzoj 4998 LCT 并查集同 bzoj 2959，并查集维护下siz即可 CF 503 div.2AB 模拟C 暴力 贪心D 交互 二分2020.4.7luogu P4172 LCT 最小生成树luogu P4180 LCT 严格次小生成树luogu P4234 LCTluogu P2387 LCTluogu P4219 LCT 维护子树信息2020.4.8CF 632 Div.2A 构造BC 乱搞D先暴力搞出最快移动方案，拆成大小为 $k$ 就行 F 数论$x$ 一定是在答案是他最大因子的那一轮加进去，暴力分解 2020.4.91900~2300 xjb练 [0]2h solved 3/5 CF 864E *2000 dp$d_{i}$ 小的肯定先救，按 $d_{i}$ sort 后按时间轴 dp，$f[i][j]$ 表示考虑前 $i$ 个物品，当前在时间 $j$ 时能救的最大价值，记录方案 dp CF 853B *1900 乱搞直接暴力枚举停留的时间点 $[i,i+k-1]$，然后搞个 $multiset$ 维护一下前后每个人来和去最便宜的航班 CF 865B *1900 贪心假如每个人都吃他最喜欢的那个种类的披萨，设 $A$ 种披萨的需求量为 $Sa$，$B$ 的需求量为 $Sb$，若 $Sa$ % $S + Sb$ % $S$ &gt; $S$，则所有人都可以满足，否则有一些人需要放弃他最喜欢的那种，枚举最后一块披萨是 $A$ 还是 $B$ 的情况，按差值排序选最小的几个即可。 CF 862D *2000 交互 二分观察可以发现通过询问 $111110000$ 可以算出某段区间的 $0$ 和 $1$ 的个数，二分找左区间全是 $0$，有区间全是 $1$ 的位置就行 CF 808D *1900 乱搞枚举断开的位置，$set$ 查一查差值 QTREE6 lctlct维护同色联通快 2020.4.10CF EDU 85 2020.4.11GCJ 没进R2 颓废 ++++++ 2020.4.121900-2300 xjb刷 [1]solved 2/5 CF 1017D *1900 暴力$ 2^12 $ 种情况的价值开个桶存一下 CF 1015E2 *2000 贪心枚举中点贪心放星，check 的话搞个差分 CF 992D *2100 暴力如果没有 $1$, $P$ 往前乘不到 $100$ 次就爆 $2e18$ 了 考虑成段的 $1$ 一起处理，因为乘积不变，符合条件的位置最多一个 1900-2300 xjb刷 [2]CF 1067A *2000 dpCF 1067B *2000 bfs从叶子开始多点bfs，按题意check CF 1039B *2100 交互 二分二分，&lt;=40 rand一个点 CF 1037E *2100 bfs倒着考虑，首先把所有点都加进去，删掉那些度数 &lt;k 的点和他们连的边，这个可以用 bfs 来做 删掉一个边就看一下他连的那两个点的度数是否 &lt;k，如果 &lt;k 了就继续 bfs 删到不能删为止 边要用set存 CF 493 div.1A设 $0$ 有 $n$ 段，答案就是 $min\\{x(n-1)+y,yn\\}$ B 打表C 容斥CF 635 div.1AB2020.4.13CF 988E 暴力 *2100CF 962E 贪心 *2200难想 第一个 P 之前和最后一个 P 之后的 AB 一定都是相邻的直接连 考虑距离最近的两个 P 之间的 AB 如何连： P—A—A…A—P 加上 P—B—B..B—P P—A—A A—A—P 加上 P—B B—B—P 然后两个 P 再相连，解释一下就是断开其中最大的间隙 两种取个 $min$ 就是答案 CF 997E 数据结构 *3000区间 $good$ 的条件： $max-min==r-l$ 离线，对于每个右端点维护左面每个位置的答案，套路类似于 zzq 那题，搞两个单调栈，踢出元素的时候再线段树上更新一下，然后统计下 $(max-min)-(r-l)$ 是 $0$ 的有多少 但这样只能求固定某个右端点的答案，我们要的是右端点在 $[l,r]$ 时左端点 $&lt;=l$ 符合条件的点有多少个，即我们需要每个版本答案之和的线段树 主席树? 线段树上在维护一个 $save$ 标记，代表这一段区间需要对答案贡献一次，这个标记与时间无关，注意 $pushdown$ 时只能向最小值所在的儿子区间进行累加 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102namespace seg{ int mn[MAXN*4],num[MAXN*4],add[MAXN*4],save[MAXN*4];//,ans[MAXN*4]; LL saveans[MAXN*4]; inline void dosave(int cnt,int v) { saveans[cnt]+=1LL*num[cnt]*v,save[cnt]+=v; } inline void doadd(int cnt,int v){mn[cnt]+=v,add[cnt]+=v;} inline void down(int cnt) { if(add[cnt])doadd(ls,add[cnt]),doadd(rs,add[cnt]),add[cnt]=0; if(save[cnt]) { if(mn[ls]==mn[cnt])dosave(ls,save[cnt]); if(mn[rs]==mn[cnt])dosave(rs,save[cnt]); save[cnt]=0; } } inline void up(int cnt) { if(mn[ls]==mn[rs]) mn[cnt]=mn[ls],num[cnt]=num[ls]+num[rs]; else if(mn[ls]&lt;mn[rs]) mn[cnt]=mn[ls],num[cnt]=num[ls]; else mn[cnt]=mn[rs],num[cnt]=num[rs]; saveans[cnt]=saveans[ls]+saveans[rs]; } void build(int l,int r,int cnt) { if(l==r){mn[cnt]=0,num[cnt]=1;return;} build(l,mid,ls),build(mid+1,r,rs),up(cnt); } LL query(int l,int r,int nl,int nr,int cnt) { if(l==nl&amp;&amp;r==nr)return saveans[cnt]; down(cnt); if(nr&lt;=mid)return query(l,mid,nl,nr,ls); if(nl&gt; mid)return query(mid+1,r,nl,nr,rs); return query(l,mid,nl,mid,ls)+query(mid+1,r,mid+1,nr,rs); } void rangeadd(int l,int r,int nl,int nr,int v,int cnt) { if(l==nl&amp;&amp;r==nr){doadd(cnt,v);return;} down(cnt); if(nr&lt;=mid)rangeadd(l,mid,nl,nr,v,ls); else if(nl&gt;mid)rangeadd(mid+1,r,nl,nr,v,rs); else rangeadd(l,mid,nl,mid,v,ls),rangeadd(mid+1,r,mid+1,nr,v,rs); up(cnt); } void rangesave(int l,int r,int nl,int nr,int v,int cnt) { if(l==nl&amp;&amp;r==nr){if(mn[cnt]==0)dosave(cnt,v);return;} down(cnt); if(nr&lt;=mid)rangesave(l,mid,nl,nr,v,ls); else if(nl&gt;mid)rangesave(mid+1,r,nl,nr,v,rs); else rangesave(l,mid,nl,mid,v,ls),rangesave(mid+1,r,mid+1,nr,v,rs); up(cnt); }} int n,m;int a[MAXN],l[MAXN],r[MAXN]; LL ans[MAXN];vector&lt;int&gt; pos[MAXN];struct elem{ int l,r,v; bool operator &lt;(const elem &amp;t)const{return v&lt;t.v;} bool operator &gt;(const elem &amp;t)const{return v&gt;t.v;}};stack&lt;elem&gt; mx,mn; int work(){ scanf(&quot;%d&quot;,&amp;n); fp(i,1,n)scanf(&quot;%d&quot;,&amp;a[i]); scanf(&quot;%d&quot;,&amp;m); fp(i,1,m)scanf(&quot;%d%d&quot;,&amp;l[i],&amp;r[i]),pos[r[i]].pb(i); seg::build(1,n,1); fp(i,1,n) { if(i&gt;1)seg::rangeadd(1,n,1,i-1,-1,1); elem cur = {0,i,a[i]}; while(!mx.empty()&amp;&amp;cur&gt;mx.top()) { elem t=mx.top(); mx.pop(); seg::rangeadd(1,n,t.l,t.r,-t.v,1); } cur.l=mx.empty()?1:(mx.top().r+1); mx.push(cur); seg::rangeadd(1,n,cur.l,cur.r,a[i],1); while(!mn.empty()&amp;&amp;cur&lt;mn.top()) { elem t=mn.top(); mn.pop(); seg::rangeadd(1,n,t.l,t.r,t.v,1); } cur.l=mn.empty()?1:(mn.top().r+1); mn.push(cur); seg::rangeadd(1,n,cur.l,cur.r,-a[i],1); seg::rangesave(1,n,1,i,1,1); for(auto j:pos[i]) ans[j]=seg::query(1,n,l[j],r[j],1); } fp(i,1,m)printf(&quot;%lld\\n&quot;,ans[i]); return 0;} 2020.4.14CF 634 Div.31335 E2 暴力答案一定是从尽量靠两边的位置选 $a$，中间的部分选出现次数最多的字母，处理下前缀和枚举两边的字母和长度就行 复杂度是 $O(200*n)$，一开始还以为是 $O(200*200*n)$，其实每个位置只会被枚举到一次，所以是 $n$ 级别的而非 $200*n$ 1335 F 倍增观察可以发现这图其实是个基环树，走足够步数后所有机器人都会在环上转，即树上每个点都与环上点一一对应 那么 $ans1$ 就是所有环的大小之和，$ans2$ 就是有多少黑点能上环 考虑倍增走个 $2e6$ 步，肯定就上环了，剩下就好做了 $O(nlogn)$ 跑的慢点，但码量少呀 1900-2300 xjb刷 [3]2/5 CF 909E *2100 拓扑把拓扑排序扩展一下，每轮先拿黑点到拿不动位置，再不断拿白点到拿不动位置 白点拿的轮数就是答案 CF 912D *2100 期望 数据结构首先格子上每个点对答案的贡献是固定的，我们只要选前 $k$ 大加起来就是最优解 打表观察发现贡献矩阵是从中心向四周递减 由于 $k==1e5$，我们用类似 $bfs$ 的做法， 每次选队列中权值最大的点，然后向四周扩展 最多扩展 $4*1e5$ 次，复杂度不会炸 1900-2300 xjb刷 [4]2/5 1012C CF 1012C *2000 dp$dp[i][j][0/1]$ 表示前 $i$ 个坑，造 $j$ 个房子，最后一个山有没有被砍过 这么定义是因为如果一个山被砍过，他一定是 $min(a[i],a[i-1]-1)$ 的高度 转移脑补一下，特判 $n=1$ 和 $n=2$ CF 1061D *2000 贪心 sort stl按 $pair$ 排序，贪心选一个右端点离当前左端点最近的，如果放不下 或 新开一个更合适就新开一段 找 $&lt;l$ 最大的右端点用 $set$ 就行 CF 1030E *2100 暴力zzqnb就完了 把每个数换成 $bitcount(x)$，然后转化题意，问有多少区间满足 每次选俩数减 $1$，可以把区间内的数全减乘 $0$ 区间内的数可以减为 $0$ 的条件: 1.$\\sum_{i=l}^{r}a[i]&gt;=2*max\\{a[l]…a[r]\\}$ 2.$\\sum_{i=l}^{r}a[i]$ % $2 == 0$ 由于 $1&lt;=a[i]&lt;=64$，长度大于 $128$ 的区间一定满足条件 $1$，只要判下条件 $2$ 即可，这个用通过统计前缀和奇偶性可以 $O(1)$ 来算 长度 $&lt;=128$ 的区间暴力判两个条件 复杂度：$O(nlogn)$ CF 1028D *2100 模拟意义不明 每次 $accept$ 确定一些 $buy$ 和 $sell$，自己不确定 $ans*=2$ 最后一段 $add$ 枚举分界点 $ans*=(siz+1)$","link":"/2020/03/27/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"网络流24题 简要题解","text":"洛谷 LOJ 下面用到的 (flow,cost) 表示边的容量和费用，S表示源点，T表示汇点 AC 23/24 题解 6/23 1.餐巾计划问题费用流 首先建立 2*n 个节点，1~n 代表每日的餐巾需求量，n+1 ~ 2*n 代表每日可以提供的脏毛巾。 从 S 到 1~n 分别连 (inf,p) 的边表示每日可以购买无限量的毛巾 从 1~n 到 T 分别连 (w[i],0) 的边表示每日需求毛巾量 从 S 到 n+i (1&lt;=i&lt;=n) 连 (w[i],0) 的边代表每日可提供 w[i] 的脏毛巾 从 n+i 到 i+m (1&lt;=i&lt;=n) 连 (w[i],f) 的边代表快洗部，慢洗同理 最后从 i 到 i+1 (1&lt;=i&lt;=n-1) 连 (inf,0) 的边代表洗好的毛巾可以留到下一天 2.[CTSC1999]家园最大流 先判断是否优解，并查集合并所有飞船可到达点，判断起点终点是否联通 地球月球可看作两个特殊的空间站，然后对每个时间点都建一套全新的空间站和飞船 每个时间的飞船和停靠站(当前时间下)连 inf 的双向边，表示人可上下飞船 上一时间的飞船向当前时间的飞船连 hpi 的边，代表飞船最多可运送 hpi 的人 上一时间的空间站向当前时间的空间站连 inf 的边，表示人留在空间站不动 源点向初始时间的地球连 k 的边，表示共有 k 人需要运输 每个时间点的月球向汇点连 k 的边，表示到达终点 建完图后不断增加时间，增广，直到最大流 == k 3.飞行员配对方案问题二分图最大匹配 用最大流做的话就是 S 向左边点连容量 1 的边，左边点向右边点能配对的连容量 1 的边，右边点向 T 连容量 1 的边 看题解说 Dinic 比 匈牙利快不知真假。。有时间测测 4.软件补丁问题最短路(用最短路转移的dp，类似分层图) 每个点的编号 id 表示 bug 的修补的状态，即二进制上这位是 0 代表已修复，1 代表未修复，能用补丁的点之间连有向边，权值为打补丁所需时间，求个从 $2^n-1$ 到 $0$ 的最短路 注意边存不下，松弛的时候动态建边 5.太空飞行计划问题最小割 最大权闭合子图 一般的最大权闭合子图问题：给定一个联通的 DAG，每个点有权重，选一个点就必须选以该点为出边的所有点(依赖关系)，求一个合法的选点方案使得点权和最大。 考虑最小割建模，点权为正的点为左部图，点权为负的点为又部图，S 向左部点练 wi 的边，右部图向 T 连 -wi 的边，对于原图中的边 从点 u 向点 v 连 inf 的边，记最小割为 cut，答案即为所有正点权之和减去 cut。 简单说一下个人的理解，首先新图的一个割对应着原图的一种选择方案，割掉左边的边相当于弃掉某个正权的点，割掉右边的边相当于选择某个负权点 接下来考虑方案的合法性，反证以下，假设选了 u 没选 v 且 对应原图的一个有向边： 若 u、v 分别位于新图的两侧，设w[u]&gt;0，w[v]","link":"/2020/02/10/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98-%E7%AE%80%E8%A6%81%E9%A2%98%E8%A7%A3/"},{"title":"最大流&amp;&amp;费用流 板子整理","text":"3 种费用流在 loj 上测试的结果： EK + dij 5584ms Dinic + spfa 4649ms Dinic + dij 4870ms 推荐使用 dinic + dij，出题人人均卡 spfa … 网络流注意以下模板默认编号范围为 1~n，请确保所有编号（包括源汇点）都在此范围内，以防初始化不全。 最大流Dinic 用容量不为 0 的边构建层次图，在层次图上有方向的进行多路增广。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465int n,m,S,T;struct edge{ int u,v,next; LL flow;}e[N*2];int pre[MAXN],cur[MAXN],cnt=1;void add(int u,int v,LL flow){ e[++cnt]={u,v,pre[u],flow},pre[u]=cnt;}int dis[MAXN],q[MAXN];bool bfs() //构建分层图{ int h=1,t=0; mst(dis,0),q[++t]=S,dis[S]=1; while(h&lt;=t) { int u=q[h++]; for(int i=pre[u];i;i=e[i].next) { int v=e[i].v; if(!dis[v]&amp;&amp;e[i].flow) dis[v]=dis[u]+1,q[++t]=v; } } return dis[T];}LL dfs(int u,LL flow) //多路增广{ if(u==T||!flow)return flow; LL ret=0,d=0; for(int i=cur[u];i;i=e[i].next) { int v=e[i].v; cur[u]=i; //当前弧优化 if(dis[v]==dis[u]+1&amp;&amp;e[i].flow) { d=dfs(v,min(flow-ret,e[i].flow)); if(d)ret+=d,e[i].flow-=d,e[i^1].flow+=d; if(ret==flow)return ret; } } return ret;}LL dinic(){ LL ans=0; while(bfs()) { fp(i,1,n)cur[i]=pre[i]; ans+=dfs(S,linf); } return ans;}int work(){ scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;S,&amp;T); fp(i,1,m) { int u,v;LL flow; scanf(&quot;%d%d%lld&quot;,&amp;u,&amp;v,&amp;flow); add(u,v,flow),add(v,u,0); } return printf(&quot;%lld\\n&quot;,dinic());} 费用流1. Dinic Bfs改最短路算法将 Dinic 中的 bfs 构建层次图改成最短路算法（Spfa或带势函数的Dijkstra），每次沿着最短路图的方向进行增广。 Spfa123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int n,m,S,T;struct edge{int u,v,next;LL flow,w;}e[N];int pre[MAXN],cur[MAXN],cnt=1;void add(int u,int v,LL flow,LL w){e[++cnt]={u,v,pre[u],flow,w},pre[u]=cnt;}bool vis[MAXN];int q[MAXN],h,t; LL dis[MAXN];bool spfa()//建议用stl queue 手写要换成循环队列防越界{ fp(i,1,n)dis[i]=linf; mst(vis,0); h=1,t=0,vis[S]=1,dis[S]=0,q[++t]=S; while(h&lt;=t) { int u=q[(h++)%MAXN]; vis[u]=0; gow(u)if(e[i].flow&amp;&amp;dis[v]&gt;dis[u]+w) { dis[v]=dis[u]+w; if(!vis[v])vis[v]=1,q[(++t)%MAXN]=v; } } return dis[T]&lt;linf;}lpr ans;LL dfs(int u,LL flow){ if(u==T||!flow) return ans.fi+=flow,ans.se+=dis[u]*flow,flow; LL ret=0,d; vis[u]=1; //vis标记 防止在费用为 0 的边上反复跳 for(int i=cur[u];i;i=e[i].next) { int v=e[i].v;LL w=e[i].w; cur[u]=i; if(e[i].flow&amp;&amp;dis[u]+w==dis[v]&amp;&amp;!vis[v]) { d=dfs(v,min(e[i].flow,flow-ret)); if(d) e[i].flow-=d,e[i^1].flow+=d,ret+=d; if(ret==flow)return ret; } } return ret;}void mcf(){ while(spfa()) { mst(vis,0); fp(i,1,n)cur[i]=pre[i]; dfs(S,linf); }}int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); scanf(&quot;%d%d&quot;,&amp;S,&amp;T); fp(i,1,m) { int u,v; LL f,w; scanf(&quot;%d%d%lld%lld&quot;,&amp;u,&amp;v,&amp;f,&amp;w); add(u,v,f,w),add(v,u,0,-w); } mcf(); return printf(&quot;%lld %lld\\n&quot;,ans.fi,ans.se);} Dijkstra1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465int n,m,S,T;struct edge{int u,v,next;LL flow,w;}e[N];int pre[MAXN],cur[MAXN],cnt=1;void add(int u,int v,LL flow,LL w){ e[++cnt]={u,v,pre[u],flow,w},pre[u]=cnt;}bool vis[MAXN];LL dis[MAXN],h[MAXN];bool dij(){ priority_queue&lt;lpr&gt; q; fp(i,1,n)dis[i]=linf; dis[S]=0,q.push({0,S}); while(!q.empty()) { int u=q.top().se; LL d=-q.top().fi; q.pop(); if(d!=dis[u])continue; gow(u)if(e[i].flow&amp;&amp;dis[u]+w+h[u]-h[v]&lt;dis[v]) dis[v]=dis[u]+w+h[u]-h[v],q.push({-dis[v],v}); } //fp(i,1,n)cout&lt;&lt;dbgs2(i,dis[i])&lt;&lt;endl; return dis[T]&lt;linf;}lpr ans;LL dfs(int u,LL flow){ //cout &lt;&lt; dbgs(u) &lt;&lt; endl; if(u==T||!flow) return ans.fi+=flow,ans.se+=(dis[u]+h[u])*flow,flow; LL ret=0,d; vis[u]=1; for(int i=cur[u];i;i=e[i].next) { int v=e[i].v;LL w=e[i].w; cur[u]=i; if(e[i].flow&amp;&amp;dis[u]+w+h[u]-h[v]==dis[v]&amp;&amp;!vis[v]) { d=dfs(v,min(e[i].flow,flow-ret)); if(d) e[i].flow-=d,e[i^1].flow+=d,ret+=d; if(ret==flow)return ret; } } return ret;}void mcf(){ while(dij()) { mst(vis,0); fp(i,1,n)cur[i]=pre[i]; dfs(S,linf); fp(i,1,n)if(dis[T]&lt;linf)h[i]+=dis[i]; //维护势函数 }}int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); scanf(&quot;%d%d&quot;,&amp;S,&amp;T); fp(i,1,m) { int u,v; LL f,w; scanf(&quot;%d%d%lld%lld&quot;,&amp;u,&amp;v,&amp;f,&amp;w); add(u,v,f,w),add(v,u,0,-w); } mcf(); return printf(&quot;%lld %lld\\n&quot;,ans.fi,ans.se);} 2.EKDijkstra12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int n,m,S,T;struct edge{int u,v,next;LL flow,w;}e[N];int pre[MAXN],cur[MAXN],cnt=1;void add(int u,int v,LL flow,LL w){ e[++cnt]={u,v,pre[u],flow,w},pre[u]=cnt;}bool vis[MAXN];LL dis[MAXN],h[MAXN];int from[MAXN];bool dij(){ priority_queue&lt;lpr&gt; q; fp(i,1,n)dis[i]=linf; dis[S]=0,q.push({0,S}); while(!q.empty()) { int u=q.top().se; LL d=-q.top().fi; q.pop(); if(d!=dis[u])continue; gow(u)if(e[i].flow&amp;&amp;dis[u]+w+h[u]-h[v]&lt;dis[v]) dis[v]=dis[u]+w+h[u]-h[v],q.push({-dis[v],v}),from[v]=i; } return dis[T]&lt;linf;}lpr ans;void mcf(){ while(dij()) { LL flow=linf; for(int u=T;u!=S;u=e[from[u]].u) flow=min(flow,e[from[u]].flow); ans.fi+=flow,ans.se+=(dis[T]+h[T])*flow; for(int u=T;u!=S;u=e[from[u]].u) e[from[u]].flow-=flow, e[from[u]^1].flow+=flow; fp(i,1,n)if(dis[i]&lt;linf)h[i]+=dis[i]; }}int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); scanf(&quot;%d%d&quot;,&amp;S,&amp;T); fp(i,1,m) { int u,v; LL f,w; scanf(&quot;%d%d%lld%lld&quot;,&amp;u,&amp;v,&amp;f,&amp;w); add(u,v,f,w),add(v,u,0,-w); } mcf(); return printf(&quot;%lld %lld\\n&quot;,ans.fi,ans.se);}","link":"/2020/02/06/%E6%9C%80%E5%A4%A7%E6%B5%81-%E8%B4%B9%E7%94%A8%E6%B5%81-%E6%9D%BF%E5%AD%90%E6%95%B4%E7%90%86/"},{"title":"线段树分治小结","text":"标记永久化标记永久化是一种线段树上打标记的技巧，用来在某些场合代替 pushup 和 pusdown 操作，但无法处理标记在时间上的先后顺序和标记的叠加，具体可以见 线段树标记永久化个人理解 &amp; BZOJ 1513 [POI2006]Tet-Tetris 3D 顺便重写了一下这个题，可以留着做板子了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364int n=1000;struct seg{ int val[MAXN],cov[MAXN]; void docov(int v,int cnt) { val[cnt]=max(val[cnt],v); cov[cnt]=max(cov[cnt],v); } void down(int cnt) { if(cov[cnt]) docov(cov[cnt],ls), docov(cov[cnt],rs), cov[cnt]=0; } bool update(int l,int r,int nl,int nr,int v,int cnt) { if(l==nl&amp;&amp;r==nr) return docov(v,cnt),0; down(cnt),val[cnt]=max(val[cnt],v); if(nr&lt;=mid)return update(l,mid,nl,nr,v,ls); if(nl&gt; mid)return update(mid+1,r,nl,nr,v,rs); return update(l,mid,nl,mid,v,ls),update(mid+1,r,mid+1,nr,v,rs); } int query(int l,int r,int nl,int nr,int cnt) { if(l==nl&amp;&amp;r==nr)return val[cnt];down(cnt); if(nr&lt;=mid)return query(l,mid,nl,nr,ls); if(nl&gt; mid)return query(mid+1,r,nl,nr,rs); return max(query(l,mid,nl,mid,ls),query(mid+1,r,mid+1,nr,rs)); }}val[MAXN],cov[MAXN];int query(int l,int r,int nl,int nr,int y1,int y2,int cnt){ int ans=cov[cnt].query(1,n,y1,y2,1); if(l==nl&amp;&amp;r==nr)return max(ans,val[cnt].query(1,n,y1,y2,1)); if(nr&lt;=mid)return max(ans,query(l,mid,nl,nr,y1,y2,ls)); if(nl&gt; mid)return max(ans,query(mid+1,r,nl,nr,y1,y2,rs)); return max({ans, query(l,mid,nl,mid,y1,y2,ls), query(mid+1,r,mid+1,nr,y1,y2,rs) });}bool update(int l,int r,int nl,int nr,int y1,int y2,int v,int cnt){ val[cnt].update(1,n,y1,y2,v,1); if(l==nl&amp;&amp;r==nr) return cov[cnt].update(1,n,y1,y2,v,1),0; if(nr&lt;=mid)return update(l,mid,nl,nr,y1,y2,v,ls); if(nl&gt; mid)return update(mid+1,r,nl,nr,y1,y2,v,rs); return update(l,mid,nl,mid,y1,y2,v,ls),update(mid+1,r,mid+1,nr,y1,y2,v,rs);}int work(){ int a,b,q;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;q); while(q--) { int d,s,w,x,y; scanf(&quot;%d%d%d%d%d&quot;,&amp;d,&amp;s,&amp;w,&amp;x,&amp;y); int x1=x+1,x2=x+d,y1=y+1,y2=y+s; int h=query(1,n,x1,x2,y1,y2,1)+w; update(1,n,x1,x2,y1,y2,h,1); } return printf(&quot;%d\\n&quot;,query(1,n,1,n,1,n,1));} 线段树分治线段树常用来维护顺序序列上的区间信息(如区间和，区间最大值等)，而线段树分治则利用线段树来维护时间轴(操作的先后关系)，并利用标记永久化的思想来解决一些需要撤销操作的数据结构问题。 例题1: BZOJ 4184 shallot本题中需要你维护一个支持删除的线性基，脑补可知线性基的删除很麻烦(or不可做)。 我们把每次操作(包括询问在内)看作是一个时间点，那么每一个数 $a_{i}$ 都有一个可用的时间区间。类似于线段树打标记的做法，我们将这个区间拆成 $logn$ 个区间并覆盖在线段树上对应的节点上，具体来讲是线段树的每个节点维护一个 vector 来存这个标记。 然后我们考虑如何处理询问操作，每次询问可以看作是根节点到某个叶子节点的一条路径，我们只要将这条路径上的所有标记丢到一个线性基里做一次查询即可。 具体来讲就是递归处理到某个节点时先复制一份修改前的线性基(这一步O(logn))，然后把当前节点上的标记插入到线性基里，递归处理左右儿子，结束后再复制回来就实现了线性基的撤销操作。 复杂度的话，每个时间区间最多贡献 $logn$ 个标记，线性基插入复杂度 $logn$ 总复杂度 $O(nlognlogn)$。 123456void solve(int l,int r,linearbase s=linearbase(),int cnt=1){ for(auto x:cov[cnt])s.insert(x); if(l==r){ans[l]=s.query();return;} solve(l,mid,s,ls),solve(mid+1,r,s,rs);} 完整代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465struct linearbase{ int a[35]; linearbase(){mst(a,0);} void insert(int x) { fd(i,30,0)if(x&amp;(1&lt;&lt;i)) { if(!a[i]){a[i]=x;break;} else x^=a[i]; } } int query(int ans=0) { fd(i,30,0)if((ans^a[i])&gt;ans)ans^=a[i]; return ans; } void print() { fd(i,30,0)cout&lt;&lt;dbgs2(i,a[i])&lt;&lt;endl; }};int n;int a[MAXN],ans[MAXN];vector&lt;int&gt; cov[MAXN*4];map&lt;int,int&gt; tim,cnt;void cover(int l,int r,int nl,int nr,int val,int cnt){ if(l==nl&amp;&amp;r==nr){cov[cnt].pb(val);return;} if(nr&lt;=mid)cover(l,mid,nl,nr,val,ls); else if(nl&gt;mid)cover(mid+1,r,nl,nr,val,rs); else cover(l,mid,nl,mid,val,ls),cover(mid+1,r,mid+1,nr,val,rs);}void solve(int l,int r,linearbase s=linearbase(),int cnt=1){ for(auto x:cov[cnt])s.insert(x); if(l==r){ans[l]=s.query();return;} solve(l,mid,s,ls),solve(mid+1,r,s,rs);}int work(){ scanf(&quot;%d&quot;,&amp;n); fp(i,1,n) { scanf(&quot;%d&quot;,&amp;a[i]); if(a[i]&gt;0) { if(cnt[a[i]]==0)tim[a[i]]=i; cnt[a[i]]++; } else { cnt[-a[i]]--; if(cnt[-a[i]]==0) cover(1,n,tim[-a[i]],i-1,-a[i],1); } } for(auto x:cnt)if(x.se!=0) cover(1,n,tim[x.fi],n,x.fi,1); solve(1,n); fp(i,1,n)printf(&quot;%d\\n&quot;,ans[i]); return 0;} 例题2：LOJ121 「离线可过」动态图连通性类似于上一题，将每条边的存活的时间区间覆盖到线段树上，搞一个并查集，进入某个节点时合并一下当前节点上的标记，递归结束时倒着撤销掉合并操作即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int n,m;int f[MAXN],siz[MAXN];vector&lt;pr&gt; cov[N*4];struct query{int t,x,y,ans;}q[N];int find(int x){return x==f[x]?x:find(f[x]);}void merge(int x,int y,vector&lt;pr&gt; &amp;a){ x=find(x),y=find(y);if(x==y)return; if(siz[x]&gt;siz[y])swap(x,y); f[x]=y,siz[y]+=siz[x],a.pb({x,y});}void undo(pr opt){ int x=opt.fi,y=opt.se; f[x]=x,siz[y]-=siz[x];}#define ls (cnt&lt;&lt;1)#define rs (cnt&lt;&lt;1|1)void cover(int l,int r,int nl,int nr,pr e,int cnt){ if(l==nl&amp;&amp;r==nr){cov[cnt].pb(e);return;} if(nr&lt;=mid)cover(l,mid,nl,nr,e,ls); else if(nl&gt;mid)cover(mid+1,r,nl,nr,e,rs); else cover(l,mid,nl,mid,e,ls),cover(mid+1,r,mid+1,nr,e,rs);}void solve(int l,int r,int cnt){ vector&lt;pr&gt; seq; for(auto e:cov[cnt])merge(e.fi,e.se,seq); if(l==r)q[l].ans=(find(q[l].x)==find(q[l].y)); if(l!=r)solve(l,mid,ls),solve(mid+1,r,rs); reverse(all(seq));for(auto x:seq)undo(x);}map&lt;pr,int&gt; tim;int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); fp(i,1,n)siz[i]=1,f[i]=i; fp(i,1,m) { scanf(&quot;%d%d%d&quot;,&amp;q[i].t,&amp;q[i].x,&amp;q[i].y); if(q[i].x&gt;q[i].y)swap(q[i].x,q[i].y); pr t={q[i].x,q[i].y}; if(q[i].t==0)tim[t]=i; if(q[i].t==1)cover(1,m,tim[t],i,t,1),tim.erase(t); } for(auto p:tim)cover(1,m,p.se,m,p.fi,1); solve(1,m,1); fp(i,1,m)if(q[i].t==2)puts(q[i].ans?&quot;Y&quot;:&quot;N&quot;); return 0;}","link":"/2020/02/04/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB%E5%B0%8F%E7%BB%93/"},{"title":"Solution for ZZQ&#39;s Catforces","text":"ZZQ’s Catforces idea by Nanako &amp; bakapiano prepared by bakapiano &amp; zzq 题意本题的背景为一个简化版的 CF 赛制，$n$ 道题有一个初始分数 $a[i]$，掉分速度为 $b[i]$/每分钟 与与解题所需时间 $t[i]$，请你安排一个解题顺序使得得分： score = \\sum_{i=1}^{n} (a_{i} - b_{i}*\\sum_{j=1}^{i}t_{j})最大。 题解题目难度 medium- 注意到 $\\sum_{i=1}^{n}a_{i}$ 项与解题顺序无关，我们只需要最小化总掉分数即可。 首先我们任意安排一个解题顺序 $p_{1},…,p_{n}$，并尝试对当前得到的答案进行改进。设 $p$ 数组中相邻的两项为 $x,y(1 \\leq x &lt; y \\leq n)$，易知交换相邻两项对其他题目的得分没有影响(因为对于除 $x,y$ 的任意题目 $i$ 来说 $\\sum_{j=1}^{i}t_{j}$ 不变)，下面我们来推导在什么情况下交换 $x,y$ 两项能使得答案变得更优。 首先设 $pre = \\sum_{j=1}^{x-1}t_{j}$ 设交换前 $x,y$ 两项对答案的贡献： ans_{1}=a_{x}-b_{x}*(pre+t_{x})+a_{y}-b_{y}*(pre+t_{x}+t_{y})交换后的贡献： ans_{2}=a_{y}-b_{y}*(pre+t_{y})+a_{x}-b_{x}*(pre+t_{y}+t_{x})使答案更优的条件： ans1 < ans2化简可得： b_{x}*t_{y} t_{y}/b_{y}设$k_{i}=t_{i}/b_{i}$，注意到当 $k_{y}&lt;k_{x}$ 时交换相邻两项会使答案更优，因此我们可以选择序列中 $k_{i}$ 最小的一项并把它不断往前交换来使答案变的更优，然后选 $k_{i}$ 次小的一项 … 重复上述操作直至序列中的 $k_{i}$ 变得非递减，此使得到的排列便是最优解题顺序。 因此只需将所有题目按 $t_{i}/b_{i}$ 的顺序排序，$O(n)$ 计算答案即可，总复杂度 $O(nlogn+n)$ 可以在规定时限内通过本题。 tag: 贪心 sort 标称注意使用 $double$ 计算斜率可能会造成精度误差，sort 时使用自定义比较函数即可避免这一问题。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt; using namespace std;typedef long long LL;const int MAXN = 1e5+5;/*----------head----------*/int n;struct pro{LL a,b,t;}p[MAXN];LL s[MAXN],ans;int main(){ scanf(&quot;%d&quot;,&amp;n); fp(i,1,n) scanf(&quot;%lld%lld%lld&quot;,&amp;p[i].a,&amp;p[i].b,&amp;p[i].t),ans+=p[i].a; sort(p+1,p+1+n,[](pro a,pro b){return a.t*b.b&lt;b.t*a.b;}); fp(i,1,n) { s[i]=s[i-1]+p[i].t; ans-=s[i]*p[i].b; } printf(&quot;%lld\\n&quot;,ans); return 0;}","link":"/2020/01/16/Solution-for-ZZQ-s-Catforces/"},{"title":"Solution for ZZQ&#39;s Maximum AND","text":"ZZQ’s Maximum AND idea by bakapiano prepared by bakapiano 题意在 $n$ 个数中选恰好 $k$ 个使得这 $k$ 个数 $and$ 起来的和最大。 题解题目难度 easy+ 注意到位运算时各位的运算是相互独立的，因此我们可以将这 $n$ 个数拆成二进制并从高位到低位依次考虑。假设当前处理的是第 $i$ 位，我们首先统计在二进制下这一位是 $1$ 的数的个数 $num$，然后我们分两种情况进行讨论： 若 $k \\leq num$，说明存在一种选数的方案使得这一位是 $1$，此时我们可以抛弃这一位是 $0$ 的那些数而仅保留这一位是 $1$ 的数，可以这么做的依据是如果我们选择了某一个该位是 $0$ 的数作为 $k$ 个数中的一个，那么这一位 $and$ 起来的结果必然是 $0$，但是考虑到低位无论如何组合都不可能比这一位是 $1$ 的结果更优，因此我们不可能选择这一位是 $0$ 的那些数作为我们选择的结果之一。 若 $k &gt; num$，说明无论怎么选这一位 $and$ 的结果都必为 $0$，因此保留所有数并继续处理下一位即可。 时间复杂度 $O(nlogn)$，可以在规定时限内通过本题。 此外可以考虑一下 $m$ 组询问，每次询问给出 $k$ 的加强版怎么做：） tag: 贪心 位运算 标称123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt; using namespace std;const int MAXN = 1e5+5;int n,k;int val[MAXN];int solve(){ int ans=0; vector&lt;int&gt; a,b; for(int i=1;i&lt;=n;i++) a.push_back(val[i]); for(int i=20;i&gt;=0;i--) { int cnt=0; for(auto x:a) if(x&amp;(1&lt;&lt;i)) cnt++; if(cnt&gt;=k) { ans+=(1&lt;&lt;i); b.clear(); for(auto x:a) if(x&amp;(1&lt;&lt;i)) b.push_back(x); swap(a,b); } } return ans;} int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;val[i]); printf(&quot;%d\\n&quot;,solve()); return 0;}","link":"/2020/01/15/Solution-for-ZZQ-s-Maximum-AND-0/"},{"title":"高维前缀和&amp;子集枚举","text":"参考资料高维前缀和总结 heyuhhh 子集枚举$O(4^{n})$ 到 $O(3^{n})$ 的一个优化12345678for(int s=0;s&lt;(1&lt;&lt;n);s++){ for(int i=s;;i=(i-1)&amp;s) { //code here... if(!i) break; }} 首先，对于一个二进制下全是1的数不断减1可以遍历他的所有子集，i-1会把末尾的0都变成1，而&amp;s则保证了原先s上是0的位仍是0，整个循环相当于一个忽略s中是0的位而不断减1的过程。 复杂度证明 高维前缀和一维前缀和12for(int i=1;i&lt;=n;i++) a[i]+=a[i-1]; 二维前缀和123456for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a[i][j]+=a[i-1][j];for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a[i][j]+=a[i][j-1]; 相当于先对列求和，在对行求和 三维前缀和123456789101112for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) a[i][j][k]+=a[i-1][j][k];for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) a[i][j][k]+=a[i][j-1][k];for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) a[i][j][k]+=a[i][j][k-1]; 可以画个图理解下，，， N维前缀和？仿照上面的写法，$n$ 个 $n$ 重循环，每次对一个维度求和即可。 状压 &amp; 与子集枚举的联系对于一个 $n$ 维数组，设它所有维度上的最大值为 $k$，我们可以把 $n$ 维上的每一个点压成一个 $k+1$ 进制的数，求高维前缀和时用上面的方法即可。 二进制中的子集关系($i \\subset j$)可以看作是每一位上的偏序关系，而 $n$ 维前缀和刚好是满足这种偏序关系的。 所以，对于类似于这类问题： S_i = \\sum_{j\\subset i}A_jF_i = \\min_{}\\{A_j\\}, j\\subset iF_i = \\max_{}\\{A_j\\}, j\\subset i都可以使用高位前缀和的技巧将复杂度由 $O(3^{n})$ 降到 $O(n*2^{n})$ 代码也很好写： 1234for(int i=1;i&lt;=n;i++) for(int s=0;s&lt;(1&lt;&lt;n);s++) if((1&lt;&lt;(i-1))&amp;s) f[i]+=f[s^(1&lt;&lt;(i-1))]; 例题1.CF1221G Graph And Numbers题解先坑着，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132LL n,m,c;vector&lt;int&gt; G[MAXN]; LL fpow(LL x,LL k){ LL ans=1; while(k) { if(k&amp;1) ans=ans*x; x=x*x,k=k&gt;&gt;1; } return ans;} namespace paint{ bool flag=1; int col[MAXN]; void dfs(int u) { for(auto v:G[u]) { if(!col[v]) col[v]=-col[u],dfs(v); else if(col[u]+col[v]!=0) flag=0; } } LL solve() { fp(i,1,n)if(!col[i])c++,col[i]=1,dfs(i); //fp(i,1,n)cout &lt;&lt; dbgs2(i,col[i]) &lt;&lt; endl; return flag?fpow(2,c):0; }} LL solve0() //只有0{ int cnt=0; fp(i,1,n)if(G[i].size()==0)cnt++;//,cout&lt;&lt;dbgs(i)&lt;&lt;endl; return fpow(2,cnt);} LL solve1() //只有1{ return paint::solve();} LL solve2() //只有2{ return solve0();} bool check1(int s){ fp(u,1,n/2)for(auto v:G[u])if(v&lt;=n/2) { bool a=(1&lt;&lt;(u-1))&amp;s,b=(1&lt;&lt;(v-1))&amp;s; if(a&amp;&amp;b) return 0; } return 1;} bool check2(int s){ fp(u,n/2+1,n)for(auto v:G[u])if(v&gt;n/2) { bool a=(1&lt;&lt;(u-n/2-1))&amp;s,b=(1&lt;&lt;(v-n/2-1))&amp;s; if(a&amp;&amp;b) return 0; } return 1;} LL f[1&lt;&lt;25];LL solve01() //只有0 1{ LL ans=0; mst(f,0); fp(s,0,(1&lt;&lt;(n/2))-1) f[s]+=check1(s);//,cout&lt;&lt;dbgs2(bitset&lt;3&gt;(s),f[s])&lt;&lt;endl; fp(i,1,n/2)fp(s,0,(1&lt;&lt;(n/2))-1) if((1&lt;&lt;(i-1))&amp;s) f[s]+=f[s^(1&lt;&lt;(i-1))]; //cout &lt;&lt; endl; fp(s,0,(1&lt;&lt;(n/2))-1) cout&lt;&lt;dbgs2(bitset&lt;3&gt;(s),f[s])&lt;&lt;endl; fp(s,0,(1&lt;&lt;(n-n/2))-1)if(check2(s)) { int t=(1&lt;&lt;(n/2))-1; fp(u,n/2+1,n)if((1&lt;&lt;(u-n/2-1))&amp;s)for(auto v:G[u])if(v&lt;=n/2&amp;&amp;t&amp;(1&lt;&lt;(v-1))) t-=(1&lt;&lt;(v-1)); ans+=f[t]; } return ans;} LL solve02() //只有0 2{ return fpow(2,c);} LL solve12() //只有1 2{ return solve01();} int work(){ scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); if(m==0) return printf(&quot;0&quot;); fp(i,1,m) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); G[u].pb(v),G[v].pb(u); } LL ans=0; ans+=fpow(2,n);/* cout &lt;&lt; dbgs(solve0() ) &lt;&lt; endl; cout &lt;&lt; dbgs(solve1() ) &lt;&lt; endl; cout &lt;&lt; dbgs(solve2() ) &lt;&lt; endl; cout &lt;&lt; dbgs(solve01()) &lt;&lt; endl; cout &lt;&lt; dbgs(solve02()) &lt;&lt; endl; cout &lt;&lt; dbgs(solve12()) &lt;&lt; endl;*/ ans+=solve0(); ans+=solve1(); ans+=solve2(); ans-=solve01(); ans-=solve02(); ans-=solve12(); return printf(&quot;%lld\\n&quot;,ans);} 2.CF449D Jzzhu and Numbers题意： 给定数列 $a_{1}…a_{n}$，计算从中取一段子序列使其 $And$ 起来的和为 $0$ 的方案数。 SOL: 考虑容斥计算不合法的方案数，$And$ 后有一位为1的方案数 - 有两位为1的方案数… 然后考虑如何计算 $n$ 位为1的方案数，设 $f[s]$ 等于满足下面条件的 $a_{i}$ 的个数： $s$ 为1的二进制位上 $a_{i}$ 也为1 其他位上任意 可以发现这是个超集(取反后的子集)，求出 $f$ 数组后就可以愉快的容斥辣 123456789101112131415161718192021222324252627282930313233343536373839int lowbit(int x){return x&amp;-x;}int bitcount(int x,int cnt=0){while(x)x-=lowbit(x),cnt++;return cnt;} const LL MOD = 1000000007;LL fpow(LL x,LL k){ LL ans=1; while(k) { if(k&amp;1) ans=ans*x%MOD; x=x*x%MOD,k=k&gt;&gt;1; } return ans;}LL C(LL n,LL m){ if(n&lt;m) return 0; LL s1=1,s2=1; for(LL i=1;i&lt;=m;i++) s1=s1*((n-i+1)%MOD)%MOD; for(LL i=1;i&lt;=m;i++) s2=s2*i%MOD; return s1*fpow(s2,MOD-2)%MOD;} int n;LL s,f[MAXN],ans=0; int work(){ scanf(&quot;%d%lld&quot;,&amp;n,&amp;s); fp(i,1,n)scanf(&quot;%lld&quot;,&amp;f[i]); for(int k=0;k&lt;(1&lt;&lt;n);k++) { LL sum=s+n; for(int i=1;i&lt;=n;i++)if((1&lt;&lt;(i-1))&amp;k)sum-=f[i]+1; ans+=pow(-1,bitcount(k))*C(sum-1,n-1); ans%=MOD,ans+=MOD,ans%=MOD; } return printf(&quot;%lld\\n&quot;,ans);} 3.CF1234F Yet Another Substring Reverse题意： 给定一个字符串，你可以翻转一段子串(或者不)，之后求原字符串中满足字符两两不同的子串的最长长度。 字符只有 ‘a’~’t’ (20个) SOL： 首先考虑一下执行翻转操作后答案长啥样，一定是一段没翻转拼上一段翻转过的，所以可以将问题转化为 选两个子串拼起来得到一个新串且满足字符两两不同，求这个新串最长是多少。 考虑状压，$s$二进制位上的1/0代表这个字符出现/没出现。若 $i$ 想和 $s$ 拼到一起的话， $s$ 是1的位置上 $i$ 不能是1，而其他位上没有限制，用高维前缀和处理出满足上述条件的子串的最长长度 $f[i]$ 之后暴力枚举即可。 1234567891011121314151617181920212223242526272829303132333435363738int n;int f[1&lt;&lt;21],g[1&lt;&lt;21];char s[MAXN]; int lowbit(int x){return x&amp;-x;}int bitcount(int x){ int cnt=0; while(x) x-=lowbit(x),cnt++; return cnt;}void in(int f[],int pos,int len){ int t=0; for(int i=pos;i&lt;pos+len;i++) { int c=s[i]-'a'; if((1&lt;&lt;c)&amp;t) return; t|=(1&lt;&lt;c); } f[t]=bitcount(t);} int work(){ scanf(&quot;%s&quot;,s+1),n=strlen(s+1); fd(i,n,1)fp(l,1,min(n-i,20))in(f,i+1,l); fp(i,0,19)fp(j,0,(1&lt;&lt;20)-1) if((1&lt;&lt;i)&amp;j) f[j]=max(f[j],f[j-(1&lt;&lt;i)]); reverse(s+1,s+1+n); fd(i,n,1)fp(l,1,min(n-i,20))in(g,i+1,l); int ans=1; fp(s,0,(1&lt;&lt;20)-1) if(g[s]) ans=max(ans,f[((1&lt;&lt;20)-1)^s]+bitcount(s)); return printf(&quot;%d\\n&quot;,ans);} 题外话：有生之年终于AK了DIV3","link":"/2019/10/03/%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C-%E5%AD%90%E9%9B%86%E6%9E%9A%E4%B8%BE/"},{"title":"SAM 后缀自动机小结","text":"后缀自动机资料 陈立杰冬令营SAM讲稿 后缀自动机（SAM）学习笔记 ouuan OI wiki SAM 后缀自动机学习笔记 Menci 笔记后缀自动机上每个点代表的是一些 $endpos$ 相同且长度连续的一些字符串，状态 $u$ 表示的字符串的长度范围为 $[min(u),max(v)]$ 每个结点的 $par$ 是所有满足 $endpos[u] \\in endpos[v]$ 的 $v$ 中且 $endpos[v]$ 大小最小的状态 $v$。 有关 $par$ 的一些性质： $min(u)=max(par[u])+1$ $par[u]$ 所表示的字符串都是 $u$ 的后缀。 自动机接受的字符串为 $S$ 的所有子串。 表示字符串前缀 $Pre$ 的状态 $u$ 的 $max(u) = |Pre|$，从 $u$ 跳 $par$ 的话可以遍历 $Pre$ 的所有后缀。 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748namespace SAM{ int cnt=0,root,last; int len[MAXN*2],par[MAXN*2]; LL sum[MAXN*2]; map&lt;char,int&gt; nx[MAXN*2]; void newnode(int &amp;x) { x=++cnt; len[cnt]=par[cnt]=sum[cnt]=0; nx[cnt].clear(); } void init(){cnt=0,newnode(root),last=root;} void extend_sam(char c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; nx [n]=nx [q]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur,sum[cur]=1; } void build_sam(char s[]) { int n=strlen(s+1); for(int i=1;i&lt;=n;i++) extend_sam(s[i]);//,debug(); }}; 技巧 &amp; 应用求 $endpos$ 集合的大小/最大值/最小值考虑 $par$ 树的所有节点，$endpos$ 中 含有 $i$ 的深度最大的节点一定是表示前缀 $Pre_{i}$ 的状态，标记这个节点后用 dfs/拓扑/基排 逆推即可。 如果要求每个点 $endpos$ 的具体值可能需要 线段树合并/平衡树启发式合并。 1234567891011121314151617int seq[MAXN*2],buc[N];void sort_by_len(){ fp(i,1,cnt) buc[len[i]]++; fp(i,1,N-1) buc[i]+=buc[i-1]; fp(i,1,cnt) seq[buc[len[i]]--]=i;}void solve(){ fp(i,1,cnt) { int cur=seq[i]; f[par[cur]]+=f[cur]; //f[par[cur]]=min(f[par[cur]],f[cur]); //f[par[cur]]=max(f[par[cur]],f[cur]); }} $logn$ 查找某个子串在 $SAM$ 上对应的状态考虑倍增，预处理出每个节点在 $par$ 树上的$2^j$ 祖先，从表示 $S[1…r]$ 的叶子往上跳找到深度最小且满足 $max(u)&gt;=(r-l+1)$的 $u$ 即可。 1234567891011121314void init(){ for(int i=1;i&lt;=cnt;i++) nx[i][0]=par[i]; fp(k,1,20)fp(i,1,cnt)nx[i][k]=nx[nx[i][k-1]][k-1];}LL count(int l,int r){ int cur=suf[r]; fd(k,20,0) if(nx[cur][k]&amp;&amp;len[nx[cur][k]]&gt;=r-l+1) cur=nx[cur][k]; return sum[cur];} 两个串的LCS对 $S$ 串建立 $SAM$，拿 $T$ 串到 $SAM$ 上“运行” 具体来讲就是考虑 $T$ 的每个前缀 $pre_{i}$ 有多长的后缀是 $S$ 的一个子串，从 $pre_{i}$ 转移到 $pre_{i+1}$ 时看下当前状态是否存在到 $T[i+1]$ 的转移边，若不存在就不断跳 $par$ (删掉前面的一部分) 直到找到存在转移边的状态，同时维护在每个状态下的匹配长度，最后取个 $max$ 就是答案。 匹配过程十分类似于 $kmp$ 和 $AC$自动机 啊，，， 12345678910111213void solve(char s[]){ int L=0,ans=0,cur=root,n=strlen(s+1); for(int i=1;i&lt;=n;i++) { int c=s[i]-'a'; while(cur!=root&amp;&amp;!nx[cur][c]) cur=par[cur],L=len[cur]; if(nx[cur][c]) cur=nx[cur][c],L++; ans=max(ans,L); } printf(&quot;%d\\n&quot;,ans);} 本质不同的子串个数相同的子串一定被同一个状态所表示，所以对后缀自动机上每个状态所表示的子串长度求和即是答案。 ans = \\sum_{i=1}^{cnt}len[i]-len[par[i]]最小表示法先将字符串 $S$ 复制一倍后得到 $T$，可以发现 $T$ 的长度为 $n$ 的子串包含了 $S$ 通过循环移位所能得到的所有字符串，所以问题转化为求 $T$ 的长度为 $n$ 的子串中字典序最小的一个。 对 $T$ 建立 $SAM$ 后从 $root$ 开始贪心走转移边中字符最小的那条即可。 字典序k大子串统计出在每个状态通过转移边能到达的状态的数量 $f[u]$ ，从根节点开始从小到大枚举转移边 $v$ 若 $f[v]&gt;=k$ 则从 $u$ 转移到 $v$，否则将 $k$ 减去 $f[v]$ 后继续尝试字符更大的转移边。 12345678910111213141516171819202122232425262728293031323334void print(int cur,int k,int t,LL f[]){ if(!k) return; for(auto trans:nx[cur]) { if(f[trans.se]&gt;=k) { putchar(trans.fi),print(trans.se,k-(t?sum[trans.se]:1),t,f); break; } else k-=f[trans.se]; }}void solve(int k,int t){ fp(i,1,cnt) buc[len[i]]++; fp(i,1,N-1) buc[i]+=buc[i-1]; fp(i,1,cnt) seq[buc[len[i]]--]=i; fd(i,cnt,1) sum[par[seq[i]]]+=sum[seq[i]]; fd(i,cnt,1) { int cur=seq[i]; f[0][cur]=1,f[1][cur]=sum[cur]; for(auto trans:nx[cur]) { f[0][cur]+=f[0][trans.se]; f[1][cur]+=f[1][trans.se]; } } if(f[t][root]-(t==1?sum[root]:1)&lt;k) printf(&quot;-1\\n&quot;); else print(root,k,t,f[t]),putchar('\\n');} 多个串的LCS对其中一个串建立 $SAM$ 把剩下所有串放到 $SAM$ 上运行，类似于求两个串的 $LCS$ 的过程，运行每一个串的时候记录它在当前状态上的最大匹配长度，注意不同串在同一个状态上的匹配长度要取 $min$,最后统计答案即可。 1234567891011121314151617181920212223242526void run(string &amp;s,int id){ mst(f,0); int cur=root,L=0; fp(i,0,s.size()-1) { int c=s[i]-'a'; while(cur!=root&amp;&amp;!nx[cur][c]) cur=par[cur],L=len[cur]; if(nx[cur][c]) cur=nx[cur][c],L++; f[cur]=max(f[cur],L); } fd(i,cnt,1) { int cur=seq[i]; if(f[cur]) f[par[cur]]=len[par[cur]]; } if(id==2) fp(i,1,cnt) ans[i]=f[i]; else fp(i,1,cnt) ans[i]=min(ans[i],f[i]);}void solve(){ int L=0; fp(i,1,cnt) L=max(ans[i],L); cout &lt;&lt; L &lt;&lt; endl;} 广义SAM将 $SAM$ 推广到字典树上的产物，目前不太理解，，， 定义 $Trie$ 树的一个子串为节点 $u$ 到它子树中的节点 $v$ 的路径所形成的字符串，那么广义 $SAM$ 接受的状态为 $Tire$ 树上的所有子串。 $endpos$ 可视为 $Trie$ 树上的节点，$par$ 的定义不变。 模板离线构造，需要预先知道 $Tire$ 树的形态，从根节点开始 $bfs$，建立新节点时拿他父亲的状态作为 $last$ 执行普通 $SAM$ 的 $extend$ 即可。 还有一种做法是每插入一个串就把 $last$ 指向 $root$，但这样可能建出一些无用的节点(考虑一个字符串完全包含另一个的情况)。 [ZJOI2015]诸神眷顾的幻想乡 求多个串本质不同的子串个数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103const int K = 10;namespace SAM{ int root,cnt; int len[MAXN*2],par[MAXN*2]; int nx[MAXN*2][K+1]; void newnode(int &amp;x){x=++cnt;} void init(){cnt=0,newnode(root);} int extend(int c,int last) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; memcpy(nx[n],nx[q],sizeof(nx[q])); while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } return cur; } void solve() { LL ans=0; fp(i,1,cnt) ans+=len[i]-len[par[i]]; io.write(ans); io.push('\\n'); }}namespace Trie{ int root,cur,cnt; int nx[MAXN][K+1],fa[MAXN],last[MAXN]; void newnode(int &amp;x){x=++cnt;} void init(){cnt=0,newnode(root),cur=root;} void insert(int c) { if(!nx[cur][c]) newnode(nx[cur][c]),fa[nx[cur][c]]=cur; cur=nx[cur][c]; } void back(){cur=fa[cur];} void build_sam() { SAM::init(); queue&lt;int&gt; q; q.push(root); last[root]=SAM::root; while(!q.empty()) { int cur=q.front(); q.pop(); fp(i,0,K)if(nx[cur][i]) last[nx[cur][i]]=SAM::extend(i,last[cur]), q.push(nx[cur][i]); } }};struct edge{int u,v,next;};vector&lt;edge&gt; e;int n,c;int pre[MAXN],col[MAXN],in[MAXN];void addedge(int u,int v){e.pb({u,v,pre[u]}),pre[u]=e.size()-1;}void dfs(int u,int fa){ Trie::insert(col[u]); go(u) if(v!=fa) dfs(v,u); Trie::back();}int work(){ io.read(n),io.read(c),e.pb(edge()); fp(i,1,n) io.read(col[i]); fp(i,1,n-1) { static int u,v; io.read(u),io.read(v); addedge(u,v),addedge(v,u); in[u]++,in[v]++; } Trie::init(); fp(i,1,n) if(in[i]==1) dfs(i,-1); Trie::build_sam(); SAM::solve(); return 0;} 练习Luogu P3804 【模板】后缀自动机统计每个状态 $u$ 的 $endpos$ 集合的大小 $siz[u]$，所有的 $siz[u]*len[u]$ 取个 $max$ 就是答案123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990namespace SAM{ int cnt=0,root,last; int len[MAXN*2],par[MAXN*2]; LL sum[MAXN*2]; map&lt;char,int&gt; nx[MAXN*2]; void debug() { cout &lt;&lt; dbgs2(root,last) &lt;&lt; endl; for(int i=1;i&lt;=cnt;i++) { cout &lt;&lt; dbgs3(i,len[i],par[i]) &lt;&lt; endl; for(auto t:nx[i]) cout &lt;&lt; dbgs2(t.fi,t.se) &lt;&lt; endl; } cout &lt;&lt; endl; } void newnode(int &amp;x) { x=++cnt; len[cnt]=par[cnt]=sum[cnt]=0; nx[cnt].clear(); } void init(){cnt=0,newnode(root),last=root;} void extend_sam(char c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; nx [n]=nx [q]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur,sum[cur]=1; } void build_sam(char s[]) { int n=strlen(s+1); for(int i=1;i&lt;=n;i++) extend_sam(s[i]);//,debug(); }};char s[MAXN];struct edge{int u,v,next;};vector&lt;edge&gt; e={edge()};int pre[MAXN*2];void addedge(int u,int v){e.pb({u,v,pre[u]}),pre[u]=e.size()-1;}LL ans=0;void dfs(int u){ go(u) dfs(v),SAM::sum[u]+=SAM::sum[v]; //cout &lt;&lt; dbgs3(u,SAM::len[u],SAM::sum[u]) &lt;&lt; endl; if(SAM::sum[u]&gt;1) ans=max(ans,SAM::len[u]*SAM::sum[u]);}void solve(){ fp(i,2,SAM::cnt) addedge(SAM::par[i],i); dfs(1);}int work(){ scanf(&quot;%s&quot;,s+1); SAM::init(); SAM::build_sam(s); solve(); printf(&quot;%lld\\n&quot;,ans); return 0;} Luogu P1368 工艺求字符串的最小表示法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172namespace SAM{ const int K = 26; int cnt=0,root,last; int len[MAXN*2],par[MAXN*2]; map&lt;int,int&gt; nx[MAXN*2]; void newnode(int &amp;x) { x=++cnt; len[cnt]=par[cnt]=0; nx[cnt].clear(); } void init(){cnt=0,newnode(root),last=root;} void extend_sam(int c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; nx [n]=nx [q]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur; } void build_sam(int s[],int n){fp(i,1,n) extend_sam(s[i]);} void solve(int n) { int cur=root; while(n--) { io.write((nx[cur].begin())-&gt;fi); io.push(' '); cur=(nx[cur].begin())-&gt;se; } io.push('\\n'); }}int n;int s[MAXN];int work(){ io.read(n); fp(i,1,n) io.read(s[i]),s[i+n]=s[i]; n*=2; SAM::init(); SAM::build_sam(s,n); SAM::solve(n/2); return 0;} luogu P3804 【模板】后缀自动机 统计 $endpos$ 集合的大小，找到最大的 $sum[i]*len[i]$ 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990namespace SAM{ int cnt=0,root,last; int len[MAXN*2],par[MAXN*2]; LL sum[MAXN*2]; map&lt;char,int&gt; nx[MAXN*2]; void debug() { cout &lt;&lt; dbgs2(root,last) &lt;&lt; endl; for(int i=1;i&lt;=cnt;i++) { cout &lt;&lt; dbgs3(i,len[i],par[i]) &lt;&lt; endl; for(auto t:nx[i]) cout &lt;&lt; dbgs2(t.fi,t.se) &lt;&lt; endl; } cout &lt;&lt; endl; } void newnode(int &amp;x) { x=++cnt; len[cnt]=par[cnt]=sum[cnt]=0; nx[cnt].clear(); } void init(){cnt=0,newnode(root),last=root;} void extend_sam(char c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; nx [n]=nx [q]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur,sum[cur]=1; } void build_sam(char s[]) { int n=strlen(s+1); for(int i=1;i&lt;=n;i++) extend_sam(s[i]);//,debug(); }};char s[MAXN];struct edge{int u,v,next;};vector&lt;edge&gt; e={edge()};int pre[MAXN*2];void addedge(int u,int v){e.pb({u,v,pre[u]}),pre[u]=e.size()-1;}LL ans=0;void dfs(int u){ go(u) dfs(v),SAM::sum[u]+=SAM::sum[v]; //cout &lt;&lt; dbgs3(u,SAM::len[u],SAM::sum[u]) &lt;&lt; endl; if(SAM::sum[u]&gt;1) ans=max(ans,SAM::len[u]*SAM::sum[u]);}void solve(){ fp(i,2,SAM::cnt) addedge(SAM::par[i],i); dfs(1);}int work(){ scanf(&quot;%s&quot;,s+1); SAM::init(); SAM::build_sam(s); solve(); printf(&quot;%lld\\n&quot;,ans); return 0;} SPOJ 1811 LCS两个串的 $LCS$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576namespace SAM{ int cnt=0,root,last; int len[MAXN*2],par[MAXN*2]; int nx[MAXN*2][K]; void newnode(int &amp;x) { x=++cnt; len[cnt]=par[cnt]=0; for(int i=0;i&lt;K;i++) nx[cnt][i]=0; } void init(){cnt=0,newnode(root),last=root;} void extend_sam(int c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; for(int i=0;i&lt;K;i++) nx[n][i]=nx[q][i]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur; } void build_sam(char s[]) { int n=strlen(s+1); for(int i=1;i&lt;=n;i++) extend_sam(s[i]-'a'); } void solve(char s[]) { int L=0,ans=0,cur=root,n=strlen(s+1); for(int i=1;i&lt;=n;i++) { int c=s[i]-'a'; while(cur!=root&amp;&amp;!nx[cur][c]) cur=par[cur],L=len[cur]; if(nx[cur][c]) cur=nx[cur][c],L++; ans=max(ans,L); } printf(&quot;%d\\n&quot;,ans); }};char a[MAXN],b[MAXN];int work(){ scanf(&quot;%s&quot;,a+1); scanf(&quot;%s&quot;,b+1); SAM::init(); SAM::build_sam(a); SAM::solve(b); return 0;} Luogu P3649 [APIO2014]回文串马拉车 + SAM上倍增 其实是PAM模板题 首先考虑如何用马拉车求出本质不同的回文串，可以发现当扩展最长回文串的右边界时才会产生新的回文串，用 $SAM$ 统计出现次数即可。 注意扩展右边界时得到的回文串不一定就在之前从未出现过，如 $abadeaba$，所以用马拉车求本质不同回文串需要配上 $hash$ 来去重。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125namespace SAM{ const int K = 26; int cnt=0,root,last; int len[MAXN*2],par[MAXN*2],suf[MAXN]; LL sum[MAXN*2]; int nx[MAXN*2][K]; //int f [MAXN*2][21]; struct edge{int u,v,next;}; vector&lt;edge&gt; e={edge()}; int pre[MAXN*2]; void addedge(int u,int v){e.pb({u,v,pre[u]}),pre[u]=e.size()-1;} void dfs(int u){go(u)dfs(v),sum[u]+=sum[v];} void build_graph(){fp(i,2,cnt) addedge(par[i],i);} void newnode(int &amp;x) { x=++cnt; len[cnt]=par[cnt]=sum[cnt]=0; fp(i,0,K-1) nx[cnt][i]=0; } void init(){cnt=0,newnode(root),last=root;} void extend_sam(int i,int c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; fp(i,0,K-1) nx[n][i]=nx[q][i]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur,sum[cur]=1,suf[i]=cur; } void build_sam(char s[]) { int n=strlen(s+1); fp(i,1,n) extend_sam(i,s[i]-'a'); build_graph(),dfs(root); for(int i=1;i&lt;=cnt;i++) nx[i][0]=par[i]; fp(k,1,20)fp(i,1,cnt)nx[i][k]=nx[nx[i][k-1]][k-1]; } void debug() { for(int i=1;i&lt;=cnt;i++) { cout &lt;&lt; dbgs4(i,len[i],par[i],sum[i]) &lt;&lt; endl; } } LL count(int l,int r) { int cur=suf[r]; fd(k,20,0) if(nx[cur][k]&amp;&amp;len[nx[cur][k]]&gt;=r-l+1) cur=nx[cur][k]; return sum[cur]; }}LL ans=0;void calc(int l,int r){ans=max(ans,LL(r-l+1)*SAM::count(l,r));}namespace manacher{ int p[MAXN*2]; string a; void run(char s[]) { int m=strlen(s+1); a.pb('$'),a.pb('#'); for(int i=1;i&lt;=m;i++) a.pb(s[i]),a.pb('#'); a.pb('\\0'); int n=a.size()-1,id=0,mx=0; for(int i=1;i&lt;=n;i++) { if(mx&gt;i) p[i]=min(p[2*id-i],mx-i+1); else p[i]=1; while(a[i+p[i]]==a[i-p[i]]) { if(a[i+p[i]]!='#') calc((i-p[i])/2,(i+p[i])/2); p[i]++; } if(i+p[i]-1&gt;mx) mx=i+p[i]-1,id=i; } }}int n;char s[MAXN];int work(){ scanf(&quot;%s&quot;,s+1); n=strlen(s+1); SAM::init(); SAM::build_sam(s); //SAM::debug(); manacher::run(s); for(int i=1;i&lt;=n;i++) calc(i,i); return printf(&quot;%lld\\n&quot;,ans);} Luogu P4070 [SDOI2016]生成魔咒题意：求给定字符串每个前缀的本质不同子串个数 扩展 $SAM$ 时加上新节点的贡献即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172namespace SAM{ const int K = 26; int cnt=0,root,last; int len[MAXN*2],par[MAXN*2]; LL sum[MAXN*2],ans=0; map&lt;int,int&gt; nx[MAXN*2]; struct edge{int u,v,next;}; vector&lt;edge&gt; e={edge()}; int pre[MAXN*2]; void addedge(int u,int v){e.pb({u,v,pre[u]}),pre[u]=e.size()-1;} void dfs(int u){go(u) dfs(v),sum[u]+=sum[v];} void newnode(int &amp;x) { x=++cnt; len[cnt]=par[cnt]=0; nx[cnt].clear(); } void init(){cnt=0,newnode(root),last=root;} void extend_sam(int c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; nx [n]=nx [q]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur,sum[cur]=1; ans+=len[last]-len[par[last]]; io.write(ans); io.push('\\n'); } void build_sam(int s[],int n) { fp(i,1,n) extend_sam(s[i]); }}int n;int a[MAXN];int work(){ io.read(n); fp(i,1,n) io.read(a[i]); SAM::init(); SAM::build_sam(a,n); return 0;} Luogu P3975 [TJOI2015]弦论K小子串 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105namespace SAM{ int cnt=0,root,last; int len[MAXN*2],par[MAXN*2]; LL sum[MAXN*2],f[2][MAXN*2]; map&lt;char,int&gt; nx[MAXN*2]; void newnode(int &amp;x) { x=++cnt; len[x]=par[x]=sum[x]=f[0][x]=f[1][x]=0; nx[x].clear(); } void init(){cnt=0,newnode(root),last=root;} void extend_sam(char c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; nx [n]=nx [q]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur,sum[cur]=1; } void build_sam(char s[]) { int n=strlen(s+1); fp(i,1,n) extend_sam(s[i]); } int seq[MAXN*2],buc[N]; void print(int cur,int k,int t,LL f[]) { if(!k) return; //cout &lt;&lt; dbgs2(cur,k) &lt;&lt; endl; for(auto trans:nx[cur]) { if(f[trans.se]&gt;=k) { putchar(trans.fi),print(trans.se,k-(t?sum[trans.se]:1),t,f); break; } else k-=f[trans.se]; } } void solve(int k,int t) { fp(i,1,cnt) buc[len[i]]++; fp(i,1,N-1) buc[i]+=buc[i-1]; fp(i,1,cnt) seq[buc[len[i]]--]=i; //fp(i,1,cnt) cout &lt;&lt; dbgs3(seq[i],len[seq[i]],par[seq[i]]) &lt;&lt; endl; fd(i,cnt,1) sum[par[seq[i]]]+=sum[seq[i]]; fd(i,cnt,1) { int cur=seq[i]; //cout &lt;&lt; dbgs2(cur,sum[cur]) &lt;&lt; endl; f[0][cur]=1,f[1][cur]=sum[cur]; for(auto trans:nx[cur]) { f[0][cur]+=f[0][trans.se]; f[1][cur]+=f[1][trans.se]; } //cout &lt;&lt; dbgs3(cur,f[0][cur],f[1][cur]) &lt;&lt; endl; } if(f[t][root]-(t==1?sum[root]:1)&lt;k) printf(&quot;-1\\n&quot;); else print(root,k,t,f[t]),putchar('\\n'); }}int n,t,k;char s[MAXN];int work(){ scanf(&quot;%s&quot;,s+1); n=strlen(s+1); scanf(&quot;%d%d&quot;,&amp;t,&amp;k); SAM::init(); SAM::build_sam(s); SAM::solve(k,t); return 0;} Luogu P2463 [SDOI2008]Sandy的卡片多个串LCS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103namespace SAM{ int cnt=0,root,last; int len[MAXN*2],par[MAXN*2]; int f[MAXN*2],ans[MAXN*2]; map&lt;int,int&gt; nx[MAXN*2]; void newnode(int &amp;x){x=++cnt;} void init(){cnt=0,newnode(root),last=root;} void extend_sam(int c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; nx [n]=nx [q]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur; } int seq[MAXN*2],buc[N]; void sort_by_len() { fp(i,1,cnt) buc[len[i]]++; fp(i,1,N-1) buc[i]+=buc[i-1]; fp(i,1,cnt) seq[buc[len[i]]--]=i; } void build_sam(vector&lt;int&gt; &amp;s) { int n=s.size(); fp(i,0,n-1) extend_sam(s[i]); sort_by_len(); } void run(vector&lt;int&gt; &amp;s,int id) { mst(f,0); int cur=root,L=0; fp(i,0,s.size()-1) { int c=s[i]; while(cur!=root&amp;&amp;!nx[cur][c]) cur=par[cur],L=len[cur]; if(nx[cur][c]) cur=nx[cur][c],L++; f[cur]=max(f[cur],L); } fd(i,cnt,1) { int cur=seq[i]; if(f[cur]) f[par[cur]]=len[par[cur]]; } if(id==2) fp(i,1,cnt) ans[i]=f[i]; else fp(i,1,cnt) ans[i]=min(ans[i],f[i]); } void solve() { int L=0; fp(i,1,cnt) if(ans[i]!=inf) L=max(ans[i],L); io.write(L+1); }}int n,m;vector&lt;int&gt; s[MAXN];int work(){ io.read(m); fp(i,1,m) { static int tmp; io.read(n); fp(j,1 ,n) io.read(tmp),s[i].pb(tmp); fd(j,n-1,1) s[i][j]-=s[i][j-1]; s[i].erase(s[i].begin()); //cout &lt;&lt; dbgs(i) &lt;&lt; endl; } SAM::init(); SAM::build_sam(s[1]); //cout &lt;&lt; &quot;done&quot; &lt;&lt; endl; fp(i,2,m) SAM::run(s[i],i); SAM::solve(); return 0;} BZOJ 1396 识别子串设每个位置 $i$ 的最短识别子串长度为 $len[i]$ 考虑那些 $endpos$ 集合大小为 $1$ 的叶子节点 $u$，设它唯一的 $endpos$ 为 $i$，则这个节点对每个位置的贡献可分两种情况讨论： 满足 $j\\in[i-min(u) + 1,i]$ 的 $len[j]$ 和 $min(u)$ 取 $min$ 满足 $j\\in[1,i-min(i)]$ 的 $len[j]$ 和 $i-j+1$ 取 $min$ 考虑两种情况分别用线段树维护，那么第一种状态的更新相当于区间每个数对 $min(u)$ 取 $min$，第二种更新 $i-j+1$ 中的 $j$ 可以提出来，同样的做法维护最小的 $i+1$ 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137struct sgt{ int mn[MAXN*4],v[MAXN*4]; void doMin(int cnt,int &amp;val) { mn[cnt]=min(mn[cnt],val); v [cnt]=min(v [cnt],val); } void pushdown(int cnt) { if(mn[cnt]!=inf) { doMin(ls,mn[cnt]); doMin(rs,mn[cnt]); mn[cnt]=inf; } } void build(int l,int r,int cnt) { mn[cnt]=inf,v[cnt]=inf; if(l==r) return; build(l,mid,ls); build(mid+1,r,rs); } void update(int l,int r,int nl,int nr,int v,int cnt) { if(l==nl&amp;&amp;r==nr){doMin(cnt,v);return;} pushdown(cnt); if(nr&lt;=mid) update(l,mid,nl,nr,v,ls); else if(nl&gt;mid) update(mid+1,r,nl,nr,v,rs); else update(l,mid,nl,mid,v,ls),update(mid+1,r,mid+1,nr,v,rs); } void get_val(int a[],int l,int r,int cnt) { if(l==r){a[l]=v[cnt];return;} pushdown(cnt); get_val(a,l,mid,ls); get_val(a,mid+1,r,rs); }}T1,T2;const int K = 26;namespace SAM{ int cnt=0,root,last; int len[MAXN*2],par[MAXN*2],s[MAXN*2]; int nx[MAXN*2][K],pre[MAXN]; void newnode(int &amp;x){x=++cnt;} void init(){cnt=0,newnode(root),last=root;} void extend_sam(int c,int index) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; for(int i=0;i&lt;K;i++) nx[n][i]=nx[q][i]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur,pre[index]=cur,s[cur]=1; } int seq[MAXN*2],buc[N]; void sort_by_len() { fp(i,1,cnt) buc[len[i]]++; fp(i,1,N-1) buc[i]+=buc[i-1]; fp(i,1,cnt) seq[buc[len[i]]--]=i; } void build_sam(char s[]) { int n=strlen(s+1); fp(i,1,n) extend_sam(s[i]-'a',i); } void solve(int n) { sort_by_len(); fd(i,cnt,1) { int cur=seq[i]; s[par[cur]]+=s[cur]; } fp(i,1,n) { int cur=pre[i]; if(s[cur]==1) { int l=len[par[cur]]+1,r=len[cur]; T1.update(1,n,i-r+1,i-l+1,i,1); if(i-l+2&lt;=i) T2.update(1,n,i-l+2,i,l,1); } } }}int n;char s[MAXN];int v1[MAXN],v2[MAXN];int work(){ scanf(&quot;%s&quot;,s+1); n=strlen(s+1); T1.build(1,n,1); T2.build(1,n,1); SAM::init(); SAM::build_sam(s); SAM::solve(n); T1.get_val(v1,1,n,1); T2.get_val(v2,1,n,1); fp(i,1,n) printf(&quot;%d\\n&quot;,min(v2[i],v1[i]-i+1)); return 0;} Luogu P3346 [ZJOI2015]诸神眷顾的幻想乡由于叶子最多只有 $20$ 个，我们可以把每个叶子当作根跑出一颗 $Trie$ 出来，那么 20 个 $Trie$ 合并起来就包含了所有原树上任意两个路径所构成的字符串 然后建立广义 $SAM$，最后在求一波本质不同子串即可 代码见上面 BZOJ 3277 串贴个别人的题解，，， 一个用SAM维护多个串的根号特技 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899int n,k;string s[MAXN]; const int K = 26; namespace SAM{ int cnt=0,root,last; int len[MAXN*2],par[MAXN*2],sum[MAXN*2]; map&lt;char,int&gt; nx[MAXN*2]; int vis[MAXN*2]; LL f[MAXN*2]; void newnode(int &amp;x){x=++cnt;} void init(){cnt=0,newnode(root),last=root;} void extend_sam(char c,int index) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; nx[n]=nx[q]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur; } int seq[MAXN*2],buc[N]; void sort_by_len() { fp(i,1,cnt) buc[len[i]]++; fp(i,1,N-1) buc[i]+=buc[i-1]; fd(i,cnt,1) seq[buc[len[i]]--]=i; } void build_sam(string &amp;s) { int n=s.size(); fp(i,0,n-1) extend_sam(s[i],i); last=root; } void mark(int cur,int id) { while(cur!=root&amp;&amp;vis[cur]!=id) sum[cur]++,vis[cur]=id,cur=par[cur]; } void solve() { sort_by_len(); fp(i,1,cnt) if(sum[i]&gt;=k) f[i]+=len[i]-len[par[i]]; fp(i,1,cnt) { int cur=seq[i]; f[cur]+=f[par[cur]]; } } void run(string &amp;s,int id,bool flag=0) { int cur=root,n=s.size(); LL ans=0; fp(i,0,n-1) { cur=nx[cur][s[i]]; if(!flag) mark(cur,id); else ans+=f[cur]; } if(flag) cout &lt;&lt; ans &lt;&lt; &quot; &quot;; }} int work(){ cin &gt;&gt; n &gt;&gt; k; SAM::init(); fp(i,1,n) cin &gt;&gt; s[i],SAM::build_sam(s[i]); fp(i,1,n) SAM::run(s[i],i,0); SAM::solve(); fp(i,1,n) SAM::run(s[i],i,1); return 0;} CF235C Cyclical Quest题意：当两个字符串可以通过循环移位变成完全一样时我们称这两个字符串“相等”。 给定文本串，多个模式串，询问文本串中与模式串“相等”的子串有多少 SOL：先对文本串建立 $SAM$，考虑计算模式串的所有循环移位在文本串中的出现次数 把模式串拿到 $SAM$ 上运行并记录在每个状态的匹配长度 L，每次去掉首字母并把他加到字符串末尾，若 $L-1&lt;min(u)$ 或没有转移边就暴力跳 $par$即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116namespace SAM{ const int K = 26; int cnt=0,root,last; int len[MAXN*2],par[MAXN*2]; LL sum[MAXN*2]; bool calc[MAXN*2]; map&lt;int,int&gt; nx[MAXN*2]; struct edge{int u,v,next;}; vector&lt;edge&gt; e={edge()}; int pre[MAXN*2]; void addedge(int u,int v){e.pb({u,v,pre[u]}),pre[u]=e.size()-1;} void dfs(int u){go(u) dfs(v),sum[u]+=sum[v];} void newnode(int &amp;x) { x=++cnt; len[cnt]=par[cnt]=0; nx[cnt].clear(); } void init(){cnt=0,newnode(root),last=root;} void extend_sam(int c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; nx [n]=nx [q]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur,sum[cur]=1; } void build_sam(char s[]) { int n=strlen(s+1); fp(i,1,n) extend_sam(s[i]-'a'); fp(i,2,cnt) addedge(par[i],i); dfs(root); //fp(i,2,cnt) cout &lt;&lt; dbgs2(i,sum[i]) &lt;&lt; endl; } stack&lt;int&gt; stk; void match(char s[],LL ans=0) { while(!stk.empty()) calc[stk.top()]=0,stk.pop(); int n=strlen(s+1); int cur=root,l=0; fp(i,1,n) { int c=s[i]-'a'; while(cur!=root&amp;&amp;!nx[cur][c]) cur=par[cur],l=len[cur]; if(nx[cur][c]) cur=nx[cur][c],l++; } fp(i,1,n) { //cout &lt;&lt; dbgs2(i,cur) &lt;&lt; endl; if(l==n) l--; if(cur!=root&amp;&amp;len[par[cur]]&gt;=l) cur=par[cur]; int c=s[i]-'a'; while(cur!=root&amp;&amp;!nx[cur][c]) cur=par[cur],l=len[cur]; if(nx[cur][c]) cur=nx[cur][c],l++; if(l==n&amp;&amp;!calc[cur]) ans+=sum[cur],calc[cur]=1,stk.push(cur); //cout &lt;&lt; dbgs3(i,l,ans) &lt;&lt; endl; } printf(&quot;%I64d\\n&quot;,ans); } } int n,m;char s[N]; int work(){ scanf(&quot;%s&quot;,s+1); n=strlen(s+1); SAM::init(); SAM::build_sam(s); scanf(&quot;%d&quot;,&amp;m); while(m--) { scanf(&quot;%s&quot;,s+1); n=strlen(s+1); SAM::match(s); } return 0;} 我整个人都自动机辣","link":"/2019/09/10/SAM-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%B0%8F%E7%BB%93/"},{"title":"HDU6701 2019多校十1011 启发式分治","text":"LinkMake Rounddog Happy 题意给你 $k$ 和一个长度为 $n$ 的数组和，求满足 max\\{a_{l},a_{l+1}...a_{r}\\}-(r-l+1)>=k且 $a_{l}…a_{r}$ 两两不同的 $(l,r)$ 的对数。 题解打的时候乱写了个尺取+线段树，到最后也没调出，，， 用尺取预处理出在保证区间数不重复的情况下每个位置作为左/右边界时能扩展的最大距离。 考虑分治，$solve(l,r)$ 表示计算 $l$ 到 $r$ 中跨越 $mid$ 的合法区间对数，但式子中的 $max$ 那一项不能固定，因此考虑选择满足 $a_{mid} = max\\{a_{l}…a_{r}\\}$ 的 $mid$ 作为分治的中点，这样可以把式子中 $max\\{a_{l},a_{l+1}…a_{r}\\}$ 固定为 $a_{mid}$，对区间长度的限制也可以变为 $(r-l+1)&gt;=a_{mid}-k$ 。 还有一个问题，计算答案时我们有两种选择，一个是枚举左端点 $l,l+1,…mid$ 统计右端点的可行位置，另一种是枚举右端点统计左端点的可行位置，但我们的 $mid$ 不是 $(l+r)/2$，所以我们每次选择长度小的一边计算答案以保证复杂度里的 $logn$ 不会退化成 $n$（启发在这里）。 区间最大值的位置用 $ST$ 表就好 ，多个 $log$ 估计冲不过，，， 细节还蛮多的，大概要细心点调123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384namespace st{ int f[MAXN][20]; int pos[MAXN][20]; void init(int a[],int n) { fp(i,1,n)f[i][0]=a[i]; fp(i,1,n)pos[i][0]=i; for(int j=1;(1&lt;&lt;j)&lt;=n;j++) { for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) { f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); if(f[i][j-1]&gt;=f[i+(1&lt;&lt;(j-1))][j-1]) pos[i][j]=pos[i][j-1]; else pos[i][j]=pos[i+(1&lt;&lt;(j-1))][j-1]; } } } int query(int l,int r) { int k=log2(r-l+1),ans=max(f[l][k],f[r-(1&lt;&lt;k)+1][k]); return f[l][k]&gt;=f[r-(1&lt;&lt;k)+1][k]?pos[l][k]:pos[r-(1&lt;&lt;k)+1][k]; }}int n,k;int L[MAXN],R[MAXN];int a[MAXN];LL solve(int l,int r){ if(l&gt;r ) return 0; if(l==r) return a[l]-1&lt;=k; int mid=st::query(l,r),len=max(1,a[mid]-k); LL ans=0; if(mid-l&lt;r-mid) { fp(i,l,mid) if(max(i+len-1,mid)&lt;=min(r,R[i])) ans+=min(r,R[i])-max(i+len-1,mid)+1; } else { fp(i,mid,r) if(min(i-len+1,mid)&gt;=max(l,L[i])) ans+=min(i-len+1,mid)-max(l,L[i])+1; } //cout &lt;&lt; dbgs3(l,r,mid) &lt;&lt; endl; //cout &lt;&lt; dbgs2(len,ans) &lt;&lt; endl; return ans+solve(l,mid-1)+solve(mid+1,r);}map&lt;int,bool&gt; m;void init(){ m.clear(); for(int r=1,l=1;r&lt;=n;r++) { while(l&lt;r&amp;&amp;m[a[r]]==1) m[a[l]]=0,l++; m[a[r]]=1,L[r]=l; //cout &lt;&lt; dbgs2(r,L[r]) &lt;&lt; endl; } m.clear(); for(int l=n,r=n;l&gt;=1;l--) { while(l&lt;r&amp;&amp;m[a[l]]==1) m[a[r]]=0,r--; m[a[l]]=1,R[l]=r; //cout &lt;&lt; dbgs2(l,R[l]) &lt;&lt; endl; }}int work(){ int T=read(); while(T--) { n=read(),k=read(); fp(i,1,n)a[i]=read(); init(),st::init(a,n); write(solve(1,n)),putchar('\\n'); } return 0;}","link":"/2019/08/26/HDU6701-2019%E5%A4%9A%E6%A0%A1%E5%8D%811011-%E5%90%AF%E5%8F%91%E5%BC%8F%E5%88%86%E6%B2%BB/"},{"title":"CF1207F 根号分治","text":"LinkCF1207F. Remainder Problem 题意给你一个包含 $n$ 个数的数组，一开始每一位上都是 $0$。$q$ 次操作，第一个操作是单点修改，第二个操作是对于所有满足 $i$ % $y=x$ 的 $a_{i}$ 求和。 $n=500000$ $q&lt;=500000$ 题解打CF时看清神秒了这题我还以为是数据结构，，，结果想了半天也想不出咋维护，，， 一种暴力的做法是对于每一个对 $y$ 和 $x$ 都开一个数组记录一下，但单点更新 $O(n)$，查询时 $O(1)$。 另一个种暴力做法就是直接求 $a_{x}+a_{x+y}+a_{x+2y}+a_{x+3y}…$ 最差情况下也是 $O(n)$ 的，更新时 $O(1)$。 当 $n$ 很小的时候第一种暴力很有效，当 $n$ 很大时第二种暴力也很会快，因此我们考虑定一个上界 $m$，对于小于 $m$ 的 $x$ 我们选择第一种暴力方式，大于 $m$ 我们用第二种暴力。 这样单次询问或查询的复杂度是$O(m+n/(n-m))$的，显然 $m$ 取 $sqrt{n}$ 时复杂度最优。 这东西就是根号分治 真是太暴力了 Code123456789101112131415161718192021222324const int sqrtn=sqrt(MAXN); int n=5e5,q;LL s[sqrtn+5][sqrtn+5];LL a[MAXN]; int work(){ q=read(); while(q--) { int t=read(),x=read(),y=read(); if(t==1){a[x]+=y;fp(i,1,sqrtn)s[i][x%i]+=y;} else { LL ans=0; if(x&gt;sqrtn){for(int i=y;i&lt;=n;i+=x)ans+=a[i];} else ans=s[x][y]; write(ans),putchar('\\n'); } } return 0;}","link":"/2019/08/24/CF1207F-%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"},{"title":"19.8.24简单字符串讲课","text":"PPT字符串 bakapiano 神秘代码 frhd 几道板子题字符串 神秘代码 heuacm","link":"/2019/08/24/19-8-24%E7%AE%80%E5%8D%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%B2%E8%AF%BE/"}],"tags":[{"name":"网络流 费用流 最大流","slug":"网络流-费用流-最大流","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E8%B4%B9%E7%94%A8%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"数据结构 线段树","slug":"数据结构-线段树","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"categories":[]}