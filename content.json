{"pages":[{"title":"tags","text":"","link":"/tags/index-1.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"Guide &amp;&amp; About","text":"GuideOJ-Counter è½»é‡çº§ OJ è¿‡é¢˜æ•°ç»Ÿè®¡ç«™ç‚¹ Blog ä¸ªäººåšå®¢ HEUé€‰è¯¾è„šæœ¬ æš‚ä¸å¼€æºï¼Œæœ‰éœ€è¦ç§èŠ Aboutå’¸é±¼ï¼Œå…¨ç½‘åŸºæœ¬éƒ½ä¸€ä¸ªidã€‚ã€‚ã€‚ Emailï¼šbakapiano@outlook.com QQï¼š2514965141 Githubï¼šhttps://github.com/bakapiano Codeforces: https://codeforces.com/profile/Bakapiano","link":"/about/index.html"}],"posts":[{"title":"é¢è¯•ç®—æ³•é¢˜*2","text":"é¢˜ç›®æè¿°èƒŒæ™¯ $k$ èšç±»ï¼Œå¯èƒ½å’Œå®é™…é¢˜ç›®æœ‰å‡ºå…¥ã€‚ã€‚ã€‚ T1äºŒç»´å¹³é¢ä¸Šæœ‰ä¸€ä¸ªä¸­å¿ƒç‚¹ p_{0} ï¼Œä½ å¯ä»¥åœ¨ä¸Šé¢æ·»åŠ ä¸€äº›ç‚¹ï¼Œä½†å¯¹äºä»»æ„æ·»åŠ çš„ä¸¤ç‚¹ $p_{i}ï¼Œp_{j}$ï¼Œéœ€æ»¡è¶³ $dis(p_{i},p_{0}) &lt;=dis(p_{i},p_{j})$ ä¸” $dis(p_{j},p_{0}) &lt; dis(p_{i},p_{j})$ T2äºŒç»´å¹³é¢ä¸Šæœ‰ $n+m$ ä¸ªä¸¤ä¸¤ä¸åŒçš„ç‚¹ï¼Œå…¶ä¸­ $n$ ä¸ªç‚¹æˆ‘ä»¬ç§°å…¶ä¸ºå¾…åˆ†ç±»ç‚¹ï¼Œå…¶ä½™çš„ $m$ ä¸ªç‚¹ç§°ä¸ºä¸­å¿ƒç‚¹ï¼ˆåˆ†ç±»çš„ä¸­å¿ƒç‚¹ï¼‰ï¼Œå°†ä¸€ä¸ªå¾…åˆ†ç±»ç‚¹åˆ†ç»™ä¸­å¿ƒç‚¹çš„ä»£ä»·ä¸ºä¸¤ç‚¹çš„è·ç¦»ã€‚ ç°åœ¨ç»™å®šè¿™ $n+m$ ä¸ªç‚¹ï¼Œå¹¶ä¸”ç¬¬ $i$ ä¸ªåˆ†ç±»åªèƒ½å®¹çº³ $[l_{i},r_{i}]$ ä¸ªç‚¹ï¼Œè¯·ä½ è®¾è®¡ä¸€ç§ç®—æ³•æ±‚å‡ºæœ€å°æ€»ä»£ä»·æœ€å°ã€‚ My solution for T1çŒœäº†ä¸€ä¸ªç­‰åˆ†åœ†ï¼Œåˆ—ä¸ªæŸ¿å­ï¼š$2PIr/n&gt;r$ è§£å‡º $n$ æœ€å¤š $6$ã€‚ My solution for T2ç­”äº†ä¸ªä¸Šä¸‹ç•Œè´¹ç”¨æµï¼Œå»ºå›¾ç±»ä¼¼äºŒåˆ†å›¾å¸¦æƒåŒ¹é…ã€‚","link":"/2021/03/16/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98-2/"},{"title":"Ubuntu ä¸‹æ­å»º mirai + mirai-api-http","text":"miraiæä¾› QQ Android åè®®æ”¯æŒçš„é«˜æ•ˆç‡æœºå™¨äººåº“ mirai ä½¿ç”¨ iTXTech MCL Installer è·å– mcliTXTech MCL Installer æ–°å»ºç›®å½• 12mkdir mclcd mcl æ ¹æ®ç³»ç»Ÿå’Œæ¶æ„é€‰æ‹©å¯¹åº”æ–‡ä»¶ï¼šrelease 123curl -LJO https://github.com/iTXTech/mcl-installer/releases/download/2827601/mcl-installer-2827601-linux-amd64chmod +x mcl-installer-2827601-linux-amd64./mcl-installer-2827601-linux-amd64 æ— ç‰¹æ®Šéœ€æ±‚å¯ä¸€è·¯å›è½¦ï¼Œmclå°±è£…å¥½å•¦ ä½¿ç”¨ mcl å®‰è£… mirai-api-http1./mcl --update-package net.mamoe:mirai-api-http --channel stable --type plugin æµ‹è¯• http apiï¼š 12./mcllogin qqå· qqå¯†ç  å¦‚æœè¦æ±‚æ»‘å—éªŒè¯è¯·çœ‹ä¸‹ä¸€æ­¥ æ‰‹åŠ¨å®Œæˆæ»‘åŠ¨éªŒè¯å‚è€ƒè‡ª mirai-login-solver-selenium é€€å‡ºæ§åˆ¶å°ï¼Œåœ¨ mirai è¿è¡Œæ—¶ä¸­æ·»åŠ  JVM å±æ€§ mirai.slider.captcha.supported ä»¥å¯ç”¨æ‰‹åŠ¨éªŒè¯ ä¿®æ”¹æ–‡ä»¶ mcl vim mcl ä¸ºå¦‚ä¸‹å†…å®¹ï¼š 123#!/usr/bin/env shexport JAVA_BINARY=&quot;/root/mcl/java/bin/java&quot;$JAVA_BINARY -Dmirai.slider.captcha.supported -jar mcl.jar $* å†æ¬¡æ‰“å¼€ mcl å¹¶ç™»å½•ï¼Œç”¨æœ‰æ¡Œé¢ç³»ç»Ÿçš„ç”µè„‘æ‰“å¼€éªŒè¯åœ°å€ F12 æ‰“å¼€ DevToolsï¼Œåˆ‡æ¢è¿è¡Œæ¨¡å¼ä¸º Android åˆ‡æ¢åˆ° Consoleï¼Œå¤åˆ¶ captcha.inject.js çš„å†…å®¹å…¨éƒ¨å¤åˆ¶è‡³ Console ä¸­å¹¶è¿è¡Œ å¤åˆ¶ä¼ å›çš„ ticket å¹¶åœ¨ mcl ä¸­è¾“å…¥ï¼Œæµç¨‹æ­£ç¡®çš„è¯å°±èƒ½å®Œæˆç™»é™†äº† éªŒè¯ apiä½¿ç”¨äº† python sdk Graia Application å®‰è£…ï¼š 1pip install graia-application-mirai è¿è¡Œ Python ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233from graia.broadcast import Broadcastfrom graia.application import GraiaMiraiApplication, Sessionfrom graia.application.message.chain import MessageChainimport asynciofrom graia.application.message.elements.internal import Plainfrom graia.application.friend import Friendloop = asyncio.get_event_loop()bcc = Broadcast(loop=loop)app = GraiaMiraiApplication( broadcast=bcc, connect_info=Session( host=&quot;http://localhost:8080&quot;, # å¡«å…¥ httpapi æœåŠ¡è¿è¡Œçš„åœ°å€ authKey=&quot;0123456789&quot;, # å¡«å…¥åœ¨setting.ymlä¸­è®¾ç½®çš„authKey account=88888888, # ä½ çš„æœºå™¨äººçš„ qq å· websocket=True # Graia å·²ç»å¯ä»¥æ ¹æ®æ‰€é…ç½®çš„æ¶ˆæ¯æ¥æ”¶çš„æ–¹å¼æ¥ä¿è¯æ¶ˆæ¯æ¥æ”¶éƒ¨åˆ†çš„æ­£å¸¸è¿ä½œ. ))@bcc.receiver(&quot;FriendMessage&quot;)async def friend_message_listener(message: MessageChain, friend: Friend, app: GraiaMiraiApplication): msg = message.asDisplay() if msg.startswith(&quot;.help&quot;): await app.sendFriendMessage(friend, MessageChain(__root__=[Plain(&quot;.help\\tæ˜¾ç¤ºå¸®åŠ©æŒ‡ä»¤\\r\\n.copy\\tå¤è¯»&quot;)])) elif msg.startswith(&quot;.copy &quot;): msg = msg[6:] await app.sendFriendMessage(friend, MessageChain(__root__=[Plain(msg)])) else: await app.sendFriendMessage(friend, MessageChain(__root__=[Plain(&quot;æ”¶åˆ°!&quot;)]))app.launch_blocking() æœ€åå°è¯•ç»™æœºå™¨äººå‘æ¶ˆæ¯ï¼Œæ”¶åˆ°å›å¤å°±æµ‹è¯•æˆåŠŸäº†","link":"/2021/03/15/Ubuntu-%E4%B8%8B%E6%90%AD%E5%BB%BA-mirai-mirai-api-http/"},{"title":"2020æ­ç”µå¤šæ ¡","text":"æ‰“æ˜Ÿä¸º upsolve Round 1rank 524 (1/12) æ£’å­ï¼Œæˆ‘xä½ ä»™äºº.jpg 1004ç­¾åˆ° n&gt;=3 éƒ½æ˜¯ abcabacabcâ€¦ *1005ä¸ºä»€ä¹ˆä½ ä»¬éƒ½ä¼šäºŒæ¬¡å‰©ä½™å•Š è€ƒè™‘ fib é€šé¡¹ï¼Œå°†æ ¹å·äº”ç”¨äºŒæ¬¡å‰©ä½™åŒ–æˆå¸¸æ•° äºŒé¡¹å¼å®šç†å±•å¼€ï¼Œæ¯ä¸€é¡¹ç­‰æ¯”æ±‚å’Œ å¡å¡å¸¸ï¼Œå¹‚æ¬¡å¯¹ MOD-1 å–æ¨¡ *1006åˆ†å— å¥½é¢˜ è€ƒè™‘å°†åº¦æ•°å¤§äº $\\sqrt{n}$ çš„ç‚¹è®°ä½œç‰¹æ®Šç‚¹ï¼Œæ˜“çŸ¥ç‰¹æ®Šç‚¹æœ€å¤š $\\sqrt{n}$ ä¸ª ç”±äºå…¶ä»–ç‚¹åº¦æ•°ä¸è¶…è¿‡ $\\sqrt(n)$ è¯¢é—®ç›´æ¥æš´åŠ› åŒæ—¶ç»´æŠ¤ç‰¹æ®Šç‚¹çš„ç›¸é‚»ç‚¹çš„æƒå€¼ä¿¡æ¯ï¼Œè¿™é‡Œæˆ‘ç”¨äº†åˆ†å—æ¥ä¿è¯æ•´ä½“å¤æ‚åº¦åœ¨ $n\\sqrt{n}$ çº§åˆ« ä¿®æ”¹ä¸€ä¸ªç‚¹æƒå€¼çš„æ—¶å€™åªéœ€è¦æ›´æ–°å…¶ç›¸é‚»ç‰¹æ®Šç‚¹çš„ä¿¡æ¯å³å¯ï¼Œç”±äºç‰¹æ®Šç‚¹ä¸è¶…è¿‡ $\\sqrt{n}$ ä¸ªï¼Œæš´åŠ›æ›´æ–°çš„å¤æ‚åº¦ä¹Ÿèƒ½ä¿è¯ *1009é¦–å…ˆæŒ‰ p sortä¸€ä¸‹ï¼Œç”¨å•è°ƒæ ˆç­›å‡º a å•è°ƒé€’å‡çš„æ‰€æœ‰æœºå™¨äºº ä¹‹åæŒ‰ç…§ p é€’å¢çš„é¡ºåºè€ƒè™‘ï¼Œç»´æŠ¤ä¸€ä¸ªå¯è¡Œçš„ï¼ˆæœ‰æœºä¼šæˆä¸ºé¢†å…ˆçš„ï¼‰æœºå™¨äººçš„é›†åˆï¼Œå¯ä»¥å‘ç°è¿™æ˜¯ä¸€ä¸ªä¸‹å‡¸åŒ… æ–°åŠ å…¥ä¸€æ¡çº¿çš„æ—¶å€™ï¼Œå¦‚æœå’Œæœ€åä¸€æ¡ç›´çº¿çš„äº¤ç‚¹çš„æ¨ªåæ ‡ï¼ˆæ—¶é—´ï¼‰ &gt; æœ€åä¸¤ä¸ªç›´çº¿çš„äº¤ç‚¹çš„æ¨ªåæ ‡ï¼Œå°±è¸¢æ‰æœ€åæœ€åä¸€ä¸ªç›´çº¿ ç±»ä¼¼äºç»´æŠ¤å‡¸åŒ…ï¼Œæœ€åæ ˆçš„å¤§å°å°±æ˜¯ç­”æ¡ˆ å°å¿ƒç»´æŠ¤ p a éƒ½ç›¸ç­‰çš„ç‚¹ï¼Œå³å¸¦å…¥æ„å»ºå‡¸åŒ…ï¼Œä½†ä¸ç®—ç­”æ¡ˆ *1011å­—ç¬¦ä¸²ï¼Œæˆ‘çš„åç¼€è‡ªåŠ¨æœºå¡ä¸è¿‡å» Round 2rank 50 (6/12) 1001æŒ‰æƒå€¼ sort ä¸€ä¸‹ï¼Œä»åå¾€å‰å¹¶æŸ¥é›† 1005è´¹ç”¨æµï¼Œä¿ç•™æ¯ä¸ªå·¥äººæå€¼ç‚¹å·¦å³ 50 ä¸ªç‚¹çš„æœºå™¨ï¼Œä¹‹åè´¹ç”¨æµ æ¯æ¬¡æ–°åŠ è¾¹å¢å¹¿å°±è¡Œï¼Œä¸ç”¨é‡æ–°å»ºå›¾ 1006å–ä¸ªæ¨¡æ•°ç®—ä¸€ä¸‹ï¼ŒO(n) éªŒè¯ 1007äºŒåˆ†ç­”æ¡ˆ + dp äºŒåˆ†ç›´å¾„é•¿åº¦ limitï¼Œè€ƒè™‘ dp $f[u][k]$ è¡¨ç¤º $u$ è¿™é¢—å­æ ‘é€‰ $k$ ä¸ªè¾¹åè½¬æ—¶ å¶å­åˆ° $u$ çš„æœ€é•¿è·¯å¾„çš„é•¿åº¦ åˆå¹¶æ—¶è‹¥ä¸¤æ¡è·¯å¾„ &gt; limit åˆ™ä¸èƒ½è½¬ç§»ï¼Œæœ€åçœ‹ $f[1][k]$ æ˜¯å¦æœ‰å€¼ $O(kn\\log{n})$ *1009æš´åŠ› æ³¨æ„åˆ°å¯¹äºæ¯è¡Œä¸€å®šç»è¿‡å¶æ•°æ¬¡ï¼Œè®°å½•æ¯æ¬¡ç»è¿‡çš„ y åæ ‡ï¼Œsort å $[y_{i}+1,y_{i+1}] (i = 0,2,4â€¦.)$ å°±æ˜¯è¿™è¡Œç»è¿‡çš„æ ¼å­ ç„¶åæš´åŠ› 1010æš´æœ 1012dp è§‚å¯Ÿç­”æ¡ˆä¸º $(r-l+1) + m - 2*lcs$ è€ƒè™‘ $f[i][j][k]$ è¡¨ç¤º $S[1-i]$ åŒ¹é…é•¿åº¦ä¸º $j$ çš„å­åºåˆ—ï¼Œå­åºåˆ—åœ¨ $T$ ä¸²çš„ç»“å°¾ä¸º $k$ æ—¶å­åºåˆ—èµ·ç‚¹åœ¨ $S[1-i]$ ä¸­æœ€é å³çš„ä½ç½® ç”¨å‰ç¼€å’Œåšä¸€ä¸ª $O(n*m^2)$ çš„ dp å³å¯","link":"/2020/07/24/2020%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"},{"title":"å¹³é¢å›¾è½¬å¯¹å¶å›¾æ±‚ç½‘ç»œæµ","text":"ç‰›å®¢å¤šæ ¡å‡ºäº†ä¸ªé¢˜ï¼Œè¡¥ä¸‹çŸ¥è¯†ç‚¹ å‚è€ƒèµ„æ–™ç½‘ç»œæµï¼ˆå¹³é¢å›¾è½¬å¯¹å¶å›¾ï¼‰ ysner ç®€ä»‹ç‹¼æŠ“å…”å­ å°†å·¦ä¸Šè§’çœ‹ä½œæºç‚¹ï¼Œå³ä¸‹ä¸ºæ±‡ï¼Œè¿åŒå‘è¾¹ä¹‹åå°±æ˜¯ä¸€ä¸ªæœ€å°å‰²é—®é¢˜äº†ï¼Œä½†ç½‘ç»œæµçš„å¤æ‚åº¦æ— æ³•èƒœä»»æœ¬é¢˜ã€‚ æ³¨æ„åˆ°æœ€ç»ˆå»ºå‡ºæ¥çš„å›¾æ˜¯ä¸€ä¸ªå¹³é¢å›¾ï¼Œç”»ä¸€æ¡ä»å·¦ä¸Šåˆ°å³ä¸‹å¯¹è§’çº¿å°†æœ€å¤–çš„æ— é™å¹³é¢å‰²æˆä¸¤ä¸ªï¼Œæ±‚ä¸€ä¸‹å¯¹å¶å›¾ï¼ˆå³å¹³é¢çœ‹ä½œæ˜¯ç‚¹ï¼ŒåŸå›¾ä¸­çš„è¾¹çœ‹ä½œæ˜¯è¿æ¥æ–°å›¾ä¸­ä¸¤ä¸ªå¹³é¢çš„è¾¹ï¼‰ ä¾‹å¦‚ä¸‹å›¾ è½¬æˆå¯¹å¶å›¾å°±æ˜¯ï¼š è§‚å¯ŸåŸå›¾çš„ä»»æ„ä¸€ä¸ªå‰²éƒ½å¯ä»¥è¡¨ç¤ºä¸ºæ–°å›¾ä¸Šä» $Sâ€™$ å‡ºå‘åˆ° $Tâ€™$ çš„ä¸€æ¡è·¯å¾„ï¼Œæ‰€ä»¥æ€§æ„Ÿç†è§£ä¸€ä¸‹ï¼ŒåŸå›¾çš„æœ€å¤§æµå’Œæœ€å°å‰²å°±ç­‰äºæ–°å›¾çš„æœ€çŸ­è·¯ã€‚ã€‚ã€‚ æœ‰å‘å›¾çš„è¯ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæ‰€æœ‰è¾¹æŒ‰é¡º(é€†)æ—¶é’ˆè½¬ 90Â° å°±å¾—åˆ°äº†æ–°å›¾ä¸Šçš„è¾¹ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849EDGE(N,N);int S,T,cnt=0,n,m;int id[MAXN][MAXN][2];LL dis[N];LL solve(){ priority_queue&lt;lpr,vector&lt;lpr&gt;,greater&lt;lpr&gt;&gt; q; fp(i,1,cnt)dis[i]=linf; dis[S]=0,q.push({0,S}); while(!q.empty()) { int u=q.top().se; LL d=q.top().fi; q.pop(); if(d!=dis[u])continue; if(u==T)break; gow(u)if(dis[u]+w&lt;dis[v]) dis[v]=dis[u]+w,q.push({dis[v],v}); } return dis[T];}void con(int u,int v,int w){ addedge(u,v,w),addedge(v,u,w); // cout &lt;&lt; dbgs3(u,v,w) &lt;&lt; endl;}int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); fp(i,1,n-1)fp(j,1,m-1)id[i][j][0]=++cnt,id[i][j][1]=++cnt; S=++cnt,T=++cnt; fp(i,1,n)fp(j,1,m-1) { int w;scanf(&quot;%d&quot;,&amp;w); if(i==1)con(S,id[i][j][0],w); else if(i==n) con(id[i-1][j][1],T,w); else con(id[i-1][j][1],id[i][j][0],w); } fp(i,1,n-1)fp(j,1,m) { int w;scanf(&quot;%d&quot;,&amp;w); if(j==1)con(id[i][j][1],T,w); else if(j==m)con(S,id[i][j-1][0],w); else con(id[i][j][1],id[i][j-1][0],w); } fp(i,1,n-1)fp(j,1,m-1) { int w;scanf(&quot;%d&quot;,&amp;w); con(id[i][j][0],id[i][j][1],w); } return printf(&quot;%lld\\n&quot;,solve());} ç»ƒä¹ [NOI2010]æµ·æ‹”å…ˆå¤§åŠ›æ¥ä¸€æ³¢ç»“è®ºï¼Œæ¯ä¸ªç‚¹çš„é«˜åº¦å°±æ˜¯ 0/1ï¼Œå¹¶ä¸”é«˜åº¦ä¸º 1 çš„ç‚¹éƒ½ä¸å³ä¸‹çš„ç‚¹è”é€šï¼Œä¸” 1-&gt;0 çš„è¾¹æ„æˆåŸå›¾çš„ä¸€ä¸ªå‰² ç„¶ååº”ç”¨ä¸Šè¿°æŠ€å·§ï¼Œæ±‚ä¸ªæœ€çŸ­è·¯å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960EDGE(N,N*4);int n,m,S,T,cnt;int c[MAXN][MAXN][2]; //0-left 1-downint id[MAXN][MAXN];LL dis[N];LL solve(){ priority_queue&lt;lpr,vector&lt;lpr&gt;,greater&lt;lpr&gt;&gt; q; fp(i,1,cnt)dis[i]=linf; dis[S]=0,q.push({0,S}); while(!q.empty()) { int u=q.top().se; LL d=q.top().fi; q.pop(); if(d!=dis[u])continue; if(u==T)break; gow(u)if(dis[u]+w&lt;dis[v]) dis[v]=dis[u]+w,q.push({dis[v],v}); } return dis[T]==linf?-1:dis[T];}void add(int u,int v,int w){ // cout &lt;&lt; dbgs3(u,v,w) &lt;&lt; endl; addedge(u,v,w);}int work(){ scanf(&quot;%d&quot;,&amp;n); fp(i,1,n)fp(j,1,n)id[i][j]=++cnt; S=++cnt,T=++cnt; fp(i,1,n+1)fp(j,1,n) { int w;scanf(&quot;%d&quot;,&amp;w); int u=(i==1)?T:id[i-1][j]; int v=(i==n+1)?S:id[i][j]; add(u,v,w); } fp(i,1,n)fp(j,1,n+1) { int w;scanf(&quot;%d&quot;,&amp;w); int u=(j==n+1)?T:id[i][j]; int v=(j==1)?S:id[i][j-1]; add(u,v,w); } fp(i,1,n+1)fp(j,1,n) { int w;scanf(&quot;%d&quot;,&amp;w); int u=(i==n+1)?S:id[i][j]; int v=(i==1)?T:id[i-1][j]; add(u,v,w); } fp(i,1,n)fp(j,1,n+1) { int w;scanf(&quot;%d&quot;,&amp;w); int u=(j==1)?S:id[i][j-1]; int v=(j==n+1)?T:id[i][j]; add(u,v,w); } swap(S,T); return printf(&quot;%lld\\n&quot;,solve());} ç‰›å®¢å¤šæ ¡2020 Day2 IntervalæŠŠæ‰€æœ‰ $[i,i]$ éƒ½çœ‹ä½œä¸€ä¸ªç‚¹ï¼Œé‚£ä¹ˆé—®é¢˜ç­‰ä»·äºæ±‚ $[1,1]$ åˆ°æ±‡ç‚¹çš„ä¸€ä¸ªæœ€å°å‰² 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758EDGE(N,N*4);int n,m,S,T,cnt;int c[MAXN][MAXN][2]; //0-left 1-downint id[MAXN][MAXN];LL dis[N];LL solve(){ priority_queue&lt;lpr,vector&lt;lpr&gt;,greater&lt;lpr&gt;&gt; q; fp(i,1,cnt)dis[i]=linf; dis[S]=0,q.push({0,S}); while(!q.empty()) { int u=q.top().se; LL d=q.top().fi; q.pop(); if(d!=dis[u])continue; if(u==T)break; gow(u)if(dis[u]+w&lt;dis[v]) dis[v]=dis[u]+w,q.push({dis[v],v}); } return dis[T]==linf?-1:dis[T];}void add(int u,int v,int w){ // cout &lt;&lt; dbgs3(u,v,w) &lt;&lt; endl; addedge(u,v,w),addedge(v,u,w);}int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); fp(i,1,n)fp(j,1,n)c[i][j][0]=c[i][j][1]=inf; fp(i,1,m) { int l,r,w; char dir; scanf(&quot;%d %d %c %d&quot;,&amp;l,&amp;r,&amp;dir,&amp;w); if(dir=='L')c[l][r][1]=min(c[l][r][1],w); else c[l][r][0]=min(c[l][r][0],w); } fp(i,1,n-1)fd(j,n,i+1)id[i][j]=++cnt; S=++cnt,T=++cnt; // fp(i,1,n-1)fd(j,n,i+1)cout &lt;&lt; dbgs3(i,j,id[i][j]) &lt;&lt; endl; cout &lt;&lt; dbgs2(S,T) &lt;&lt; endl; fp(i,1,n-1)fd(j,n,i+1) { //0-left if(c[i][j][0]!=inf) { int u=(i==1)?S:id[i-1][j]; int v=id[i][j]; add(u,v,c[i][j][0]); } if(c[i][j][1]!=inf) { int u=(j==n)?T:id[i][j+1]; int v=id[i][j]; add(u,v,c[i][j][1]); } } return printf(&quot;%lld\\n&quot;,solve());}","link":"/2020/07/14/%E5%B9%B3%E9%9D%A2%E5%9B%BE%E8%BD%AC%E5%AF%B9%E5%81%B6%E5%9B%BE%E6%B1%82%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"title":"2020ç‰›å®¢å¤šæ ¡","text":"æ‰“æ˜Ÿä¸º upsolve Round 1å¥½å¤šè®ºæ–‡é¢˜ã€‚ã€‚è‡ªé—­ rank 99 (3/10) *Aåç¼€æ•°ç»„ï¼Œå¡å¸¸ Fç­¾åˆ°ï¼Œæ‰©ä¸¤å€ä¸‹æ ‡å–æ¨¡æ¯”è¾ƒä¸‹ Hé¢„å¤„ç†è´¹ç”¨åˆ†æ®µå‡½æ•°ï¼Œè®¨è®º JOEIS ç‰›é€¼ Round 2å†ä¹Ÿä¸åšæ„é€ ç³»åˆ— rank 85 (5/11) *Aå¯¹äºæ¯ä¸ªå­—ç¬¦ä¸²æšä¸¾å‰ç¼€ $s[1]$ â€¦ $s[i]$ï¼Œè®¾æœ‰ $cnt[i]$ ä¸ªåç¼€å’Œä»–ç›¸åŒï¼Œä½†è¿™æ ·ä¼šé‡å¤è®¡ç®—ï¼Œå¦‚å­—ç¬¦ä¸² $aba$ å’Œåç¼€ $aba$ï¼ŒåŒä¸€å­—ç¬¦ä¸²çš„åç¼€è¢«è®¡äº†ä¸¤æ¬¡æ•° è€ƒè™‘å»é‡ï¼Œä»å‰å¾€å $cnt[next[i]]-=cnt[i]$ï¼Œç„¶åè®¡ç®—ç­”æ¡ˆå³å¯ã€‚ Bä¸‰ç‚¹å®šåœ†ï¼Œè€ƒè™‘æšä¸¾ $(0,0)$ å¤–çš„å¦å¤– $2$ ç‚¹ï¼Œç®—å‡ºåœ†å¿ƒå»é‡ç»Ÿè®¡ç­”æ¡ˆï¼Œæ³¨æ„ç²¾åº¦ã€‚ Cèµµå“¥ç‹‚æ—¥$20$å‘ é¢˜è§£åšæ³•ï¼šæ‰€æœ‰å¶å­æŒ‰ dfs åº sort, $l_{1} - l_{s/2+1}$, $l_{2} - l_{s/2+2}$ $â€¦$ $l_{s/2} - l_{n}$ Dç­¾åˆ° *Eå¾…è¡¥ FWT Fä¸¤ç»´åˆ†åˆ«å•è°ƒé˜Ÿåˆ—ï¼Œè¿™é‡Œæ±‚ $gcd$ å¯ä»¥è®°å¿†åŒ–å»æ‰ä¸€ä¸ª $log$ *Gä¾å‡ºé¢˜äººçš„è¯´æ³•ï¼Œè¿™ç§ $m$ æ˜¯ 4ä¸‡çš„æ•°æ®åº”è¯¥å¾€ $bitset$ ä¸Šé ã€‚ã€‚ã€‚ $n*m$ åœ¨ 1e9 å·¦å³çš„é¢˜éƒ½å¯ä»¥è€ƒè™‘ä¸€ä¸‹ $bitset$ï¼Œå¤æ‚åº¦ä¼šé™¤ä¸ª $64$ åšæ³•ç±»ä¼¼äº $shift-and$ï¼Œé¦–å…ˆå¯¹äºæ¯ä¸ª $a[i]$ å¤„ç†å‡ºä»–åœ¨ $b$ æ•°ç»„ä¸­èƒ½åŒ¹é…çš„ä½ç½® $s[i]$ï¼Œè¿™ä¸ªç”¨ä¸ª bitset å­˜ä¸‹ã€‚ æ³¨æ„åˆ°æœ¬è´¨ä¸åŒçš„ $s$ æœ€å¤š $m$ ç§ï¼Œå¯¹äºæ¯ä¸ª $b[j]$ æ±‚ä¸‹ $s$ å³å¯ å‰©ä¸‹çš„åšæ³•å’Œ $shift-and$ ä¸€è‡´äº†ï¼Œ$f[i][j]$ è¡¨ç¤ºç»“å°¾ä¸º $i$ çš„å­åŒºé—´æ˜¯å¦èƒ½åŒ¹é…ä¸Š $b[1$~$j]$ï¼Œè®°ä½œ $cur$ï¼Œè½¬ç§»ï¼šcur = (cur &lt;&lt; 1 &amp; s[i]) | 1 *Hèµ›ä¸­å·®ä¸€ç‚¹è°ƒå‡ºï¼Œçˆ†äº† int ã€‚ã€‚ã€‚ è€ƒè™‘ä¸‰ç§æƒ…å†µï¼š $a &lt; b &lt; x$ï¼Œa å’Œ b å– x çš„ä¸¤ä¸ªå‰é©±æœ€ä¼˜ $a &lt; x &lt; b$ï¼Œa å’Œ b åˆ†åˆ«å– x çš„å‰é©±å’Œåç»§æœ€ä¼˜ $x &lt; a &lt; b$ï¼Œé¦–å…ˆ a å’Œ b ä¸€å®šæ˜¯è¿ç»­çš„ï¼Œå…¶æ¬¡è€ƒè™‘èƒ½ç»„æˆä¸‰è§’å½¢æ—¶çš„æ¡ä»¶ï¼š$x+a&gt;b$ å³ $x&gt;b-a$ï¼Œå› æ­¤ç»´æŠ¤æœ‰åºåºåˆ—ï¼Œæƒå€¼ä¸ºç›¸é‚»ä¸¤é¡¹çš„å·®ï¼Œæ±‚ $&gt;x$ æƒå€¼çš„ $min$ å³å¯ 1 å’Œ 2 å¼€ä¸ª $set$ æä¸€æå°±è¡Œ 3: è¯·é€‰æ‹©ä½ å–œæ¬¢çš„æ•°æ®ç»“æ„.jpg *Iç½‘ç»œæµå¹³é¢å›¾è½¬å¯¹å¶å›¾ J *Kå¾…è¡¥ï¼Œå‡ ä½• ç»™é˜Ÿå‹äº†ã€‚ã€‚ã€‚ Round 3rank 62 (8/12) å¥½ï¼Œdreamoonç‰›é€¼ Aè´ªå¿ƒï¼Œæœ‰ğŸŸå°±æŠ“ï¼Œå€’åºç´¯è®¡å¯ä»¥ç”¨é±¼é¥µæŠ“é±¼çš„æ—¶é—´ç‚¹ B å¹³è¡¡æ ‘ æ¨¡æ‹Ÿ æ‰‹ç©è§‚å¯Ÿè§„å¾‹ï¼ŒæŠ¤åç§»é‡å°±è¡Œ Cå‡ ä½•ï¼Œzyyç‰›é€¼ Dæ„é€ ï¼Œzyyç‰›é€¼ å…ˆæ„é€ ä¸€ä¸ªæ­£æ–¹å½¢ï¼Œæ¯æ¬¡å‘å³ä¸ŠæŒªç‚¹ ans+=2,å˜æˆä¸€æ¡é“¾åæ‹†ä¸¤ç«¯çš„ç‚¹ï¼Œæ¯æ¬¡ ans+=2 Edpï¼Œzzqç‰›é€¼ å…ˆsortï¼Œè§‚å¯Ÿå‘ç°å¶æ•° &gt;=4 è”é€šå¿«å†…æœ€ä¼˜è§£ä¸º 2*(a[r]-a[l])ï¼Œä¹‹ådp Fæ•°è®ºï¼Œzzqç‰›é€¼ a b ä¸äº’è´¨ç›´æ¥æ„é€  åˆ†è§£ bï¼Œè‹¥ b ä¸º p^k åˆ™æ— è§£ å¦åˆ™åˆ†è§£ b ä¸º p^k * b/p^kï¼Œexgcdè§£ä¸¤ä¸ªè§£ Gæ•°æ®ç»“æ„ å¹¶æŸ¥é›†ç»´æŠ¤è”é€šæƒ…å†µï¼Œvector ç»´æŠ¤è¾¹é›†ï¼Œå¯å‘å¼åˆå¹¶ list å¯ä»¥åšåˆ° O(1) åˆå¹¶ Hæ•°æ®ç»“æ„ï¼Œæ¯æ¬¡æ‰¾ [l,r] ä¸­ p æœ€å°çš„ä½ç½®åˆ†æ²»ï¼Œç¬›å¡å°”æ ‘åšåˆ°çº¿æ€§ *Iå¾…è¡¥ *Jå¾…è¡¥ *Kå¾…è¡¥ Lç­¾åˆ° Round 4rank 84 (4/10) é¢˜ä¸é”™ï¼Œå°±æ˜¯äººå¤ªèœ *Aè€ƒè™‘ k å›ºå®šï¼ŒäºŒåˆ†ç­”æ¡ˆè®°ä½œ disï¼Œæ¯æ¬¡è´ªå¿ƒæ‰¾å¶å­çš„ dis çº§ç¥–å…ˆå¹¶å‰²æ‰è¿™é¢—å­æ ‘ ä¸€ä¸ªæ€§è´¨è‹¥ç­”æ¡ˆä¸º disï¼Œåˆ™å…³é”®ç‚¹æ•°è‡³å°‘ä¸º n/dis çº§åˆ«çš„ï¼ˆè€ƒè™‘ä¸€æ¡é“¾ï¼‰ é‚£ä¹ˆæ€»å…³é”®ç‚¹æ•°å°±æ˜¯ä¸€ä¸ªè°ƒå’Œçº§æ•°ï¼Œå¯¹äºæ¯ä¸ª dis ç”¨çº¿æ®µæ ‘æ¨¡æ‹Ÿå‰²å­æ ‘çš„è¿‡ç¨‹æ€»å¤æ‚åº¦ä¸¤ä¸ª log Bç®€å•æ•°è®º *Cç‰›é€¼ä¸²ä¸²é¢˜ é¢˜é¢å¥½éš¾è¯» æŠŠåç¼€å…¨ä¸¢åˆ° Trie ä¸Šæ€»ç‚¹æ•°ä¸º 10N çº§åˆ«çš„ ç„¶åé—®é¢˜å˜æˆäº†æ±‚ Trie ä¸Šä¸²æœ¬è´¨ä¸åŒå­—ä¸²ä¸ªæ•°ï¼Œå¹¿ä¹‰SAM *Då¾…è¡¥ *Eå¾…è¡¥ Fç­¾åˆ°ä¸ä¼šç³»åˆ— *Gå¾…è¡¥ï¼Œæ¬ç –é¢˜ï¼Ÿï¼Ÿ Hæ•°è®ºï¼ŒåŸé¢˜äº† é™¤äº† 1 å’Œ &gt; n/2 çš„è´¨æ•°å¤–éƒ½èƒ½åŒ¹ä¸Š ä¸€ç§æ„é€ ï¼š å€’åºè€ƒè™‘æ‰€æœ‰è´¨æ•° pï¼Œå¤„ç†ä»–çš„æ‰€æœ‰æœªåŒ¹é…çš„å€æ•°ï¼Œå‡è®¾æœ‰ num ä¸ª è‹¥ num ä¸ºå¶æ•°ï¼Œåˆ™ä¸¤ä¸¤åŒ¹é…ï¼Œè‹¥ä¸ºå¥‡æ•°ï¼Œåˆ™ç•™ä¸‹ 2*p æœ€åå°†æ‰€æœ‰ç•™ä¸‹çš„æ‰€æœ‰ 2*pi ä¸¤ä¸¤åŒ¹é… Ié­” å¹» è°ƒ å‚ æ¯æ¬¡æ‰¾ä¸€ä¸ªæœªå½’ç±»çš„ç‚¹ï¼Œå‡è®¾ä»–æ‰€æœ‰çš„è¯éƒ½æ˜¯çœŸçš„ï¼Œæ‰©ä¸€æ³¢ç‚¹ ç„¶åä»¥å¤šæ•°äººåŸåˆ™æ¥åˆ¤æ–­ç»„å†…æ˜¯å¦æœ‰é”™åŠ å…¥çš„ç‚¹ï¼ŒåŠå½“ &gt;cnt çš„äººè®¤ä¸ºä»–æ˜¯ä¸€ç»„æ—¶å°±è®¤ä¸ºæ˜¯çœŸçš„ ç„¶ååš bfs æ‰©ç‚¹ï¼ŒåŒæ ·ä¹Ÿç”¨åŒæ ·çš„åŸåˆ™è¾¨åˆ«çœŸå‡ æœ€å cnt è°ƒæˆ å½“å‰ç»„å†…ç‚¹æ•°/2 è¿‡äº†ã€‚ã€‚ã€‚ *Jæ®è¯´æ˜¯åˆ†å—ï¼Œè¡¥ä¸€ä¸‹","link":"/2020/07/13/2020%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"},{"title":"å›æ»šè«é˜Ÿ","text":"ä»‹ç»åœ¨ä¸€äº›ç”¨è«é˜Ÿå¤„ç†çš„é—®é¢˜ä¸­ï¼Œæ‰©å±•åŒºé—´å®¹æ˜“ä½†æ”¶ç¼©åŒºé—´ä¸å¥½å¤„ç†ï¼Œè¿™æ—¶å¯ä»¥è€ƒè™‘ä½¿ç”¨å›æ»šè«é˜Ÿçš„æŠ€å·§ï¼Œä»¥è¾¾åˆ°åŒºé—´åªå¢ä¸å‡çš„æ•ˆæœã€‚ å…·ä½“æ­¥éª¤ å¯¹è¯¢é—®ç¦»çº¿å¹¶æ’åºï¼Œä»¥å·¦ç«¯ç‚¹æ‰€åœ¨å—å·ä¸ºç¬¬ä¸€å…³é”®å­—ï¼Œå³ç«¯ç‚¹å¤§å°ä¸ºç¬¬äºŒå…³é”®å­—è¿›è¡Œæ’åº ä»¥å—å·é€’å¢çš„é¡ºåºå¤„ç†è¯¢é—®ï¼Œæ¯æ¬¡åªè€ƒè™‘å·¦ç«¯ç‚¹åœ¨è¯¥å—å†…çš„è¯¢é—® æš´åŠ›å›ç­”æ‰€æœ‰å·¦å³ç«¯ç‚¹éƒ½åœ¨å—å†…çš„è¯¢é—® è®°å½“å‰å—å·ä¸º $k$ï¼ŒåŒºé—´ä¸º $[st[k],ed[k]]$ï¼Œè€ƒè™‘å‰©ä¸‹çš„è¯¢é—®ï¼Œæ˜¾ç„¶è¯¢é—®çš„å³ç«¯ç‚¹éƒ½å¤§äº $ed[k]$ å¹¶ä¸”é€’å¢ è®°å½“å‰å·²æ±‚å¾—ç­”æ¡ˆçš„åŒºé—´ä¸º $[l,r]$ï¼Œç­”æ¡ˆä¸º $pre$ï¼Œè‹¥è¯¥è¯¢é—®æ˜¯è¯¥å—å†…çš„ç¬¬ä¸€æ¬¡è¯¢é—®åˆ™åˆå§‹åŒ–åŒºé—´ä¸º $[l=ed[k]+1, r=ed[k]]$ æ‰©å±• $r$ è‡³å½“å‰è¯¢é—®çš„å³è¾¹ç•Œï¼Œå¹¶æ›´æ–°ç­”æ¡ˆ $pre$ å»ºç«‹ä¸´æ—¶å˜é‡ $ans=pre$ï¼Œæ‰©å±• $l$ è‡³å½“å‰è¯¢é—®çš„å·¦è¾¹ç•Œï¼Œå¹¶æ›´æ–°ç­”æ¡ˆ $ans$ï¼Œæ‰©å±•å®Œæ¯•åç”¨ $ans$ å›ç­”å½“å‰è¯¢é—® å›æ’¤å·¦ç«¯ç‚¹ $l$ è‡³ $ed[k]+1$ï¼Œå¹¶æ’¤é”€æ‰©å±• $l$ æ—¶å¯¹è¾…åŠ©å˜é‡çš„æ›´æ”¹ï¼Œä¿ç•™ $pre$ ç”¨äºä¸‹æ¬¡è¯¢é—®ï¼ˆå³å›æ’¤åŒºé—´è‡³ $[ed[k],r]$ï¼‰ è¿™æ ·æˆ‘ä»¬å°±å®ç°äº†åŒºé—´åªå¢ä¸å‡çš„è«é˜Ÿï¼Œæ­¥éª¤ 8 ä¸­æ’¤é”€å·¦è¾¹ç•Œçš„å…·ä½“å®ç°è§†æ‰€ç”¨è¾…åŠ©å˜é‡è€Œå®šï¼Œä¾‹å¦‚æ¡¶çš„è¯å°± $cnt[value]â€”$ï¼Œå¹¶æŸ¥é›†çš„è¯ç”¨æŒ‰ç§©åˆä»¥æ”¯æŒæ’¤é”€æ“ä½œã€‚ åˆ†æä¸‹å¤æ‚åº¦ï¼Œå‡å®š $n$ å’Œ $m$ åŒæ•°é‡çº§ï¼Œå–å—å¤§å° $B = \\sqrt{n}$ï¼Œæš´åŠ›å¤„ç†å—å†…è¯¢é—® $O(\\sqrt{n})$ï¼Œæ¯ä¸ªå—å†…å³ç«¯ç‚¹è‡³å¤šæ‰©å±• $n$ æ¬¡ $O(n\\sqrt{n})$ï¼Œå·¦ç«¯ç‚¹æ¯æ¬¡æœ€å¤šæ‰©å±•å’Œæ’¤é”€ $\\sqrt{n}$ æ¬¡ï¼Œå› æ­¤æ€»å¤æ‚åº¦ä»ä¸º $O(n\\sqrt{n})$ã€‚ æ¨¡æ¿AtCoder1219 å†å²ç ”ç©¶ æ‰©å±•å³ç«¯ç‚¹ï¼šcnt[x]++,pre=max(pre,cnt[x]*x) æ‰©å±•å³ç«¯ç‚¹ï¼šcnt[x]++,ans=max(ans,cnt[x]*x) å›æ’¤å·¦ç«¯ç‚¹ï¼šcnt[x]-- 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const int SZ = sqrt(MAXN);vector&lt;int&gt; X;int n,m,z;int a[MAXN],b[MAXN],cnt[MAXN],id[MAXN],st[MAXN],ed[MAXN],t[MAXN];struct query{ int l,r,i; LL ans; bool operator &lt;(const query &amp;t)const { if(id[t.l]!=id[l])return id[l]&lt;id[t.l]; return r&lt;t.r; }}q[MAXN];inline LL baoli(int l,int r){ LL ans=0; fp(i,l,r)t[b[i]]++,ans=max(ans,1LL*t[b[i]]*a[i]); fp(i,l,r)t[b[i]]--; return ans;}int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); fp(i,1,n)scanf(&quot;%d&quot;,&amp;a[i]),X.pb(a[i]); fp(i,1,n)id[i]=(i-1)/SZ+1; z=id[n]; fp(i,1,n)if(!st[id[i]])st[id[i]]=i; fd(i,n,1)if(!ed[id[i]])ed[id[i]]=i; sort(all(X)),unq(X); fp(i,1,n)b[i]=lb(all(X),a[i])-X.begin()+1; fp(i,1,m)scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r),q[i].i=i; sort(q+1,q+1+m); LL ans=0,pre=0; for(int i=1,l,r;i&lt;=m;i++) { int k=id[q[i].l]; if(id[q[i].l]!=id[q[i-1].l])mst(cnt,0),ans=pre=0,r=ed[k],l=ed[k]+1; if(id[q[i].l]==id[q[i].r])q[i].ans=baoli(q[i].l,q[i].r); else { while(l&lt;=ed[k])cnt[b[l]]--,l++; while(r&lt;q[i].r)r++,cnt[b[r]]++,pre=max(pre,1LL*cnt[b[r]]*a[r]); ans=pre; while(l&gt;q[i].l)l--,cnt[b[l]]++,ans=max(ans,1LL*cnt[b[l]]*a[l]); q[i].ans=ans; } } sort(q+1,q+1+m,[](const query &amp;a,const query &amp;b){return a.i&lt;b.i;}); fp(i,1,m)printf(&quot;%lld\\n&quot;,q[i].ans); return 0;} ç»ƒä¹ Luogu P5906 ã€æ¨¡æ¿ã€‘å›æ»šè«é˜Ÿ&amp;ä¸åˆ é™¤è«é˜Ÿæ‰©å±•å³ç«¯ç‚¹å†æ›´æ–°ç­”æ¡ˆçš„åŒæ—¶è®°å½•æ¯ä¸ªæ•°çš„æœ€å³å‡ºç°ä½ç½®ï¼Œæ‰©å±•å·¦ç«¯ç‚¹æ—¶ç”¨åŒºé—´å†…æœ€é å³çš„ä½ç½®æ›´æ–°ç­”æ¡ˆã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const int SZ = sqrt(MAXN);int n,m;int a[MAXN],t[MAXN],s1[MAXN],s2[MAXN];int id[MAXN],st[MAXN],ed[MAXN];struct query{int l,r,i,ans;}q[MAXN];vector&lt;int&gt; X;int baoli(int l,int r){ int ans=0; fp(i,l,r) if(!t[a[i]]) t[a[i]]=i; else ans=max(ans,i-t[a[i]]); fp(i,l,r)t[a[i]]=0; return ans;}int work(){ scanf(&quot;%d&quot;,&amp;n); fp(i,1,n)scanf(&quot;%d&quot;,&amp;a[i]),X.pb(a[i]); fp(i,1,n)id[i]=(i-1)/SZ+1; fp(i,1,n)if(!st[id[i]])st[id[i]]=i; fd(i,n,1)if(!ed[id[i]])ed[id[i]]=i; sort(all(X)),unq(X); fp(i,1,n)a[i]=lb(all(X),a[i])-X.begin()+1; scanf(&quot;%d&quot;,&amp;m); fp(i,1,m)scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r),q[i].i=i; sort(q+1,q+1+m,[](const query &amp;a,const query &amp;b) { if(id[a.l]!=id[b.l])return id[a.l]&lt;id[b.l]; return a.r&lt;b.r; }); int pre=0,ans=0,l,r; fp(i,1,m) { int k=id[q[i].l]; if(id[q[i].l]!=id[q[i-1].l]) { r=ed[k],l=ed[k]+1,ans=pre=0,mst(s1,0),mst(s2,0); } if(id[q[i].l]==id[q[i].r])q[i].ans=baoli(q[i].l,q[i].r); else { while(r&lt;q[i].r) { r++,s2[a[r]]=r; if(!s1[a[r]])s1[a[r]]=r; else pre=max(pre,r-s1[a[r]]); } ans=pre; while(l&gt;q[i].l) { l--; if(!t[a[l]])t[a[l]]=l; else ans=max(ans,t[a[l]]-l); if(s2[a[l]])ans=max(ans,s2[a[l]]-l); } while(l&lt;=ed[k])t[a[l]]=0,l++; q[i].ans=ans; } } sort(q+1,q+1+m,[](const query &amp;a,const query &amp;b){return a.i&lt;b.i;}); fp(i,1,m)printf(&quot;%d\\n&quot;,q[i].ans); return 0;} ICPC2017åŒ—äº¬Cæ˜¾ç„¶æ‰©å±•åŒºé—´æ—¶ç”¨å¹¶æŸ¥é›†å¯ä»¥å¾ˆç®€å•çš„ç»´æŠ¤ç­”æ¡ˆï¼Œå®ç°å¹¶æŸ¥é›†æ’¤é”€ååº”ç”¨å›æ»šè«é˜Ÿå³å¯ è¿™é¢˜æœ‰ç‚¹ç„å­¦ï¼Œç†è®ºä¸Šæ¥è¯´åº”è¯¥æŒ‰åº¦æ•°åˆ†å—ï¼Œå› ä¸ºæ‰©å±•åŒºé—´çš„å¤æ‚åº¦å¹¶ä¸æ˜¯ $O(1)$ çš„ï¼Œè€Œæ˜¯å–å†³äºè¯¥ç‚¹å‘åŒºé—´å†…çš„è¿è¾¹æ•°ã€‚é‚£ä¹ˆåº”è¯¥ä¿è¯å—å†…æ€»åº¦æ•°åœ¨ $\\sqrt{m}$ çš„æ•°é‡çº§å†…ã€‚ã€‚ã€‚ä½†è¿™ä¹ˆåˆ†å—ä¼š TLEï¼Œä¼°è®¡æ•°æ®çš„è¿è¾¹éƒ½æ˜¯éšæœºçš„ï¼Œæ¯ä¸ªå—å†…çš„è¾¹æ•°éƒ½åœ¨ $\\sqrt{n}$ å·¦å³å§ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798const int B = sqrt(50000);struct dsu{ struct info{int fa,sz;}t[MAXN]; vector&lt;pair&lt;int,info&gt;&gt; v; void init(int n) { fp(i,1,n)t[i]={i,1}; v.clear(); } int find(int x){return t[x].fa==x?x:find(t[x].fa);} LL merge(int a,int b) { int fa=find(a),fb=find(b); LL ans=0; v.pb({fa,t[fa]}); v.pb({fb,t[fb]}); if(fa!=fb) { if(t[fa].sz&gt;t[fb].sz)swap(fa,fb); ans=1LL*t[fa].sz*t[fb].sz; t[fa].fa=fb; t[fb].sz+=t[fa].sz; } return ans; } void undo() { t[v.back().fi]=v.back().se,v.ppb(); t[v.back().fi]=v.back().se,v.ppb(); }}S,T;int n,m,q;int id[MAXN],st[MAXN],ed[MAXN];vector&lt;int&gt; G[MAXN];struct edge{int u,v;}e[MAXN];struct query{int l,r;LL ans;int i;}a[MAXN];void add(int i,int l,int r,dsu &amp;d,LL &amp;ans,int &amp;cnt){ auto it = lb(all(G[i]),l), ed = ub(all(G[i]),r); for(;it!=ed;it++) { int j=*it; ans+=d.merge(i,j); cnt++; }}LL baoli(int l,int r){ int cnt=0; LL ans=0; fp(i,l,r)add(i,l,r,T,ans,cnt); while(cnt--)T.undo(); return ans;}int work(){ MC { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); S.init(n),T.init(n); fp(i,1,n)G[i].clear(); fp(i,1,n)id[i]=(i-1)/B+1,st[id[i]]=ed[id[i]]=0; fp(i,1,n)if(!st[id[i]])st[id[i]]=i; fd(i,n,1)if(!ed[id[i]])ed[id[i]]=i; fp(i,1,m)scanf(&quot;%d%d&quot;,&amp;e[i].u,&amp;e[i].v); fp(i,1,q)scanf(&quot;%d%d&quot;,&amp;a[i].l,&amp;a[i].r),a[i].i=i; sort(a+1,a+1+q,[](const query &amp;a,const query &amp;b) { if(id[a.l]!=id[b.l])return id[a.l]&lt;id[b.l]; return a.r&lt;b.r; }); fp(i,1,m)G[e[i].u].pb(e[i].v),G[e[i].v].pb(e[i].u); fp(i,1,n)sort(all(G[i])); int l,r; LL ans=0,pre=0; fp(i,1,q) { int k=id[a[i].l]; if(id[a[i].l]!=id[a[i-1].l])S.init(n),ans=pre=0,r=ed[k],l=ed[k]+1; if(id[a[i].l]==id[a[i].r])a[i].ans=baoli(a[i].l,a[i].r); else { int cnt=0; while(r&lt;a[i].r)r++,add(r,l,r,S,pre,cnt); cnt=0,ans=pre; while(l&gt;a[i].l)l--,add(l,l,r,S,ans,cnt); a[i].ans=ans,l=ed[k]+1; while(cnt--)S.undo(); } } fp(i,1,n)G[i].clear(); sort(a+1,a+1+q,[](const query &amp;a,const query &amp;b) { return a.i&lt;b.i; }); fp(i,1,q)printf(&quot;%lld\\n&quot;,a[i].ans); } return 0;}","link":"/2020/07/07/%E5%9B%9E%E6%BB%9A%E8%8E%AB%E9%98%9F/"},{"title":"2020æ ¡é˜Ÿé¢„é€‰èµ›A-å­—ç¬¦çŸ©é˜µ-é¢˜è§£","text":"å…³äºæœ¬æ¬¡æ¯”èµ›é¦–å…ˆé“ä¸ªæ­‰ï¼Œå¡æ‰äº†æ—¶ç©ºå¤æ‚åº¦ä¸º $n^3$ çš„ $dp$ åšæ³•ç¡®å®æ˜¯ä¸åº”è¯¥ï¼Œé›¶åŸºç¡€çš„è¯èƒ½è‡ªå­¦åˆ°æŒæ¡åŸºæœ¬ $dp$ çš„ç¨‹åº¦åº”è¯¥æ˜¯å¾ˆä¼˜ç§€çš„æ°´å¹³äº†ã€‚ è€Œæœ¬æ¬¡ç»„é¢˜é—®é¢˜ä¹Ÿå¾ˆå¤šï¼ŒåŒ…æ‹¬æ²¡æœ‰ä¸€ä¸ªæ€»çš„å‘½é¢˜äººæ¥æŠŠæ¡æ•´ä½“éš¾åº¦ å’Œ â€œç¥–å®‰â€ ä¸€é¢˜å‡ºç°æ„æ–™å¤–çš„è§£æ³•(æ­£åˆ™è¡¨è¾¾å¼)ç­‰ã€‚å†æ¬¡å¯¹æˆ‘ä»¬å‘½é¢˜å·¥ä½œçš„ä¸å½“å¯¼è‡´å¤§å®¶ä¸å¥½çš„æ¯”èµ›ä½“éªŒé“ä¸ªæ­‰ã€‚ ä½†æ¯ä¸ªé¢˜æ‰€æ¶‰åŠçš„çŸ¥è¯†ç‚¹å¤šä¸ºç®—æ³•ç«èµ›ä¸­å®ç”¨çš„ç®—æ³•æˆ–æŠ€å·§ï¼Œæ•°æ®ä¹Ÿç»è¿‡å¤šæ¬¡éªŒè¯ï¼Œæ¬¢è¿å¤§å®¶èµ›åè¡¥é¢˜ã€‚ é¢˜ç›®æ¥æºDiv.1 #517 B çš„ç®€åŒ–ç‰ˆæœ¬ é¢˜è§£å›åˆ°æœ¬é¢˜ï¼Œé¢˜ç›®å¤§æ„ä¸ºç»™ä½ ä¸€ä¸ª $n*n$ å¤§å°çš„çŸ©é˜µï¼Œæ¯ä¸ªä½ç½®ä¸Šæœ‰ä¸€ä¸ªå°å†™å­—æ¯ï¼Œä» $(1,1)$ å¼€å§‹æ¯æ¬¡å‘å³æˆ–å‘ä¸‹ç§»åŠ¨åˆ°è¾¾ $(n,n)$ å¹¶æŒ‰é¡ºåºå–èµ°è·¯å¾„ä¸Šçš„å­—ç¬¦æ¥å½¢æˆä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¯·ä½ æ±‚å‡ºå…¶ä¸­å­—å…¸åºæœ€å°çš„è§£ã€‚ O(n^3)è€ƒè™‘ä½¿ç”¨åŠ¨æ€è§„åˆ’ï¼Œ$f[i][j]$ è¡¨ç¤ºä» $(1,1)$ å‡ºå‘åˆ° $(i,j)$ æ‰€èƒ½å½¢æˆçš„å­—å…¸åºæœ€å°çš„å­—ç¬¦ä¸²ï¼Œè½¬ç§»æ–¹ç¨‹ä¸º: f[i][j] = min(f[i-1][j],f[i][j-1]) + s[i][j];å…¶ä¸­ $s[i][j]$ è¡¨ç¤ºçŸ©é˜µ $(i,j)$ ä½ç½®çš„å­—ç¬¦ï¼Œ$â€+â€$ è¡¨ç¤ºå­—ç¬¦ä¸²çš„æ‹¼æ¥ã€‚ è¿™ä¸ª $dp$ çœ‹èµ·æ¥çŠ¶æ€åªæœ‰ $n^2$ï¼Œä½†è½¬ç§»å®é™…ä¸Šæ˜¯ $O(n)$ çš„ï¼Œå› ä¸ºå­—ç¬¦ä¸²å­—å…¸åºçš„æ¯”è¾ƒ(åŒ…æ‹¬std::string)æ˜¯ $O(n)$ çš„ï¼Œå› æ­¤æ€»ä½“æ—¶é—´å¤æ‚åº¦ä¸º $O(n^3)$ï¼Œ$n=2000$ æ—¶è®¡ç®—æ¬¡æ•°çº¦ä¸º $8e9$ï¼Œè€Œè¾ƒå¿«çš„è¯„æµ‹æœºå¤§æ¦‚ 5s å¯ä»¥è·‘ $1e9$ï¼Œæ— æ³•é€šè¿‡æœ¬é¢˜ï¼Œè€Œä¸”ç©ºé—´å¤æ‚åº¦ä¹Ÿä¸º $O(n^3)$ï¼Œäº¤ä¸Šå»ä¼š $MLE$ã€‚ 123456789101112131415161718192021222324int n;string f[MAXN][MAXN];char s[MAXN][MAXN];int work(){ scanf(&quot;%d&quot;,&amp;n); fp(i,1,n)scanf(&quot;%s&quot;,s[i]+1); f[1][1]=s[1][1]; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { if(i!=1||j!=1) { if(i==1)f[i][j]=f[i][j-1]; else if(j==1)f[i][j]=f[i-1][j]; else f[i][j]=min(f[i-1][j],f[i][j-1]); f[i][j].pb(s[i][j]); } } } printf(&quot;%s&quot;,f[n][n].c_str()); return 0;} O(n^2)è€ƒè™‘ä¸€ä¸ªæœ´ç´ çš„è´ªå¿ƒç®—æ³•ï¼Œç”±äºå­—å…¸åºæ¯”è¾ƒçš„ç‰¹æ®Šæ€§ï¼Œæˆ‘ä»¬éœ€è¦è®©é å‰çš„å­—æ¯å°½é‡çš„å°ï¼Œå› æ­¤ä» $(1,1)$ å‡ºå‘æ¯æ¬¡é€‰æ‹©è¾ƒå°çš„å­—ç¬¦è¿›è¡Œè½¬ç§»ã€‚ ä½†è€ƒè™‘ bbabbbbbb çš„æƒ…å†µï¼Œæˆ‘ä»¬æ— æ³•ç¡®å®šä» $(1,1)$ å¼€å§‹ä¸‹ä¸€æ­¥åº”è¯¥è½¬ç§»åˆ°å“ªé‡Œï¼Œå¦‚æœä½¿ç”¨ $dfs$ çš„è¯å¤æ‚åº¦ä¹Ÿæ˜¯ $n!$ çº§åˆ«ã€‚ ä½†å®é™…ä¸Šå¯¹äºè¿™ç§æ— æ³•ç¡®å®šçš„è½¬ç§»ä¸€å®šæ˜¯åœ¨åŒä¸€å¯¹è§’çº¿ä¸Šçš„(å¯¹åº”çš„å­—ç¬¦ä¸²é•¿åº¦ç›¸åŒ)ï¼Œæˆ‘ä»¬å¯ä»¥å»é‡åå…¨éƒ¨ä¿ç•™ï¼Œè¿™ç§è½¬ç§»æ•°æ€»çº§åˆ«æ˜¯ $O(n^2)$ çº§åˆ«çš„ï¼Œè€ƒè™‘åˆ°æ‰©å±•ä¸€ä¸ªå­—ç¬¦æ˜¯ $O(1)$çš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸€ä¸ª $O(n^2)$ çš„ç®—æ³•ï¼š é¡ºåºè€ƒè™‘å­—ç¬¦ä¸²ç¬¬ $i$ ä½çš„å­—ç¬¦ $(1&lt;=i&lt;=2*n-1)$: 1. å»ºç«‹ä¸€ä¸ªå¾…æ‰©å±•é˜Ÿåˆ—ï¼Œåˆå§‹æ—¶åªæœ‰ (1,1) 2. æŸ¥æ‰¾å¾…æ‰©å±•é˜Ÿåˆ—ä¸­æœ€å°çš„å­—ç¬¦ï¼Œè®° cï¼ŒåŒæ—¶ä¸ºç­”æ¡ˆæœ«å°¾æ·»åŠ ä¸Š c 3. ä¿ç•™é˜Ÿåˆ—ä¸­ s[i][j]==c çš„ (i,j) 4. å¯¹äºä¿ç•™ä¸‹æ¥çš„ (i,j)ï¼Œæ·»åŠ  (i+1,j) å’Œ (i,j+1) åˆ°æ–°æ‰©å±•é˜Ÿåˆ—ä¸­ 5. å°†æ—§æ‰©å±•é˜Ÿåˆ—æ›¿æ¢ä¸ºæ–°æ‰©å±•é˜Ÿåˆ— 6. è‹¥æ²¡åˆ°è¾¾ (n,n) ä»ç¬¬äºŒæ­¥å¼€å§‹é‡å¤ å®é™…å†™æ³•ç±»ä¼¼äº $bfs$ï¼Œæ—¶ç©ºå¤æ‚åº¦å‡ä¸º $O(n^2)$ å¯ä»¥é€šè¿‡æœ¬é¢˜ã€‚ 12345678910111213141516171819202122232425262728293031int n;vector&lt;pr&gt; v,t;string ans;char s[MAXN][MAXN];bool vis[MAXN][MAXN];int main(){ cin &gt;&gt; n; fp(i,1,n)fp(j,1,n)cin &gt;&gt; s[i][j]; ans.clear(),v.clear(),t.clear(),t.push_back({1,1}),vis[1][1]=1; while(1) { char c='z'+1; for(auto p:t)c=min(s[p.fi][p.se],c); ans.push_back(c); if(t.front().fi==n&amp;&amp;t.front().se==n)break; v.clear(); for(auto p:t)if(s[p.fi][p.se]==c) { if(p.fi!=n&amp;&amp;!vis[p.fi+1][p.se]) v.push_back({p.fi+1,p.se}), vis[p.fi+1][p.se]=1; if(p.se!=n&amp;&amp;!vis[p.fi][p.se+1]) v.push_back({p.fi,p.se+1}), vis[p.fi][p.se+1]=1; } swap(v,t); } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2020/06/14/2020%E6%A0%A1%E9%98%9F%E9%A2%84%E9%80%89%E8%B5%9BA-%E5%AD%97%E7%AC%A6%E7%9F%A9%E9%98%B5-%E9%A2%98%E8%A7%A3/"},{"title":"å†³ç­–å•è°ƒæ€§ä¼˜åŒ–dp","text":"ç”¨æ¥å­˜ä¸‹æ¿å­ã€‚ã€‚ã€‚è¯æ˜æˆ–è¯¦ç»†è®²è§£è¯·å‚è€ƒå…¶ä»–blog å†³ç­–å•è°ƒæ€§å¯ç¦»çº¿åˆ†æ²» ä¾‹ï¼šCF321E 123456789void solve(int s,int l=1,int r=n,int nl=0,int nr=n-1){ if(l&gt;r) return; int m = mid,from; f[s][m]=inf; fp(i,nl,min(nr,m-1)) if(f[s-1][i]+cost(i+1,m)&lt;f[s][m]) f[s][m]=f[s-1][i]+cost(i+1,m),from=i; solve(s,l,m-1,nl,from),solve(s,m+1,r,from,nr);} ä¸å¯ç¦»çº¿å†™æ³•å‚è€ƒè‡ªï¼šæµ…æ1D1DåŠ¨æ€è§„åˆ’çš„ä¼˜åŒ– ç¡®å®š $f[3]$ ä¹‹å‰æ‰€æœ‰çŠ¶æ€çš„æœ€ä¼˜å†³ç­–è¡¨ï¼š 1111111111111222222222222 åŠ å…¥ $f[3]$ åå†³ç­–è¡¨åªèƒ½æœ‰ä¸‰ç§ç±»å‹ 1111111111111222222222222 ä¸å˜ 1111111111111222223333333 å æ® $2$ çš„ä¸€éƒ¨åˆ† 1111113333333333333333333 å®Œå…¨è¦†ç›– $2$ è€ƒè™‘ä½¿ç”¨æ ˆæ¥ç»´æŠ¤æ¯ä¸ª $i$ ä½œä¸ºå†³ç­–ç‚¹çš„èµ·å§‹ä½ç½® è®¾è€å†³ç­–çš„èµ·ç‚¹ä¸º $j$ï¼Œä»æ ˆé¡¶å‘ä¸‹ä¾æ¬¡è€ƒè™‘ï¼š è‹¥æ–°å†³ç­–åœ¨ $j$ ä¼˜äºè€å†³ç­–ï¼Œåˆ™é€€æ ˆå¹¶æŠ›å¼ƒè€å†³ç­– å¦åˆ™ï¼Œè½¬æŠ˜ç‚¹ä¸€å®šåœ¨å½“å‰è¿™ä¸ªè€å†³ç­–çš„åŒºé—´ä¸­ï¼ŒäºŒåˆ†è¿™ä¸ªä½ç½® æ–°å†³ç­–å…¥æ ˆ ä¾‹ï¼š [NOI2009]è¯—äººå°G 12345678910111213141516171819pr s[MAXN]; int h=0;LL calc(int i,int j){return f[j]+cost(i,j);}fp(i,1,n){ pr t=*(ub(s+1,s+h+1,mp(i,inf))-1); f[i]=calc(i,t.se),from[i]=t.se; if(i==n||calc(n,s[h].se)&lt;calc(n,i))continue; while(h&amp;&amp;s[h].fi&gt;i&amp;&amp;calc(s[h].fi,s[h].se)&gt;calc(s[h].fi,i))h--; int l=max(i+1,s[h].fi),r=n,ans=n; while(l&lt;=r) { if(calc(mid,s[h].se)&gt;calc(mid,i))ans=mid,r=mid-1; else l=mid+1; } s[++h]={ans,i};}","link":"/2020/05/25/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7%E4%BC%98%E5%8C%96dp/"},{"title":"kruskalé‡æ„æ ‘","text":"Kruskalé‡æ„æ ‘èµ„æ–™Kruskalé‡æ„æ ‘å…¥é—¨ è‡ªä¸ºé£æœˆé©¬å‰å’ æ¨¡æ¿æ„å»ºæ–¹æ³•ï¼šåˆå§‹æ—¶æœ‰ $n$ ä¸ªå¶å­èŠ‚ç‚¹ï¼Œè¿è¡Œ $kruskal$ æœ€å°ç”Ÿæˆæ ‘ç®—æ³•ï¼Œå¯¹äºç”¨è¾¹æƒä¸º $w$ è¿æ¥ä¸¤ä¸ªèŠ‚ç‚¹ $(u,v)$, æ–°å»ºä¸€ä¸ªæƒå€¼ä¸º $w$ çš„èŠ‚ç‚¹ $x$ï¼Œå¹¶è¿è¾¹ $(x,root(u))$ å’Œ $(x,root(v))$, å¹¶å°† $x$ ç½®ä¸ºè¿™é¢—æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚ è¿™æ ·å»ºå‡ºæ¥çš„å…¶å®æ˜¯ä¸€ä¸ªå¤§æ ¹å †ï¼Œå¯ä»¥ç”¨æ¥æ±‚ä»ç‚¹ $x$ å‡ºå‘åªèµ°è¾¹æƒ $&lt;=w$ çš„è¾¹èƒ½åˆ°è¾¾çš„ç‚¹çš„æå¤§é›†åˆ åšæ³•å°±æ˜¯ä» $x$ å€å¢å¾€ä¸Šé¢è·³ç›´åˆ°ç‚¹æƒ $&gt;w$ï¼Œè®¾è·³åˆ°çš„ç‚¹ä¸º $u$ï¼Œé‚£ä¹ˆ $u$ çš„æ‰€æœ‰å¶å­å°±æ˜¯æ‰€æ±‚çš„æå¤§é›†åˆ è¿˜æœ‰ä¸€ä¸ªæ€§è´¨æ˜¯ï¼šä»»æ„ä¸¤ä¸ªç‚¹è·¯å¾„ä¸Šè¾¹æƒçš„æœ€å¤§å€¼ä¸ºå®ƒä»¬çš„LCAçš„ç‚¹æƒ ä¾‹é¢˜PeaksåŠ å¼ºç‰ˆ åœ¨Bytemountainsæœ‰Nåº§å±±å³°ï¼Œæ¯åº§å±±å³°æœ‰ä»–çš„é«˜åº¦hiã€‚ æœ‰äº›å±±å³°ä¹‹é—´æœ‰åŒå‘é“è·¯ç›¸è¿ï¼Œå…±Mæ¡è·¯å¾„ï¼Œæ¯æ¡è·¯å¾„æœ‰ä¸€ä¸ªå›°éš¾å€¼ï¼Œè¿™ä¸ªå€¼è¶Šå¤§è¡¨ç¤ºè¶Šéš¾èµ°. ç°åœ¨æœ‰Qç»„è¯¢é—®ï¼Œæ¯ç»„è¯¢é—®è¯¢é—®ä»ç‚¹vå¼€å§‹åªç»è¿‡å›°éš¾å€¼å°äºç­‰äºxçš„è·¯å¾„æ‰€èƒ½åˆ°è¾¾çš„å±±å³°ä¸­ç¬¬ké«˜çš„å±±å³°ï¼Œå¦‚æœæ— è§£è¾“å‡ºâˆ’1 kruskalé‡æ„æ ‘ + ä¸»å¸­æ ‘ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556vector&lt;int&gt; X;EDGE(MAXN,MAXN*2);int n,m,q,cnt,last=-1;int h[MAXN],a[MAXN],b[MAXN],fa[MAXN],st[MAXN],ed[MAXN],f[MAXN][21];struct temp{int u,v,w;}edg[N];int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}void dfs(int u,int fa){ st[u]=++cnt,b[cnt]=h[u],f[u][0]=fa; go(u)if(v!=fa)dfs(v,u); ed[u]=cnt;}int root[MAXN],s[MAXN*10],ls[MAXN*10],rs[MAXN*10],cnt_;void update(int pre,int &amp;rt,int l,int r,int pos){ if(!rt)rt=++cnt_; s[rt]=s[pre]+1; if(l==r)return; if(pos&lt;=mid)update(ls[pre],ls[rt],l,mid,pos),rs[rt]=rs[pre]; else update(rs[pre],rs[rt],mid+1,r,pos),ls[rt]=ls[pre];}void query(int pre,int rt,int l,int r,int k){ if(l==r){printf(&quot;%d\\n&quot;,X[l-1]),last=X[l-1];return;} int sum=s[rs[rt]]-s[rs[pre]]; if(sum&gt;=k)query(rs[pre],rs[rt],mid+1,r,k); else query(ls[pre],ls[rt],l,mid,k-sum);}bool cmp(const temp &amp;a,const temp &amp;b){return a.w&lt;b.w;}int work(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); fp(i,1,n)scanf(&quot;%d&quot;,&amp;h[i]),X.pb(h[i]); sort(all(X)),unq(X); fp(i,1,n)h[i]=lb(all(X),h[i])-X.begin()+1; fp(i,1,2*n)fa[i]=i; fp(i,1,m)scanf(&quot;%d%d%d&quot;,&amp;edg[i].u,&amp;edg[i].v,&amp;edg[i].w); sort(edg+1,edg+1+m,cmp); fp(i,1,m)if(find(edg[i].u)!=find(edg[i].v)) { a[++n]=edg[i].w; int fu=find(edg[i].u),fv=find(edg[i].v); addedge(n,fu),addedge(n,fv),fa[fu]=fa[fv]=n; } fp(i,1,n)if(!st[i])dfs(find(i),0); fp(j,1,20)fp(i,1,n)f[i][j]=f[f[i][j-1]][j-1]; fp(i,1,n) if(b[i])update(root[i-1],root[i],1,X.size(),b[i]); else root[i]=root[i-1]; while(q--) { int u,x,k;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;x,&amp;k); if(last!=-1)u^=last,x^=last,k^=last; fd(i,20,0)if(f[u][i]&amp;&amp;a[f[u][i]]&lt;=x)u=f[u][i]; int l=st[u],r=ed[u]; if(s[root[r]]-s[root[l-1]]&lt;k)printf(&quot;-1\\n&quot;),last=-1; else query(root[l-1],root[r],1,X.size(),k); } return 0;}","link":"/2020/05/25/kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"},{"title":"çº¿æ®µæ ‘åˆå¹¶ çº¿æ®µæ ‘åˆ†è£‚ çº¿æ®µæ ‘ä¼˜åŒ–å»ºå›¾(çº¿æ®µæ ‘ä¸‰è¿)","text":"çº¿æ®µæ ‘åˆå¹¶å‚è€ƒèµ„æ–™çº¿æ®µæ ‘çš„åˆå¹¶ ç®€ä»‹é»˜è®¤ä½¿ç”¨åŠ¨æ€å¼€ç‚¹çš„çº¿æ®µæ ‘ è€ƒè™‘å¦‚ä¸‹é—®é¢˜ï¼šç°åœ¨æœ‰ä¸¤æ£µå€¼åŸŸç›¸åŒçš„æƒå€¼çº¿æ®µæ ‘ï¼Œä½ éœ€è¦å°†ä¸¤é¢—çº¿æ®µæ ‘å¯¹åº”èŠ‚ç‚¹çš„ä¿¡æ¯åˆå¹¶ï¼Œå¾—åˆ°ä¸€é¢—æ–°çš„çº¿æ®µæ ‘ æ˜¾ç„¶å¯ä»¥å¯å‘å¼åˆå¹¶åšåˆ° $O(lognlogn)$ï¼Œå³æŠŠå¶å­æ•°å°çš„ä¾æ¬¡æ’å…¥åˆ°å¦ä¸€é¢—çº¿æ®µæ ‘ä¸­ï¼Œåœ¨ä¿è¯æ€»ç‚¹æ•°æ˜¯ $n$ çš„çº§åˆ«ä¸‹å¯ä»¥åšåˆ°ä¸¤ä¸ª $log$ ç”±æ­¤å¼•å‡ºä¸€ä¸ªçº¿æ®µæ ‘çš„å°æŠ€å·§ï¼šçº¿æ®µæ ‘åˆå¹¶ ä»£ç å¤§æ¦‚é•¿è¿™æ · 1234567func merge(a,b): if a,bä¸­æœ‰ä¸€ä¸ªä¸ºç©º: è¿”å›å¦ä¸€ä¸ª else if a,béƒ½ä¸ºå¶å­: åˆå¹¶a,b merge_leaf(a,b)å¹¶è¿”å›ç»“æœ else: è¿”å› merge(a-ls,b-&gt;ls) å’Œ merge(a-&gt;rs,b-&gt;rs) è¿æ¥è€Œæˆçš„æ ‘ åˆ†æä¸‹å¤æ‚åº¦ï¼Œå•æ¬¡åˆå¹¶æ“ä½œçš„å¤æ‚åº¦å–å†³äºä¸¤æ£µæ ‘å…¬å…±èŠ‚ç‚¹(å¶å­)çš„ä¸ªæ•°ï¼Œå¯å¤§å¯å° ($O(1)$ ~ $O(nlogn)$) å‡è®¾æˆ‘ä»¬æœ‰ $n$ é¢—ä¸€ä¸ªå…ƒç´ çš„çº¿æ®µæ ‘ï¼Œåˆ†æä¸‹æŠŠä»–åˆå¹¶æˆä¸€ä¸ªçš„å¤æ‚åº¦ï¼š$O(nlogn)$ï¼Œå› æ­¤åœ¨ä¿è¯æ€»ç‚¹æ•°çš„æƒ…å†µä¸‹å¤æ‚åº¦æ˜¯å‡æ‘Š $logn$ çš„ ä½†å®é™…ç”¨èµ·æ¥ä¸ä¸€å®šæ¯”ä¸¤ä¸ª $log$ å¿«ã€‚ã€‚ 12345678int merge(int x,int y,int l,int r){ if(x*y==0)return x+y; if(l==r){mx[x]+=mx[y];return x;} ls[x]=merge(ls[x],ls[y],l,mid); rs[x]=merge(rs[x],rs[y],mid+1,r); up(x);return x;} ä¾‹é¢˜1. [HNOI2012]æ°¸æ— ä¹¡å¹¶æŸ¥é›†+å¯å‘å¼åˆå¹¶å¯ä»¥åšåˆ°ä¸¤ä¸ª $log$ï¼Œçº¿æ®µæ ‘åˆå¹¶çš„è¯åœ¨å¹¶æŸ¥é›†æ¯æ¬¡åˆå¹¶çš„æ—¶å€™ï¼ˆ$a-&gt;b,fa[b]=a$ï¼‰åˆå¹¶æ ¹èŠ‚ç‚¹çš„çº¿æ®µæ ‘ï¼š$root[b]=merge(root[b],root[a])$ å³å¯ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int n,m,q;int fa[MAXN],a[MAXN],id[MAXN];vector&lt;int&gt; X;namespace seg{ int root[MAXN],ls[N],rs[N],s[N],cnt; void insert(int &amp;x,int l,int r,int val) { if(!x)x=++cnt; s[x]++; if(l==r)return; if(val&lt;=mid)insert(ls[x],l,mid,val); else insert(rs[x],mid+1,r,val); } int merge(int x,int y,int l,int r) { if(!(x*y))return x+y; if(l==r)return s[x]+=s[y],x; ls[x]=merge(ls[x],ls[y],l,mid); rs[x]=merge(rs[x],rs[y],mid+1,r); s[x]=s[ls[x]]+s[rs[x]]; return x; } void query(int x,int l,int r,int k) { if(k&gt;s[x]){printf(&quot;-1\\n&quot;);return;} if(l==r){printf(&quot;%d\\n&quot;,id[l]);return;} int num=s[ls[x]]; if(num&gt;=k)query(ls[x],l,mid,k); else query(rs[x],mid+1,r,k-num); }}int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}void merge(int x,int y){ x=find(x),y=find(y); if(seg::s[seg::root[x]]&gt;seg::s[seg::root[y]])swap(x,y); fa[x]=y,seg::root[y]=seg::merge(seg::root[y],seg::root[x],1,n);}int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); fp(i,1,n)scanf(&quot;%d&quot;,&amp;a[i]),X.pb(a[i]); sort(all(X)); fp(i,1,n)a[i]=lb(all(X),a[i])-X.begin()+1,id[a[i]]=i; fp(i,1,n)fa[i]=i,seg::insert(seg::root[i],1,n,a[i]); fp(i,1,m) { int u,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v); if(find(u)!=find(v))merge(u,v); } scanf(&quot;%d&quot;,&amp;q); while(q--) { char opt[5]; int x,y; scanf(&quot;%s%d%d&quot;,opt,&amp;x,&amp;y); if(opt[0]=='Q')seg::query(seg::root[find(x)],1,n,y); if(opt[0]=='B')if(find(x)!=find(y))merge(x,y); } return 0;} 2. CF600E Lomsat gelralè‡ªåº•å‘ä¸Šåˆå¹¶çº¿æ®µæ ‘å³å¯ï¼Œçº¿æ®µæ ‘ä¸Šç»´æŠ¤æ¯ä¸ªé¢œè‰²çš„æœ€å¤§å‡ºç°æ¬¡æ•°å’Œç­”æ¡ˆ æ¯” $dsu$ çš„è§£æ³•å¿«ä¸€ç‚¹ç‚¹ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152GE(MAXN,MAXN*2);int n,cnt;int a[MAXN],root[MAXN];LL ans[MAXN];int ls[N],rs[N],mx[N];LL sum[N];void up(int x){ mx[x]=max(mx[ls[x]],mx[rs[x]]); if(mx[ls[x]]==mx[rs[x]])sum[x]=sum[ls[x]]+sum[rs[x]]; else if(mx[ls[x]]&gt;mx[rs[x]])sum[x]=sum[ls[x]]; else sum[x]=sum[rs[x]];}void build(int &amp;x,int l,int r,int val){ x=++cnt; if(l==r){mx[x]=1,sum[x]=l;return;} if(val&lt;=mid)build(ls[x],l,mid,val); else build(rs[x],mid+1,r,val); up(x);}int merge(int x,int y,int l,int r){ if(x*y==0)return x+y; if(l==r){mx[x]+=mx[y];return x;} ls[x]=merge(ls[x],ls[y],l,mid); rs[x]=merge(rs[x],rs[y],mid+1,r); up(x); return x;}void debug(int x,int l,int r){ if(x==0)return; cout &lt;&lt; dbgs3(x,l,r) &lt;&lt; &quot; &quot; &lt;&lt; dbgs2(mx[x],sum[x]) &lt;&lt; endl; if(l==r)return; debug(ls[x],l,mid); debug(rs[x],mid+1,r);}void dfs(int u,int fa){ build(root[u],1,n,a[u]); go(u)if(v!=fa)dfs(v,u),root[u]=merge(root[u],root[v],1,n); ans[u]=sum[root[u]];}int work(){ scanf(&quot;%d&quot;,&amp;n); fp(i,1,n)scanf(&quot;%d&quot;,&amp;a[i]); fp(i,1,n-1) { int u,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v),addedge(v,u); } dfs(1,0); fp(i,1,n)printf(&quot;%lld &quot;,ans[i]); return 0;} 3. [Vaniæœ‰çº¦ä¼š]é›¨å¤©çš„å°¾å·´ /ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘åˆå¹¶å¦‚æœåªæœ‰ä¸€ç§é¢œè‰²ï¼Œæ˜¾ç„¶åšä¸€ä¸‹æ ‘ä¸Šå·®åˆ†1s[u]++,s[v]++,s[lca]--,s[fa[lca]]--ç„¶åè‡ªåº•å‘ä¸Šåˆå¹¶ s[ ] å³å¯ã€‚ æ‰©å±•åˆ°å¤šç§é¢œè‰²ï¼šä¸ºæ¯ä¸ªèŠ‚ç‚¹ $u$ å¼€ä¸€ä¸ªæ•°ç»„ $f[u][color]$ï¼Œåœ¨é¢œè‰²å¯¹åº”çš„ä½ç½® ++ æˆ– â€” ç„¶åæ¯ä¸ªèŠ‚ç‚¹éƒ½å¼€ä¸€ä¸ªçº¿æ®µæ ‘æ¥ç»´æŠ¤è¿™ä¸ª $f[u]$ æ•°ç»„ï¼Œè‡ªåº•å‘ä¸Šåˆå¹¶çº¿æ®µæ ‘å°±å¯ä»¥å¾—åˆ°æ¯ä¸ªç‚¹çš„æ•‘æµç²®åˆ†å‘æƒ…å†µ åœ¨å·®åˆ†ä¹‹åä¹Ÿå¯ä»¥æ²¿ç”¨ $dsu$ çš„è§£æ³•ï¼Œå¤æ‚åº¦åŒæ ·æ˜¯ä¸€ä¸ª $log$ï¼Œè¿™é‡Œå°±ç»ƒä¸€ä¸‹çº¿æ®µæ ‘åˆå¹¶å•¦ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int n,m;int root[MAXN],a[MAXN];int mx[N],ans[N],ls[N],rs[N],cnt;void up(int x){ if(mx[ls[x]]&gt;=mx[rs[x]])mx[x]=mx[ls[x]],ans[x]=ans[ls[x]]; else mx[x]=mx[rs[x]],ans[x]=ans[rs[x]];}void insert(int &amp;x,int l,int r,int pos,int add){ if(!x)x=++cnt; if(l==r){mx[x]+=add,ans[x]=l;return;} if(pos&lt;=mid)insert(ls[x],l,mid,pos,add); else insert(rs[x],mid+1,r,pos,add); up(x);}int merge(int x,int y,int l,int r){ if(x*y==0)return x+y; if(l==r){mx[x]+=mx[y];return x;} ls[x]=merge(ls[x],ls[y],l,mid); rs[x]=merge(rs[x],rs[y],mid+1,r); up(x);return x;}void dfs(int u,int fa){ go(u)if(v!=fa) dfs(v,u),root[u]=merge(root[u],root[v],1,M); a[u]=mx[root[u]]?ans[root[u]]:0;}int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); fp(i,1,n-1) { int u,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v),addedge(v,u); } lca::init(1); while(m--) { int u,v,z;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;z); int l=lca::query(u,v); insert(root[u],1,M,z,1); insert(root[v],1,M,z,1); insert(root[l],1,M,z,-1); if(lca::fa[l])insert(root[lca::fa[l]],1,M,z,-1); } dfs(1,0); fp(i,1,n)printf(&quot;%d\\n&quot;,a[i]); return 0;} çº¿æ®µæ ‘åˆ†è£‚çº¿æ®µæ ‘ä¼˜åŒ–å»ºå›¾ä¾æ—§ç”±ä¸€ä¸ªé—®é¢˜æ¥å¼•å…¥ï¼š[PA2011]Journeys è€ƒè™‘å¦‚ä½•å®ç°åŒºé—´è¿è¾¹ é¦–å…ˆå»ºä¸¤æ£µçº¿æ®µæ ‘ $in$ å’Œ $out$ ï¼Œ$in$ ä¸­çˆ¶äº²å‘å„¿å­è¿è¾¹æƒä¸º $0$ çš„æœ‰å‘è¾¹ï¼Œout ä¸­å„¿å­å‘çˆ¶äº²è¿è¾¹æƒä¸º $0$ çš„æœ‰å‘è¾¹ï¼Œä¸¤é¢—æ ‘çš„å¶å­èŠ‚ç‚¹å¯¹åº”ç€ç”± $in$ å‘ $out$ è¿è¾¹æƒä¸º $0$ çš„è¾¹ ä¸€ä¸ª $[1,4]$ çš„ä¾‹å­å¦‚ä¸‹ï¼š åŒºé—´ $[a,b]$ å‘ $[c,d]$ è¿è¾¹çš„è¯ï¼Œé¦–å…ˆæ–°å»ºä¸¤ä¸ªèŠ‚ç‚¹ $P1$ $P2$ï¼Œ$P1$ å‘ $P2$ è¿è¾¹æƒä¸º $1$ çš„è¾¹ï¼Œåœ¨ $out$ æ ‘ä¸Šæ‰¾åˆ° $[a,b]$ å¯¹åº”çš„åŒºé—´å¹¶åˆ†åˆ«å‘ $P1$ è¿è¾¹æƒä¸º $0$ çš„è¾¹ï¼Œ$in$ æ ‘åŒç†ï¼Œ$P2$ åˆ†åˆ«å‘ $[c,d]$ æ‰€è¡¨ç¤ºçš„åŒºé—´è¿è¾¹ ä¸€ä¸ª $[1,3]$ å‘ $[3,4]$ è¿è¾¹çš„ä¾‹å­ï¼š ä¼šäº†è¿™ä¸ªè¿™ä¸ªé¢˜å°±å¾ˆè£¸äº†ï¼Œå»ºå®Œå›¾è·‘éæœ€çŸ­è·¯å³å¯ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//ç‚¹æ•° n*4*2+m*2*2//è¾¹æ•° n*4*2+n+(1+logn)*m*2EDGE(N,M);int n,m,S,node=0;int in[MAXN*4],out[MAXN*4],dis[N];bool v[MAXN];vector&lt;int&gt; q1,q2;void build(int l,int r,int cnt){ in[cnt]=++node,out[cnt]=++node; if(cnt/2) { addedge(in[cnt/2],in[cnt],0); addedge(out[cnt],out[cnt/2],0); } if(l==r){addedge(in[cnt],out[cnt],0);return;} else build(l,mid,ls),build(mid+1,r,rs);}void query(int l,int r,int nl,int nr,int id[],vector&lt;int&gt; &amp;v,int cnt){ if(l==nl&amp;&amp;r==nr){v.pb(id[cnt]);return;} if(nr&lt;=mid)query(l,mid,nl,nr,id,v,ls); else if(nl&gt;mid)query(mid+1,r,nl,nr,id,v,rs); else query(l,mid,nl,mid,id,v,ls),query(mid+1,r,mid+1,nr,id,v,rs);}void link(int a,int b,int c,int d){ query(1,n,a,b,out,q1,1),query(1,n,c,d,in,q2,1); int t1=++node,t2=++node; addedge(t1,t2,1); for(auto x:q1)addedge(x,t1,0); for(auto x:q2)addedge(t2,x,0); q1.clear(),q2.clear();}void bfs(){ query(1,n,S,S,in,q1,1); S=q1.back(); deque&lt;int&gt; q; mst(dis,-1); dis[S]=0,q.pb(S); while(!q.empty()) { int u=q.front(); q.ppf(); if(v[u])continue; else v[u]=1; gow(u)if(dis[v]==-1||dis[u]+w&lt;dis[v]) dis[v]=dis[u]+w,(w?q.pb(v):q.pf(v)); }}void print(int l,int r,int cnt){ if(l==r){printf(&quot;%d\\n&quot;,dis[in[cnt]]);return;} print(l,mid,ls),print(mid+1,r,rs);}int work(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;S); build(1,n,1); while(m--) { int a,b,c,d;scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d); link(a,b,c,d),link(c,d,a,b); } bfs(),print(1,n,1); return 0;}","link":"/2020/05/01/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E8%A3%82-%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE-%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%89%E8%BF%9E/"},{"title":"COT1 &amp;&amp; COT2 ç®€è¦é¢˜è§£","text":"COT1COT - Count on a tree é¢˜æ„æ±‚æ ‘ä¸ŠæŸä¸ªè·¯å¾„ $(u,v)$ ä¸Šæ‰€æœ‰æ•°ä¸­çš„ç¬¬ $k$ å¤§ SOLç±»ä¼¼äºåºåˆ—ä¸Šçš„åšæ³•ï¼Œå¯¹äºæ¯ä¸ªç‚¹ $u$ ç»´æŠ¤å®ƒåˆ°æ ¹è·¯å¾„ä¸Šæ‰€æœ‰æ•°çš„æƒå€¼çº¿æ®µæ ‘ $tree[u]$ï¼Œè·¯å¾„ $(u,v)$ ä¸Šæ‰€æœ‰æ•°æ„æˆçš„æƒå€¼çº¿æ®µæ ‘å¯ä»¥çœ‹ä½œæ˜¯ $tree[u] + tree[v] - tree[lca] + val[lca]$$ï¼Œæ±‚ $k$ å¤§çš„æ–¹æ³•åŒåºåˆ—ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041vector&lt;int&gt; X;int n,m,L;int a[MAXN],fa[MAXN];int s[N],ls[N],rs[N],cnt,root[MAXN];void insert(int pre,int &amp;rt,int l,int r,int val){ if(!rt)rt=++cnt; s[rt]=s[pre]+1; if(l==r)return; if(val&lt;=mid)insert(ls[pre],ls[rt],l,mid,val),rs[rt]=rs[pre]; else insert(rs[pre],rs[rt],mid+1,r,val),ls[rt]=ls[pre];}int query(int pre,int rt1,int rt2,int l,int r,int k){ if(l==r)return l; int t=s[ls[rt1]]+s[ls[rt2]]-2*s[ls[pre]]+(a[L]&gt;=l&amp;&amp;a[L]&lt;=mid); if(t&gt;=k)return query(ls[pre],ls[rt1],ls[rt2],l,mid,k); else return query(rs[pre],rs[rt1],rs[rt2],mid+1,r,k-t);}void dfs(int u,int par=0){ fa[u]=par,insert(root[par],root[u],1,X.size(),a[u]); go(u)if(v!=par)dfs(v,u);}int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); fp(i,1,n)scanf(&quot;%d&quot;,&amp;a[i]),X.pb(a[i]); sort(all(X)),unq(X); fp(i,1,n)a[i]=lb(all(X),a[i])-X.begin()+1; fp(i,1,n-1) { int u,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v),addedge(v,u); } dfs(1,0),lca::init(n); while(m--) { int u,v,k;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;k),L=lca::query(u,v); printf(&quot;%d\\n&quot;,X[query(root[L],root[u],root[v],1,X.size(),k)-1]); } return 0;} COT2é¢˜æ„æ¯ä¸ªç‚¹æœ‰ä¸ªé¢œè‰² $a[u]$ï¼Œæ±‚æ ‘ä¸ŠæŸä¸ªè·¯å¾„ $(u,v)$ ä¸Šçš„é¢œè‰²ç§ç±»æ•° SOL1 åœ¨çº¿åšæ³• æ ‘åˆ†å— å¯æŒä¹…åŒ–å—çŠ¶æ•°ç»„å‰ç½®æŠ€èƒ½1: å¯æŒä¹…åŒ–å—çŠ¶æ•°ç»„å‰ç½®æŠ€èƒ½2: æ ‘åˆ†å—SOL2 ç¦»çº¿åšæ³• æ ‘ä¸Šè«é˜Ÿå‘","link":"/2020/03/31/COT1-COT2-%E7%AE%80%E8%A6%81%E9%A2%98%E8%A7%A3/"},{"title":"åˆ·é¢˜è®°å½•","text":"é—®å°±æ˜¯é¸½äº† 2020.3.25CF EDU 84 (7/7)A ç®€å•æ•°å­¦B æš´åŠ›C æ„é€ å…¨ç§»åŠ¨åˆ°ä¸€ä¸ªç‚¹åèµ°éæ•´ä¸ªæ£‹ç›˜å³å¯ï¼Œæ€»æ­¥æ•° $n-1+m-1+n*m$ D æš´åŠ› æ•°å­¦æ¯ä¸€ä¸ªç¯åˆ†åˆ«å¤„ç†ï¼Œè®°å®ƒçš„é•¿åº¦ä¸º $len$ æš´åŠ›å¯çŸ¥ï¼Œåªæœ‰ $p^k$ çš„ $k$ æ˜¯ $len$ å› å­æ—¶æ‰ä¼šåˆ†è£‚ æšä¸¾å› å­æš´åŠ› check å³å¯ å¤æ‚åº¦ $O(n*sqrt(n))$ E æ•°å­¦æšä¸¾ Block çš„é•¿åº¦ç®—ä¸€ç®— F DPæ„Ÿè°¢å½­çˆ¹æ•™æˆ‘dp ä½ä¸ä½ä¹‹é—´ç‹¬ç«‹ï¼Œæ€»æ–¹æ¡ˆæ•°å°±æ˜¯æ¯ä¸€ä½çš„ç­”æ¡ˆä¹˜èµ·æ¥ è€ƒè™‘ç¬¬ $i$ ä¸ªé™åˆ¶ï¼Œè‹¥ $x_{i}$ è¿™ä¸€ä½æ˜¯ $1$ï¼Œé‚£ä¹ˆ $[l_{i},r_{i}]$ åªèƒ½æ”¾ $1$ æ˜¯ $0$ é‚£ä¹ˆè¯´æ˜ $[l_{i},r_{i}]$ ä¸Šè‡³å°‘æœ‰ä¸€ä¸ª $0$ï¼Œæš‚æ—¶å«ä»– $0$ é™åˆ¶ è®° $f[i][0/1]$ è¡¨ç¤ºæ‰€æœ‰ $r_{i}&lt;=i$ çš„é™åˆ¶éƒ½å·²ç»æ»¡è¶³ ä¸” ç¬¬ $i$ ä½æ˜¯ $0/1$ çš„æ–¹æ¡ˆæ•° è‹¥ç¬¬ $i$ ä½æœ‰å¼ºåˆ¶æ˜¯ $1$ çš„é™åˆ¶ï¼š f[i][0]=0å¦åˆ™ç¬¬ $i$ æ˜¯ $0$ æ€»æ˜¯åˆæ³•çš„ ï¼š f[i][0]=f[i-1][0]+f[i-1][1]è‹¥ç¬¬ $i$ ä½æ”¾ $1$ï¼Œé‚£ä¹ˆå¿…å®šæœ‰ä¸€ä¸ª $j(j&lt;=i)$ æ˜¯ $0$ æ¥æ»¡è¶³é‚£äº› $r_{i}$ åœ¨ $[j,i]$ èŒƒå›´å†…çš„ $0$ é™åˆ¶ è€ƒè™‘æšä¸¾æ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„ $j$ è¿›è¡Œè½¬ç§»ï¼Œå³ç¬¬ $j$ ä½æ˜¯ $0$ï¼Œ$[j+1,i]$ ä½éƒ½æ˜¯ $1$ ä½†åç¼€ $1$ ä¹Ÿä¸èƒ½æ— é™åˆ¶çš„æ”¾ï¼Œå› ä¸ºå¯èƒ½ä¼šå°† $0$ é™åˆ¶çš„åŒºé—´å æ»¡ è®° $s0_{i}$ ä¸ºæ‰€æœ‰ $r_{i}&lt;=i$ çš„0é™åˆ¶çš„ $l_{i}$ çš„æœ€å¤§å€¼ï¼Œå¯ä»¥å‘ç°åç¼€ $1$ æœ€å·¦å¯ä»¥æ”¾åˆ° $s0_{i}$ å› æ­¤: f[i][1]=\\sum_{j=s0_{i}}^{i-1} f[j][0]ç”¨å‰ç¼€å’Œå¯ä»¥ä¼˜åŒ–åˆ°çº¿æ€§ O(n) G ACè‡ªåŠ¨æœº çŠ¶å‹ DPä¼˜åŒ–é¦–å…ˆè€ƒè™‘æš´åŠ›dpï¼Œ$f[i][j][s]$ è¡¨ç¤ºæ„é€ äº†é•¿åº¦ä¸º $i$ çš„å­—ç¬¦ä¸²ï¼ŒåŒ¹é…åˆ°äº† ACè‡ªåŠ¨æœºä¸Šçš„ $j$ èŠ‚ç‚¹ï¼Œ$s$ æ˜¯äºŒè¿›åˆ¶ä¸²ï¼Œè¡¨ç¤ºé—®å·ç”¨è¿‡äº†é‚£äº›å­—ç¬¦ ç¬¬ä¸€ç»´å¯ä»¥æ»šæ‰ï¼Œä½†å¤æ‚åº¦ä¸é™ æ³¨æ„åˆ°é—®å·æœ€å¤š $14$ ä¸ªï¼Œå³å¤§å¤šæ•°è½¬ç§»éƒ½æ˜¯å›ºå®šçš„ï¼Œè´¡çŒ®ä¹Ÿæ˜¯å›ºå®šçš„ï¼Œå¯ä»¥æå‰ç®—å‡ºéé—®å·æ®µçš„è½¬ç§»æ–¹å‘å’Œè´¡çŒ®ï¼Œä»è€ŒåŠ é€Ÿdp æ‰€ä»¥æ€»å¤æ‚åº¦æ˜¯ $O(1410002^{14}+1000*4e5)$ 2020.3.26CF Global Round 4 (8/9)A æš´åŠ›B å‰ç¼€(åç¼€)å’Œ dpC æ•°å­¦ç­”æ¡ˆæ˜¯ $2^{n+m}$ï¼Œå¿«é€Ÿå¹‚ D æ„é€ ç»™å®šç‚¹æ•° $n$ï¼Œæ„é€ ä¸€ä¸ªæ€»è¾¹æ•°æ˜¯è´¨æ•°ï¼Œä¸”æ¯ä¸ªç‚¹çš„åº¦æ•°éƒ½æ˜¯è´¨æ•°çš„å›¾ æˆ‘çš„åšæ³•æ˜¯è¿æˆä¸€ä¸ªç¯ï¼Œæ‰¾ä¸€äº›åº¦æ•°ä¸º 2 çš„è¿äº’è¿å‡‘åˆ°æœ€è¿‘çš„è´¨æ•° E æš´åŠ› æ€§è´¨ç»™ä¸€ä¸ªé•¿åº¦ä¸º $n$ åªåŒ…å« abc ä¸‰ç§å­—ç¬¦çš„å­—ç¬¦ä¸²ï¼Œä¸”ä¿è¯ç›¸é‚»å­—ç¬¦ä¸ç›¸åŒï¼Œè¯·ä½ æ‰¾ä¸€ä¸ªé•¿åº¦è‡³å°‘ä¸º $\\lfloor \\frac{n}{2} \\rfloor$ çš„å›æ–‡å­åºåˆ— è€ƒè™‘å­—ç¬¦ä¸²çš„å¤´ä¸¤ä¸ªå­—ç¬¦å’Œåä¸¤ä¸ªå­—ç¬¦ï¼Œä¸€å®šå­˜åœ¨ä¸¤ä¸ªå­—ç¬¦ç›¸ç­‰ï¼ŒæŠŠè¿™å¯¹æ‰¾å‡ºæ¥åŠ åˆ°å›æ–‡å­åºåˆ—é‡Œ å³æ¯ $4$ çš„é•¿åº¦è‡³å°‘è´¡çŒ® $2$ é•¿åº¦çš„å›æ–‡ï¼Œæ‰€ä»¥ç­”æ¡ˆæ°¸è¿œå­˜åœ¨ F1 åŒºé—´ dpF2 åŒºé—´ dp plusG å‡¸å£³ dfsåº åˆ†å—æŠ„äº†é¢˜è§£ ç»´æŠ¤ $ans=(A_{i}+x)*B_{i}$ çš„åŒºé—´æœ€å¤§å€¼ï¼Œæ”¯æŒ $x$ çš„åŒºé—´åŠ æ“ä½œ åˆ†å—ï¼Œç»´æŠ¤å—ä¸ŠåŠ æ³•æ ‡è®° å—å†…ç»´æŠ¤å‡¸å£³ CF1326F1 Wise Men (Easy Version)meet in mid çŠ¶å‹ dp å†²ä¸è¿‡ã€‚ã€‚æŠ„äº†é¢˜è§£ 2020.3.27CF 629 Div.3E æ ‘lcaé¦–å…ˆæ‹¿å„¿å­ä¸€å®šæ²¡æœ‰æ‹¿çˆ¶äº²æ›´ä¼˜ï¼Œå› æ­¤æ ‡è®°æ‰€æœ‰è¯¢é—®èŠ‚ç‚¹çš„çˆ¶äº²ï¼Œåœ¨åˆ¤æ–­ä¸€ä¸‹æ˜¯å¦åœ¨ä¸€æ¡é“¾ä¸Š æˆ‘åˆ¤é“¾çš„æ–¹æ³•æ˜¯æ‰€æœ‰èŠ‚ç‚¹æŒ‰æ·±åº¦æ’åºï¼Œåˆ¤ç›¸é‚»ä¸¤èŠ‚ç‚¹çš„lcaæ˜¯å¦åœ¨ä»–ä»¬ä¿©ä¹‹é—´ F æš´åŠ› å‰ç¼€å’Œæœ€åç›¸ç­‰çš„ $k$ ä¸ªæ•°ä¸€å®šæ˜¯æŸä¸ª $a_{i}$ æšä¸¾ç®—ä¸€ç®— BZOJ 1260 [CQOI2007]æ¶‚è‰²paint åŒºé—´dpHDU 2476 åŒºé—´dpä¸Šé¢é‚£é¢˜åŠ å¼ºç‰ˆ CF 522 Div.2 (5/7)A è¯»é¢˜ æš´åŠ›B æš´åŠ›C DP è®°å½•æ–¹æ¡ˆD å‡ ä½•A B ä¸¤ç‚¹å¯å”¯ä¸€ç¡®å®šä¸€ä¸ªçŸ©å½¢ï¼Œæ±‚å‡ºçŸ©å½¢ä¸ç›´çº¿çš„äº¤ç‚¹åæš´åŠ›ç®—ä¸€ç®—ï¼Œç­”æ¡ˆå– min E DP æ•°å­¦åªæœ‰ä¸¤ç§æ•°çš„æƒ…å†µç‰¹åˆ¤æ‰ å¦åˆ™ç­”æ¡ˆé€‰çš„ä¸€å®šæ˜¯ä¸€äº›é‡é‡ç›¸ç­‰çš„æ•° $dp[i][j]$ é€‰ $i$ ä¸ªæ•°å’Œä¸º $j$ çš„æ–¹æ¡ˆæ•°ï¼Œdpæä¸€æ è€ƒè™‘å„ç§æƒ…å†µä¸‹èƒ½å”¯ä¸€ç¡®å®šï¼Œè®° $cnt[i]$ ä¸ºé‡é‡ $i$ å‡ºç°çš„æ¬¡æ•° å½“ (j % i == 0) &amp;&amp; dp[i][j] == C(cnt[j/i],i) çš„æ—¶å€™å¯ä»¥å”¯ä¸€ç¡®å®š ç¬¦åˆæ¡ä»¶çš„å–ä¸ª max å³æ˜¯ç­”æ¡ˆ 2020.3.28ç‰›å®¢ NC204019 åºåˆ—è‡ªåŠ¨æœºCF1183H åºåˆ—è‡ªåŠ¨æœºç‰›å®¢ NC204272 dsu on treeLuogu P2742 å‡ ä½• å‡¸åŒ…è¿™é¢˜æ•°æ®å¥½å¼±ã€‚ã€‚ã€‚æˆ‘ç”¨æ­£æ–¹å½¢å¡äº†è‡ªå·±çš„ACä»£ç  zoj 3537 å‡ ä½• åŒºé—´dpæœ€ä¼˜ä¸‰è§’å‰–åˆ† å°†å‡¸å¤šè¾¹å½¢é¡ºæ—¶é’ˆç¼–å·ï¼Œ$f[l][r]$ ä»£è¡¨å°† $lâ€¦r$ ç»„æˆçš„å¤šè¾¹å½¢å…¨å‰²æˆä¸‰è§’å½¢çš„æœ€å°ä»£ä»· åœ¨æœ€ä¼˜å‰²æ³•ä¸­ï¼Œè¾¹ $l-r$ ä¸€å®šå±äºæŸä¸ªä¸‰è§’å½¢ä¹‹ä¸­ï¼Œæšä¸¾ä¸‰è§’å½¢çš„ç¬¬ä¸‰ä¸ªé¡¶ç‚¹ $k (l+1&lt;=k&lt;=r+1)$ï¼Œè½¬ç§»æ–¹ç¨‹ä¸º $f[l][r] = min\\{f[l][k]+f[k][r]+w(l,k)+w(k,r)\\}$ LightOJ 1422 åŒºé—´ dpæœ‰ç‚¹åƒåˆ·å­—ç¬¦ä¸²é‚£ä¸ªé¢˜ï¼Œä¹ä¸€çœ‹å’ŒåŒºé—´ dp æ²¡å•¥å…³ç³» $f[l][r]$ è¡¨ç¤ºä»¥ $lâ€¦r$ é¡ºåºæ’åˆ—æ—¶çš„ç­”æ¡ˆ è€ƒè™‘ç¬¬ $r$ ä»¶æ˜¯å¦å¯ä»¥å’ŒæŸä¸€ä¸ªå…±äº«: f[l][r] = min\\{f[l][i]+f[i+1][r-1]+(a[i]!=a[k])\\}CF 149D åŒºé—´dpæ¶å¿ƒ $f[l][r][cl(0â€¦2)][cr(0â€¦2)]$ è¡¨ç¤ºä¸ºåŒºé—´ $lâ€¦r$ æŸ“è‰²ï¼Œæ‹¬å· $l$ çš„é¢œè‰²ä¸º $c1$ï¼Œæ‹¬å· $r$ çš„é¢œè‰²ä¸º $c2$ çš„æ–¹æ¡ˆæ•° è‹¥ $l$ ä¸ $r$ åŒ¹é…ï¼Œåˆ™è¦å…ˆåˆ¤æ–­é¢œè‰²æ˜¯å¦åˆæ³•ï¼Œå†æšä¸¾ä¸ä»–ç›¸é‚»çš„æ‹¬å·çš„é¢œè‰²è¿›è¡Œè½¬ç§» f[l][r][cl][cr] = \\sum_{}f[l+1][r-1][cl'][cr']å¦åˆ™ï¼Œåˆ†åˆ«æšä¸¾ä¸ä»–ä»¬åŒ¹é…çš„æ‹¬å·çš„é¢œè‰²ï¼Œè¿™æ · $lâ€¦r$ å°±è¢«åˆ†æˆäº†ä¸‰æ®µï¼Œåˆ†åˆ« dp è®¡æ•°ä¹˜åœ¨ä¸€èµ·å°±è¡Œ 2020.3.29ç‰›å®¢ NC13221 æ•°ä½dp æ•°è®ºåˆ†å—ä¸ºä»€ä¹ˆæˆ‘ä¼šå†™æ•°è®ºçš„é¢˜ HDU 4283 åŒºé—´dpéš¾ï¼ŒæŠ„äº†é¢˜è§£ï¼Œæšä¸¾ $f[l][r]$ æšä¸¾ $l$ æ˜¯ç¬¬ $k$ ä¸ªè¿›å…¥æˆ¿é—´ç„¶åè½¬ç§»ï¼š f[l][r] = min\\{f[l+1][l+k-1]+f[l+k][r]+(k-1)*a[i]+sum(l+k,r)*k\\}ZOJ 3469 åŒºé—´dpåŒ Luogu P1220 å…³è·¯ç¯ è´¹ç”¨è®¡ç®—ä¸Šçš„æŠ€å·§ poj 1651 åŒºé—´dpå’ŒæŸåœºè®­ç»ƒèµ›æ€ç‹¼é‚£ä¸ªçŒäººçš„é¢˜ä¸€æ ·ã€‚ã€‚ã€‚ NOIP2000 ä¹˜ç§¯æœ€å¤§ dpç»ƒç»ƒpythonã€‚ã€‚ã€‚æ‰ä¸æ˜¯åœ¨æ°´é¢˜ BZOJ 1090 åŒºé—´dp$f[l][r]$ è¡¨ç¤º $s[lâ€¦r]$ èƒ½ç¼©æˆçš„æœ€çŸ­å­—ç¬¦ä¸² æ‹¼ä¸€æ‹¼ï¼š f[l][r] = min\\{f[l][i]+f[i+1][r]\\}ç¼©ä¸€ç¼©ï¼š $f[l][r] = min\\{f[l][l+len-1]+cost(l,r,len)\\}$ BZOJ 1068 åŒºé—´dpæ³¨æ„ M-R ç»„æˆçš„åŒºé—´ä¸èƒ½ç›¸äº¤ï¼Œå…¶ä»–çš„å’Œä¸Šé¢å·®ä¸å¤š BZOJ 1055 åŒºé—´dp$f[l][r][k]$ è¡¨ç¤ºå­—ç¬¦ä¸² $s[lâ€¦r]$ æ˜¯å¦èƒ½åˆæˆå•ä¸ªå­—ç¬¦ $k$ è½¬ç§»æšä¸¾æ–­ç‚¹å³å¯ f[l][r][k]|=(f[l][i][c1]\\&\\&f[i+1][r][c2])åŒºé—´dpå…ˆåˆ·åˆ°è¿™é‡Œã€‚ã€‚åˆ·äº† hzwer å’Œ kuangbin çš„é¢˜å• 2020.3.30BZOJ 1086 ç‹å®¤è”é‚¦ä¸€ç§æ ‘åˆ†å¿« å­¦ä¹  å†è¡¥å‡ é“ï¼Œfrom ã€åŠ¨æ€è§„åˆ’3ã€‘åŒºé—´ä¸ç¯å½¢åŠ¨æ€è§„åˆ’ CF607B åŒºé—´dpluogu P3205 åŒºé—´dpluogu P3146 åŒºé—´dpluogu P3146 åŒºé—´dpspoj COT1 ä¸»å¸­æ ‘spoj COT2 æ ‘åˆ†å¿« å¯æŒä¹…åŒ–å—çŠ¶æ•°ç»„2020.3.31BZOJ 2589åŒ spoj COT2ï¼Œå¼ºåˆ¶åœ¨çº¿ å¡äº†å¡å¸¸ ã€‚ã€‚ä¸‹åˆé¢“åºŸã€‚ã€‚ CF 630 div2$Nanako$ åš $tester$ çš„ åœºï¼Œå…¹ç£ä¸€ä¸‹ ä½ å¦ˆçš„è¿˜è¯´ä¸æ˜¯ math round A æ•°å­¦åˆ¤æ‰ x1=x=x2 &amp;&amp; (a||b) å’Œ y1=y=y2 &amp;&amp; (c||d) çš„æƒ…å†µï¼Œç„¶ååˆ¤ä¸€ä¸‹æœ€ç»ˆä½ç½®ä¼šä¸ä¼šè¶Šç•Œ B æ•°å­¦$\\sqrt{1000}$ ä»¥å†…çš„è´¨æ•°æœ€å¤š $11$ ä¸ªï¼Œæš´åŠ›åˆ†ä¸€åˆ† C æš´åŠ› è´ªå¿ƒ$s[1]$ ä¸€å®šå’Œ $s[k]$ ç›¸åŒï¼Œæš´åŠ›ç»Ÿè®¡æ‰€æœ‰å¾ªç¯è¯¥ä½ç½®ä¸Šçš„å­—æ¯ä¸ªæ•°ï¼Œä¿ç•™å‡ºç°ä½ç½®æœ€å¤šçš„å­—æ¯ã€‚ D æ„é€ è®¾ $k$ çš„æœ€é«˜ä½ $1$ åœ¨ç¬¬ $mx$ ä½(ä» $0$ å¼€å§‹ç¼–å·)ï¼Œæ„é€ ç­”æ¡ˆçŸ©é˜µ $2*3$ï¼š ä»¤ $t=1&lt;&lt;(mx+1)$ $t+k,k,0$ $t,t+k,k$ E æ•°å­¦ çŸ©é˜µksmè®¾å¥‡æ•°ä¸º $1$ï¼Œå¶æ•°ä¸º $0$ï¼Œæ¨ä¸€æ¨å¯ä»¥å‘ç°åˆæ³•çš„æ–¹æ¡ˆä¸€å®šæ»¡è¶³ (æœ‰å¶æ•°ä¸ª0 || æœ‰å¶æ•°ä¸ª1)ï¼Œå› ä¸ºå¦‚æœæœ‰å¶æ•°ä¸ª 0/1 ä¸€å®šå¯ä»¥é€šè¿‡ä¸æ–­æ”¹å˜ä½ç½®æœ€åç¢°åˆ°ä¸€èµ·æ¶ˆæ‰ è®¾ $f[i][0/1][0/1]$ è¡¨ç¤º $i$ ä¸ªæ ¼å­ï¼Œ$0$ æœ‰å¥‡æ•°/å¶æ•°ä¸ªï¼Œ$1$ æœ‰å¥‡æ•°/å¶æ•°ä¸ªï¼Œæšä¸¾æœ€åä¸€ä¸ªæ ¼å­æ”¾ $0/1$ è½¬ç§» æ˜¾ç„¶æ˜¯ä¸ªçº¿æ€§é€’æ¨å¼ï¼ŒçŸ©é˜µksmæä¸€æï¼ŒACæ²¡çƒ¦æ¼ F æ ‘ä¸Šdpå…ˆè½¬åŒ–ä¸€ä¸‹é¢˜æ„ï¼Œå¦‚æœæŠŠä¸é€‰ä¹Ÿçœ‹æˆæŸ“ä¸€ç§é¢œè‰²($0$)çš„è¯ï¼Œè¿™é¢˜ç­‰ä»·äºæ±‚ï¼š ç»™æ¯ä¸ªç‚¹æŸ“è‰² $(0/1/2)$-(åœ¨ç‹¬ç«‹é›†ä¸­/ä¸åœ¨ç‹¬ç«‹é›†ä¸­/æ²¡é€‰) åé€‰ä¸€äº›è¾¹ï¼Œéœ€æ»¡è¶³ä¸å­˜åœ¨å­¤ç«‹çš„ $1/2$ é¢œè‰²çš„ç‚¹ï¼Œ$1$ é¢œè‰²ä¹‹é—´çš„ç‚¹ä¸èƒ½è¿è¾¹ï¼Œæ±‚æ–¹æ¡ˆæ•°ã€‚ å®šä¹‰çŠ¶æ€ï¼š $f[u][0]$ u ç‚¹ä¸ºé¢œè‰² $1$ ä¸”ä¸å­˜åœ¨å­¤ç«‹ç‚¹çš„æ–¹æ¡ˆæ•° $f[u][1]$ u ç‚¹ä¸ºé¢œè‰² $2$ ä¸”ä¸å­˜åœ¨å­¤ç«‹ç‚¹çš„æ–¹æ¡ˆæ•° $f[u][2]$ u ç‚¹ä¸ºé¢œè‰² $1$ ä¸” $u$ æ˜¯å­¤ç«‹ç‚¹çš„æ–¹æ¡ˆæ•° $f[u][3]$ u ç‚¹ä¸ºé¢œè‰² $2$ ä¸” $u$ æ˜¯å­¤ç«‹ç‚¹çš„æ–¹æ¡ˆä¹¦æ•° $f[u][4]$ u ç‚¹ä¸ºé¢œè‰² $0$ çš„æ–¹æ¡ˆæ•° ä¸¤æ£µæ ‘é€šè¿‡ $(u,v)$ è¾¹æ¥è¿›è¡Œåˆå¹¶ç­”æ¡ˆï¼š dp[0] = f[u][0]*(f[v][0]+f[v][1]*2+f[v][3]+f[v][4]) + f[u][2]*(f[v][1]+f[v][3])$dp[1]=f[u][1](f[v][0]2+f[v][1]2+f[v][2]+f[v][3]+f[v][4])+f[u][3](f[v][0]+f[v][1]+f[v][2]+f[v][3])$ dp[2]=f[u][2]*(f[v][0]+f[v][1]+f[v][4])dp[3]=f[u][3]*(f[v][0]+f[v][1]+f[v][4])dp[4]=f[u][4]*(f[v][0]+f[v][1]+f[v][4])2020.4.1ä¸Šåˆã€‚ã€‚æ“ä½œç³»ç»Ÿè¿˜æ˜¯å¬å¬å¥½ SPOJ COT2 æ ‘ä¸Šè«é˜Ÿå­¦äº†ä¸‹æ ‘ä¸Šè«é˜Ÿçš„åšæ³•ï¼Œä¼šä¸“é—¨å¼€ä¸€ç¯‡å†™ WC2013 ç³–æœå…¬å›­ å¸¦ä¿®æ ‘ä¸Šè«é˜ŸCF æ„šäººèŠ‚roundä¸åŠ¡æ­£ä¸šè‰ A NoB åˆ†è§£è´¨å› æ•°C äºŒè¿›åˆ¶æ¢ä½D åˆ¤å¥‡å¶E ç”»å›¾æŸ“è‰² å›¾åƒå¤„ç†é»‘ç™½F åˆ¤å­—ç¬¦ä¸²èƒ½å¦è¢«åŒ–å­¦å…ƒç´ ç»„æˆ dp2020.4.2luogu P4198 æ¥¼æˆ¿é‡å»º åˆ†å—bzoj 3295 åŠ¨æ€é€†åºå¯¹ åˆ†å—/cdqä¹‹å‰ç”¨æ ‘çŠ¶æ•°ç»„å¥—åŠ¨æ€å¼€ç‚¹Aè¿‡äº†ï¼Œè¡¥ä¸‹å…¶ä»–å‡ ç§åšæ³• åˆ†å—ï¼šæ¯ä¸ªå—ç»´æŠ¤ä¸ªvectorï¼Œåˆ é™¤æŸä¸ªç‚¹æ—¶åŒä¸€å—å†…é€†åºå¯¹çš„æš´åŠ›ç»Ÿè®¡ï¼Œå…¶ä»–å—äºŒåˆ† cdq:å‘ç€ bzoj 3744 åŒºé—´é€†åºå¯¹ å¼ºåˆ¶åœ¨çº¿ åˆ†å—ç±»ä¼¼è’²å…¬è‹±ï¼Œå—ä¸å—ä¹‹é—´çš„ç­”æ¡ˆ $ans[L][R]$ å…ˆé¢„å¤„ç†å‡ºæ¥ï¼Œè¯¢é—®æ—¶åœ¨è€ƒè™‘ä¸å®Œæ•´å—çš„è´¡çŒ® bzoj 4028 [HEOI2015]å…¬çº¦æ•°æ•°åˆ— åˆ†å— æš´åŠ›å¾ˆå¦™ã€‚ã€‚ã€‚æŠ„äº†é¢˜è§£ é¦–å…ˆå‰ç¼€ $gcd$ è¿™ä¸ªä¸œè¥¿æœ‰ä¸ªå¾ˆå¥½çš„æ€§è´¨ï¼Œå³å®ƒæœ€å¤šæœ‰ $\\log_{2}{x}$ ç§ä¸åŒçš„å–å€¼(CFæŸæ ‘ä¸Š $gcd$ ä¹Ÿç”¨äº†è¿™ä¸ªæ€§è´¨) è€ƒè™‘åˆ†å—ï¼Œå½“æŸä¸ªå—å†…çš„å‰ç¼€ $gcd$ ç›¸ç­‰çš„æ—¶å€™ï¼Œæˆ‘ä»¬åªéœ€è¦æŸ¥å—å†…æ˜¯å¦å­˜åœ¨å‰ç¼€ $xor$ å’Œç­‰äº $x/g$ çš„ä½ç½® $i$ å‡è®¾å½“å‰æ˜¯ç¬¬ $k$ å—ï¼Œé‚£ä¹ˆå—å†…æŸä¸ªä½ç½® $i$ çš„å‰ç¼€ $xor$ å’Œåˆå¯ä»¥åˆ†ä¸º (å‰ $k-1$ å—çš„ $xor$ å’Œ)^(ç¬¬ $k$ å—é¦–éƒ¨åˆ° $i$ çš„ $xor$ å’Œ) ä¸¤éƒ¨åˆ†ï¼Œè€Œå½“ $k$ ç¡®å®šæ—¶å‰è€…æ˜¯ä¸ªå®šå€¼ï¼Œå› æ­¤åªéœ€ç»´æŠ¤æ¯ä¸ªä½ç½®çš„å—å†…å‰ç¼€ $xor$ å’Œå³å¯ å› æ­¤å¯¹äºæ¯ä¸ªå—ï¼Œæˆ‘ä»¬ç»´æŠ¤ä»¥ä¸‹å‡ ä¸ªå€¼ï¼š $lgcd$ï¼šå—å·¦ç«¯ç‚¹çš„å‰ç¼€ $gcd$ å€¼ $rgcd$ï¼šå—å³ç«¯ç‚¹çš„å‰ç¼€ $gcd$ å€¼ $sgcd$ï¼šå—å†…æ‰€æœ‰æ•°çš„ $gcd$ $sxor$ï¼šå—å†…æ‰€æœ‰æ•°çš„ $xor$ å’Œ $set(S)$ï¼šå—å†…æ‰€æœ‰ä½ç½®çš„å‰ç¼€ $xor$ å’Œç»„æˆçš„ $set$ å¯¹äºæŸ¥è¯¢æ“ä½œï¼Œæˆ‘ä»¬ä»å¤´æšä¸¾æ¯ä¸ªå—ï¼Œå½“å—çš„ $lgcd$ == $rgcd$ æ—¶ï¼Œæˆ‘ä»¬åªéœ€åœ¨ $set$ é‡Œ $find$ ä¸€ä¸‹æ˜¯å¦å­˜åœ¨ç¬¦åˆæ¡ä»¶çš„ä½ç½® $i$ï¼›å½“å—çš„ $lgcd$ != $rgcd$ æ—¶æˆ‘ä»¬å¤§åŠ›æšä¸¾å—å†…çš„æ¯ä¸€ä¸ªä½ç½®æ¥æŸ¥æ‰¾ç­”æ¡ˆã€‚ ç”±äºå‰ç¼€ $gcd$ æœ€å¤šæœ‰ $\\log_{2}{x}$ ç§å–å€¼ï¼Œæ‰€ä»¥ $lgcd$ != $rgcd$ çš„å—æœ€å¤šæœ‰ $\\log_{2}{x} + 1$ ä¸ªï¼Œå¤æ‚åº¦æœ‰ä¿è¯ å¯¹äºå•ç‚¹ä¿®æ”¹æ“ä½œï¼Œæˆ‘ä»¬åªéœ€æš´åŠ›é‡å»º $x$ æ‰€åœ¨çš„å—ï¼Œå¹¶æ›´æ–°åé¢æ‰€æœ‰å—çš„ $lgcd$ ä¸ $rgcd$ å³å¯ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const int SZ = 500;int n,m;int id[MAXN];LL a[MAXN];struct block{ int l,r; LL lgcd,rgcd,sgcd,sxor; vector&lt;LL&gt; v; inline bool find(LL x) { vector&lt;LL&gt;::iterator it = lb(all(v),x); return it!=v.end()&amp;&amp;*it==x; }}b[MAXN/SZ+5];void build(int k){ b[k].v.clear(); LL pre=0,g=a[b[k].l]; fp(i,b[k].l,b[k].r)pre^=a[i],b[k].v.pb(pre),g=__gcd(g,a[i]); sort(all(b[k].v)); b[k].sxor=pre; b[k].lgcd=k?__gcd(b[k-1].rgcd,a[b[k].l]):a[b[k].l]; b[k].sgcd=g; b[k].rgcd=__gcd(b[k].lgcd,b[k].sgcd);}int work(){ scanf(&quot;%d&quot;,&amp;n); fp(i,1,n)scanf(&quot;%lld&quot;,&amp;a[i]); fp(i,1,n)id[i]=(i-1)/SZ+1; fp(i,1,n)if(!b[id[i]].l)b[id[i]].l=i; fd(i,n,1)if(!b[id[i]].r)b[id[i]].r=i; fp(k,1,id[n])build(k); scanf(&quot;%d&quot;,&amp;m); while(m--) { char s[10]; scanf(&quot;%s&quot;,s+1); LL x,y; if(s[1]=='M') { scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y),x++,a[x]=y,build(id[x]); LL g=b[id[x]].rgcd; fp(k,id[x]+1,id[n]) { b[k].lgcd=__gcd(g,a[b[k].l]); b[k].rgcd=__gcd(g,b[k].sgcd); g=__gcd(g,b[k].sgcd); } } else { scanf(&quot;%lld&quot;,&amp;x); LL sxor=0,sgcd=a[1];bool flag=0; fp(k,1,id[n]) { if(b[k].lgcd!=b[k].rgcd||(x%b[k].lgcd==0&amp;&amp;b[k].find((x/b[k].lgcd)^sxor))) { LL s=0,g=a[b[k].l]; fp(i,b[k].l,b[k].r) { s^=a[i],g=__gcd(g,a[i]); if((s^sxor)*__gcd(g,sgcd)==x) {printf(&quot;%d\\n&quot;,i-1);flag=1;break;} } } sxor^=b[k].sxor,sgcd=__gcd(sgcd,b[k].sgcd); if(flag)break; } if(!flag)puts(&quot;no&quot;); } } return 0;} 2020.4.3bzoj 1926 äºŒåˆ† è«é˜ŸCF 631 div.2I_LOVE_DREAMOON ABC è´ªå¿ƒD æ•°å­¦ dp2020.4.4GCJ èµ„æ ¼èµ›A æ¨¡æ‹ŸB æ¯æ¬¡é€‰ä¸€æ®µåŒºé—´å‡å»æœ€å°å€¼C äºŒåˆ†å›¾D äº¤äº’$B = 10$ æœ‰æ‰‹å°±è¡Œ $B = 20$ è€ƒè™‘å››ç§æ“ä½œå…¶å®å¯¹ $i$ å’Œ $B-i+1$ çš„å…³ç³»(ç›¸ç­‰/ä¸ç›¸ç­‰)æ²¡æœ‰å½±å“ï¼Œ$20$ æ¬¡è¯¢é—®æ¯ä¸€å¯¹ $(i,B-i+1)$ï¼Œæœ€ååœ¨ä¸€ç»„å†…é—®å‡ºæ•°ç»„çš„ä¸€åŠï¼Œå¦ä¸€åŠæ ¹æ®ç›¸ç­‰/ä¸ç­‰å…³ç³»æ¨å¾— $B = 100$ å…ˆæ‰¾ E åªä¼šæš´åŠ›bzoj 4129 æ ‘ä¸Šå¾…ä¿®mex æ ‘ä¸Šå¾…ä¿®è«é˜Ÿ åˆ†å—æ‰“æ‰“æ¿å­ spoj qtree1 æ ‘å‰–spoj qtree2 å€å¢å€å¢å¯ä»¥å¹²çš„äº‹è¿˜æŒºå¤šçš„ã€‚ã€‚ spoj qtree3 æ ‘å‰– setæ ‘å‰–çš„åŸç†å°±æ˜¯æŠŠæ ‘å‰–æˆè‹¥å¹²é“¾ï¼ŒåŒä¸€é“¾å†…çš„èŠ‚ç‚¹æ ‡å·è¿ç»­ åŒç† $1$ ~ $u$ çš„è·¯å¾„ä¹Ÿå¯ä»¥æ‹†æˆè‹¥å¹²é‡é“¾(ä¸ä¸€å®šå®Œæ•´)ï¼Œç”¨ $set$ ç»´æŠ¤æ¯ä¸ªé“¾å†…é»‘ç‚¹ï¼ŒæŒ‰æ·±åº¦æ’åº è·³é‡é“¾è¯¢é—®çš„æ—¶å€™æ³¨æ„åªæœ‰æ·±åº¦ &lt;=d[x] çš„ç‚¹æ‰å¯ä»¥æ›´æ–°ç­”æ¡ˆï¼Œä¸ç„¶æœ‰å¯èƒ½ä¸åœ¨è·¯å¾„ä¸Š 2020.4.5é¢“åºŸ++ luogu P4332 LCTbzoj 2959 LCT å¹¶æŸ¥é›†å¦‚æœåŠ è¾¹ä¿è¯åŸå›¾ä¸€ç›´æ˜¯ä¸€æ£µæ ‘ï¼Œé‚£ä¹ˆ $a$ -&gt; $b$ çš„è·¯å¾„æ˜¾ç„¶æ˜¯å”¯ä¸€çš„ å¦‚æœåŠ è¾¹å‡ºç°äº†ç¯ï¼Œè¿™ä¸ªç¯å†…çš„æ‰€æœ‰ $a_{i}$ æˆ‘ä»¬éƒ½å¯ä»¥æ‹¿åˆ°ï¼Œå¹¶ä¸”å¯åœ¨ä»»æ„ä¸€ç‚¹è¿›å…¥/å‡ºå»ï¼Œç›¸å½“äºç¯ç¼©æˆäº†ä¸€ä¸ªç‚¹ è€ƒè™‘ä½¿ç”¨ $lct$ ç»´æŠ¤è¿™ä¸ªè¿‡ç¨‹ï¼ŒæŠŠ $a$ -&gt; $b$ çš„è·¯å¾„æ‹¿å‡ºæ¥åæš´åŠ›æŠŠä»–ä»¬çš„ç¼–å·æ˜ å°„æˆä¸€ä¸ªæ–°çš„ç‚¹ï¼Œè¿æ¥åˆ°è·¯å¾„ä¸Šçš„è™šè¾¹å¯ä»¥ä¸ç”¨åŠ¨ï¼Œè¿™ä¸€æ­¥å¯ä»¥ç”¨å¹¶æŸ¥é›†æ¥å®ç° æ³¨æ„ç¼©ç‚¹ä»¥åæ¯ä¸ªç‚¹çœŸå®çš„ $fa[x]$ éƒ½è¦åœ¨å¹¶æŸ¥é›†é‡Œ $find$ ä¸€ä¸‹ 2020.4.6é¢“åºŸ++++ å°‘åšæ°´é¢˜.. bzoj 4998 LCT å¹¶æŸ¥é›†åŒ bzoj 2959ï¼Œå¹¶æŸ¥é›†ç»´æŠ¤ä¸‹sizå³å¯ CF 503 div.2AB æ¨¡æ‹ŸC æš´åŠ› è´ªå¿ƒD äº¤äº’ äºŒåˆ†2020.4.7luogu P4172 LCT æœ€å°ç”Ÿæˆæ ‘luogu P4180 LCT ä¸¥æ ¼æ¬¡å°ç”Ÿæˆæ ‘luogu P4234 LCTluogu P2387 LCTluogu P4219 LCT ç»´æŠ¤å­æ ‘ä¿¡æ¯2020.4.8CF 632 Div.2A æ„é€ BC ä¹±æDå…ˆæš´åŠ›æå‡ºæœ€å¿«ç§»åŠ¨æ–¹æ¡ˆï¼Œæ‹†æˆå¤§å°ä¸º $k$ å°±è¡Œ F æ•°è®º$x$ ä¸€å®šæ˜¯åœ¨ç­”æ¡ˆæ˜¯ä»–æœ€å¤§å› å­çš„é‚£ä¸€è½®åŠ è¿›å»ï¼Œæš´åŠ›åˆ†è§£ 2020.4.91900~2300 xjbç»ƒ [0]2h solved 3/5 CF 864E *2000 dp$d_{i}$ å°çš„è‚¯å®šå…ˆæ•‘ï¼ŒæŒ‰ $d_{i}$ sort åæŒ‰æ—¶é—´è½´ dpï¼Œ$f[i][j]$ è¡¨ç¤ºè€ƒè™‘å‰ $i$ ä¸ªç‰©å“ï¼Œå½“å‰åœ¨æ—¶é—´ $j$ æ—¶èƒ½æ•‘çš„æœ€å¤§ä»·å€¼ï¼Œè®°å½•æ–¹æ¡ˆ dp CF 853B *1900 ä¹±æç›´æ¥æš´åŠ›æšä¸¾åœç•™çš„æ—¶é—´ç‚¹ $[i,i+k-1]$ï¼Œç„¶åæä¸ª $multiset$ ç»´æŠ¤ä¸€ä¸‹å‰åæ¯ä¸ªäººæ¥å’Œå»æœ€ä¾¿å®œçš„èˆªç­ CF 865B *1900 è´ªå¿ƒå‡å¦‚æ¯ä¸ªäººéƒ½åƒä»–æœ€å–œæ¬¢çš„é‚£ä¸ªç§ç±»çš„æŠ«è¨ï¼Œè®¾ $A$ ç§æŠ«è¨çš„éœ€æ±‚é‡ä¸º $Sa$ï¼Œ$B$ çš„éœ€æ±‚é‡ä¸º $Sb$ï¼Œè‹¥ $Sa$ % $S + Sb$ % $S$ &gt; $S$ï¼Œåˆ™æ‰€æœ‰äººéƒ½å¯ä»¥æ»¡è¶³ï¼Œå¦åˆ™æœ‰ä¸€äº›äººéœ€è¦æ”¾å¼ƒä»–æœ€å–œæ¬¢çš„é‚£ç§ï¼Œæšä¸¾æœ€åä¸€å—æŠ«è¨æ˜¯ $A$ è¿˜æ˜¯ $B$ çš„æƒ…å†µï¼ŒæŒ‰å·®å€¼æ’åºé€‰æœ€å°çš„å‡ ä¸ªå³å¯ã€‚ CF 862D *2000 äº¤äº’ äºŒåˆ†è§‚å¯Ÿå¯ä»¥å‘ç°é€šè¿‡è¯¢é—® $111110000$ å¯ä»¥ç®—å‡ºæŸæ®µåŒºé—´çš„ $0$ å’Œ $1$ çš„ä¸ªæ•°ï¼ŒäºŒåˆ†æ‰¾å·¦åŒºé—´å…¨æ˜¯ $0$ï¼Œæœ‰åŒºé—´å…¨æ˜¯ $1$ çš„ä½ç½®å°±è¡Œ CF 808D *1900 ä¹±ææšä¸¾æ–­å¼€çš„ä½ç½®ï¼Œ$set$ æŸ¥ä¸€æŸ¥å·®å€¼ QTREE6 lctlctç»´æŠ¤åŒè‰²è”é€šå¿« 2020.4.10CF EDU 85 2020.4.11GCJ æ²¡è¿›R2 é¢“åºŸ ++++++ 2020.4.121900-2300 xjbåˆ· [1]solved 2/5 CF 1017D *1900 æš´åŠ›$ 2^12 $ ç§æƒ…å†µçš„ä»·å€¼å¼€ä¸ªæ¡¶å­˜ä¸€ä¸‹ CF 1015E2 *2000 è´ªå¿ƒæšä¸¾ä¸­ç‚¹è´ªå¿ƒæ”¾æ˜Ÿï¼Œcheck çš„è¯æä¸ªå·®åˆ† CF 992D *2100 æš´åŠ›å¦‚æœæ²¡æœ‰ $1$, $P$ å¾€å‰ä¹˜ä¸åˆ° $100$ æ¬¡å°±çˆ† $2e18$ äº† è€ƒè™‘æˆæ®µçš„ $1$ ä¸€èµ·å¤„ç†ï¼Œå› ä¸ºä¹˜ç§¯ä¸å˜ï¼Œç¬¦åˆæ¡ä»¶çš„ä½ç½®æœ€å¤šä¸€ä¸ª 1900-2300 xjbåˆ· [2]CF 1067A *2000 dpCF 1067B *2000 bfsä»å¶å­å¼€å§‹å¤šç‚¹bfsï¼ŒæŒ‰é¢˜æ„check CF 1039B *2100 äº¤äº’ äºŒåˆ†äºŒåˆ†ï¼Œ&lt;=40 randä¸€ä¸ªç‚¹ CF 1037E *2100 bfså€’ç€è€ƒè™‘ï¼Œé¦–å…ˆæŠŠæ‰€æœ‰ç‚¹éƒ½åŠ è¿›å»ï¼Œåˆ æ‰é‚£äº›åº¦æ•° &lt;k çš„ç‚¹å’Œä»–ä»¬è¿çš„è¾¹ï¼Œè¿™ä¸ªå¯ä»¥ç”¨ bfs æ¥åš åˆ æ‰ä¸€ä¸ªè¾¹å°±çœ‹ä¸€ä¸‹ä»–è¿çš„é‚£ä¸¤ä¸ªç‚¹çš„åº¦æ•°æ˜¯å¦ &lt;kï¼Œå¦‚æœ &lt;k äº†å°±ç»§ç»­ bfs åˆ åˆ°ä¸èƒ½åˆ ä¸ºæ­¢ è¾¹è¦ç”¨setå­˜ CF 493 div.1Aè®¾ $0$ æœ‰ $n$ æ®µï¼Œç­”æ¡ˆå°±æ˜¯ $min\\{x(n-1)+y,yn\\}$ B æ‰“è¡¨C å®¹æ–¥CF 635 div.1AB2020.4.13CF 988E æš´åŠ› *2100CF 962E è´ªå¿ƒ *2200éš¾æƒ³ ç¬¬ä¸€ä¸ª P ä¹‹å‰å’Œæœ€åä¸€ä¸ª P ä¹‹åçš„ AB ä¸€å®šéƒ½æ˜¯ç›¸é‚»çš„ç›´æ¥è¿ è€ƒè™‘è·ç¦»æœ€è¿‘çš„ä¸¤ä¸ª P ä¹‹é—´çš„ AB å¦‚ä½•è¿ï¼š Pâ€”Aâ€”Aâ€¦Aâ€”P åŠ ä¸Š Pâ€”Bâ€”B..Bâ€”P Pâ€”Aâ€”A Aâ€”Aâ€”P åŠ ä¸Š Pâ€”B Bâ€”Bâ€”P ç„¶åä¸¤ä¸ª P å†ç›¸è¿ï¼Œè§£é‡Šä¸€ä¸‹å°±æ˜¯æ–­å¼€å…¶ä¸­æœ€å¤§çš„é—´éš™ ä¸¤ç§å–ä¸ª $min$ å°±æ˜¯ç­”æ¡ˆ CF 997E æ•°æ®ç»“æ„ *3000åŒºé—´ $good$ çš„æ¡ä»¶ï¼š $max-min==r-l$ ç¦»çº¿ï¼Œå¯¹äºæ¯ä¸ªå³ç«¯ç‚¹ç»´æŠ¤å·¦é¢æ¯ä¸ªä½ç½®çš„ç­”æ¡ˆï¼Œå¥—è·¯ç±»ä¼¼äº zzq é‚£é¢˜ï¼Œæä¸¤ä¸ªå•è°ƒæ ˆï¼Œè¸¢å‡ºå…ƒç´ çš„æ—¶å€™å†çº¿æ®µæ ‘ä¸Šæ›´æ–°ä¸€ä¸‹ï¼Œç„¶åç»Ÿè®¡ä¸‹ $(max-min)-(r-l)$ æ˜¯ $0$ çš„æœ‰å¤šå°‘ ä½†è¿™æ ·åªèƒ½æ±‚å›ºå®šæŸä¸ªå³ç«¯ç‚¹çš„ç­”æ¡ˆï¼Œæˆ‘ä»¬è¦çš„æ˜¯å³ç«¯ç‚¹åœ¨ $[l,r]$ æ—¶å·¦ç«¯ç‚¹ $&lt;=l$ ç¬¦åˆæ¡ä»¶çš„ç‚¹æœ‰å¤šå°‘ä¸ªï¼Œå³æˆ‘ä»¬éœ€è¦æ¯ä¸ªç‰ˆæœ¬ç­”æ¡ˆä¹‹å’Œçš„çº¿æ®µæ ‘ ä¸»å¸­æ ‘? çº¿æ®µæ ‘ä¸Šåœ¨ç»´æŠ¤ä¸€ä¸ª $save$ æ ‡è®°ï¼Œä»£è¡¨è¿™ä¸€æ®µåŒºé—´éœ€è¦å¯¹ç­”æ¡ˆè´¡çŒ®ä¸€æ¬¡ï¼Œè¿™ä¸ªæ ‡è®°ä¸æ—¶é—´æ— å…³ï¼Œæ³¨æ„ $pushdown$ æ—¶åªèƒ½å‘æœ€å°å€¼æ‰€åœ¨çš„å„¿å­åŒºé—´è¿›è¡Œç´¯åŠ  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102namespace seg{ int mn[MAXN*4],num[MAXN*4],add[MAXN*4],save[MAXN*4];//,ans[MAXN*4]; LL saveans[MAXN*4]; inline void dosave(int cnt,int v) { saveans[cnt]+=1LL*num[cnt]*v,save[cnt]+=v; } inline void doadd(int cnt,int v){mn[cnt]+=v,add[cnt]+=v;} inline void down(int cnt) { if(add[cnt])doadd(ls,add[cnt]),doadd(rs,add[cnt]),add[cnt]=0; if(save[cnt]) { if(mn[ls]==mn[cnt])dosave(ls,save[cnt]); if(mn[rs]==mn[cnt])dosave(rs,save[cnt]); save[cnt]=0; } } inline void up(int cnt) { if(mn[ls]==mn[rs]) mn[cnt]=mn[ls],num[cnt]=num[ls]+num[rs]; else if(mn[ls]&lt;mn[rs]) mn[cnt]=mn[ls],num[cnt]=num[ls]; else mn[cnt]=mn[rs],num[cnt]=num[rs]; saveans[cnt]=saveans[ls]+saveans[rs]; } void build(int l,int r,int cnt) { if(l==r){mn[cnt]=0,num[cnt]=1;return;} build(l,mid,ls),build(mid+1,r,rs),up(cnt); } LL query(int l,int r,int nl,int nr,int cnt) { if(l==nl&amp;&amp;r==nr)return saveans[cnt]; down(cnt); if(nr&lt;=mid)return query(l,mid,nl,nr,ls); if(nl&gt; mid)return query(mid+1,r,nl,nr,rs); return query(l,mid,nl,mid,ls)+query(mid+1,r,mid+1,nr,rs); } void rangeadd(int l,int r,int nl,int nr,int v,int cnt) { if(l==nl&amp;&amp;r==nr){doadd(cnt,v);return;} down(cnt); if(nr&lt;=mid)rangeadd(l,mid,nl,nr,v,ls); else if(nl&gt;mid)rangeadd(mid+1,r,nl,nr,v,rs); else rangeadd(l,mid,nl,mid,v,ls),rangeadd(mid+1,r,mid+1,nr,v,rs); up(cnt); } void rangesave(int l,int r,int nl,int nr,int v,int cnt) { if(l==nl&amp;&amp;r==nr){if(mn[cnt]==0)dosave(cnt,v);return;} down(cnt); if(nr&lt;=mid)rangesave(l,mid,nl,nr,v,ls); else if(nl&gt;mid)rangesave(mid+1,r,nl,nr,v,rs); else rangesave(l,mid,nl,mid,v,ls),rangesave(mid+1,r,mid+1,nr,v,rs); up(cnt); }} int n,m;int a[MAXN],l[MAXN],r[MAXN]; LL ans[MAXN];vector&lt;int&gt; pos[MAXN];struct elem{ int l,r,v; bool operator &lt;(const elem &amp;t)const{return v&lt;t.v;} bool operator &gt;(const elem &amp;t)const{return v&gt;t.v;}};stack&lt;elem&gt; mx,mn; int work(){ scanf(&quot;%d&quot;,&amp;n); fp(i,1,n)scanf(&quot;%d&quot;,&amp;a[i]); scanf(&quot;%d&quot;,&amp;m); fp(i,1,m)scanf(&quot;%d%d&quot;,&amp;l[i],&amp;r[i]),pos[r[i]].pb(i); seg::build(1,n,1); fp(i,1,n) { if(i&gt;1)seg::rangeadd(1,n,1,i-1,-1,1); elem cur = {0,i,a[i]}; while(!mx.empty()&amp;&amp;cur&gt;mx.top()) { elem t=mx.top(); mx.pop(); seg::rangeadd(1,n,t.l,t.r,-t.v,1); } cur.l=mx.empty()?1:(mx.top().r+1); mx.push(cur); seg::rangeadd(1,n,cur.l,cur.r,a[i],1); while(!mn.empty()&amp;&amp;cur&lt;mn.top()) { elem t=mn.top(); mn.pop(); seg::rangeadd(1,n,t.l,t.r,t.v,1); } cur.l=mn.empty()?1:(mn.top().r+1); mn.push(cur); seg::rangeadd(1,n,cur.l,cur.r,-a[i],1); seg::rangesave(1,n,1,i,1,1); for(auto j:pos[i]) ans[j]=seg::query(1,n,l[j],r[j],1); } fp(i,1,m)printf(&quot;%lld\\n&quot;,ans[i]); return 0;} 2020.4.14CF 634 Div.31335 E2 æš´åŠ›ç­”æ¡ˆä¸€å®šæ˜¯ä»å°½é‡é ä¸¤è¾¹çš„ä½ç½®é€‰ $a$ï¼Œä¸­é—´çš„éƒ¨åˆ†é€‰å‡ºç°æ¬¡æ•°æœ€å¤šçš„å­—æ¯ï¼Œå¤„ç†ä¸‹å‰ç¼€å’Œæšä¸¾ä¸¤è¾¹çš„å­—æ¯å’Œé•¿åº¦å°±è¡Œ å¤æ‚åº¦æ˜¯ $O(200*n)$ï¼Œä¸€å¼€å§‹è¿˜ä»¥ä¸ºæ˜¯ $O(200*200*n)$ï¼Œå…¶å®æ¯ä¸ªä½ç½®åªä¼šè¢«æšä¸¾åˆ°ä¸€æ¬¡ï¼Œæ‰€ä»¥æ˜¯ $n$ çº§åˆ«çš„è€Œé $200*n$ 1335 F å€å¢è§‚å¯Ÿå¯ä»¥å‘ç°è¿™å›¾å…¶å®æ˜¯ä¸ªåŸºç¯æ ‘ï¼Œèµ°è¶³å¤Ÿæ­¥æ•°åæ‰€æœ‰æœºå™¨äººéƒ½ä¼šåœ¨ç¯ä¸Šè½¬ï¼Œå³æ ‘ä¸Šæ¯ä¸ªç‚¹éƒ½ä¸ç¯ä¸Šç‚¹ä¸€ä¸€å¯¹åº” é‚£ä¹ˆ $ans1$ å°±æ˜¯æ‰€æœ‰ç¯çš„å¤§å°ä¹‹å’Œï¼Œ$ans2$ å°±æ˜¯æœ‰å¤šå°‘é»‘ç‚¹èƒ½ä¸Šç¯ è€ƒè™‘å€å¢èµ°ä¸ª $2e6$ æ­¥ï¼Œè‚¯å®šå°±ä¸Šç¯äº†ï¼Œå‰©ä¸‹å°±å¥½åšäº† $O(nlogn)$ è·‘çš„æ…¢ç‚¹ï¼Œä½†ç é‡å°‘å‘€ 1900-2300 xjbåˆ· [3]2/5 CF 909E *2100 æ‹“æ‰‘æŠŠæ‹“æ‰‘æ’åºæ‰©å±•ä¸€ä¸‹ï¼Œæ¯è½®å…ˆæ‹¿é»‘ç‚¹åˆ°æ‹¿ä¸åŠ¨ä½ç½®ï¼Œå†ä¸æ–­æ‹¿ç™½ç‚¹åˆ°æ‹¿ä¸åŠ¨ä½ç½® ç™½ç‚¹æ‹¿çš„è½®æ•°å°±æ˜¯ç­”æ¡ˆ CF 912D *2100 æœŸæœ› æ•°æ®ç»“æ„é¦–å…ˆæ ¼å­ä¸Šæ¯ä¸ªç‚¹å¯¹ç­”æ¡ˆçš„è´¡çŒ®æ˜¯å›ºå®šçš„ï¼Œæˆ‘ä»¬åªè¦é€‰å‰ $k$ å¤§åŠ èµ·æ¥å°±æ˜¯æœ€ä¼˜è§£ æ‰“è¡¨è§‚å¯Ÿå‘ç°è´¡çŒ®çŸ©é˜µæ˜¯ä»ä¸­å¿ƒå‘å››å‘¨é€’å‡ ç”±äº $k==1e5$ï¼Œæˆ‘ä»¬ç”¨ç±»ä¼¼ $bfs$ çš„åšæ³•ï¼Œ æ¯æ¬¡é€‰é˜Ÿåˆ—ä¸­æƒå€¼æœ€å¤§çš„ç‚¹ï¼Œç„¶åå‘å››å‘¨æ‰©å±• æœ€å¤šæ‰©å±• $4*1e5$ æ¬¡ï¼Œå¤æ‚åº¦ä¸ä¼šç‚¸ 1900-2300 xjbåˆ· [4]2/5 1012C CF 1012C *2000 dp$dp[i][j][0/1]$ è¡¨ç¤ºå‰ $i$ ä¸ªå‘ï¼Œé€  $j$ ä¸ªæˆ¿å­ï¼Œæœ€åä¸€ä¸ªå±±æœ‰æ²¡æœ‰è¢«ç è¿‡ è¿™ä¹ˆå®šä¹‰æ˜¯å› ä¸ºå¦‚æœä¸€ä¸ªå±±è¢«ç è¿‡ï¼Œä»–ä¸€å®šæ˜¯ $min(a[i],a[i-1]-1)$ çš„é«˜åº¦ è½¬ç§»è„‘è¡¥ä¸€ä¸‹ï¼Œç‰¹åˆ¤ $n=1$ å’Œ $n=2$ CF 1061D *2000 è´ªå¿ƒ sort stlæŒ‰ $pair$ æ’åºï¼Œè´ªå¿ƒé€‰ä¸€ä¸ªå³ç«¯ç‚¹ç¦»å½“å‰å·¦ç«¯ç‚¹æœ€è¿‘çš„ï¼Œå¦‚æœæ”¾ä¸ä¸‹ æˆ– æ–°å¼€ä¸€ä¸ªæ›´åˆé€‚å°±æ–°å¼€ä¸€æ®µ æ‰¾ $&lt;l$ æœ€å¤§çš„å³ç«¯ç‚¹ç”¨ $set$ å°±è¡Œ CF 1030E *2100 æš´åŠ›zzqnbå°±å®Œäº† æŠŠæ¯ä¸ªæ•°æ¢æˆ $bitcount(x)$ï¼Œç„¶åè½¬åŒ–é¢˜æ„ï¼Œé—®æœ‰å¤šå°‘åŒºé—´æ»¡è¶³ æ¯æ¬¡é€‰ä¿©æ•°å‡ $1$ï¼Œå¯ä»¥æŠŠåŒºé—´å†…çš„æ•°å…¨å‡ä¹˜ $0$ åŒºé—´å†…çš„æ•°å¯ä»¥å‡ä¸º $0$ çš„æ¡ä»¶: 1.$\\sum_{i=l}^{r}a[i]&gt;=2*max\\{a[l]â€¦a[r]\\}$ 2.$\\sum_{i=l}^{r}a[i]$ % $2 == 0$ ç”±äº $1&lt;=a[i]&lt;=64$ï¼Œé•¿åº¦å¤§äº $128$ çš„åŒºé—´ä¸€å®šæ»¡è¶³æ¡ä»¶ $1$ï¼Œåªè¦åˆ¤ä¸‹æ¡ä»¶ $2$ å³å¯ï¼Œè¿™ä¸ªç”¨é€šè¿‡ç»Ÿè®¡å‰ç¼€å’Œå¥‡å¶æ€§å¯ä»¥ $O(1)$ æ¥ç®— é•¿åº¦ $&lt;=128$ çš„åŒºé—´æš´åŠ›åˆ¤ä¸¤ä¸ªæ¡ä»¶ å¤æ‚åº¦ï¼š$O(nlogn)$ CF 1028D *2100 æ¨¡æ‹Ÿæ„ä¹‰ä¸æ˜ æ¯æ¬¡ $accept$ ç¡®å®šä¸€äº› $buy$ å’Œ $sell$ï¼Œè‡ªå·±ä¸ç¡®å®š $ans*=2$ æœ€åä¸€æ®µ $add$ æšä¸¾åˆ†ç•Œç‚¹ $ans*=(siz+1)$","link":"/2020/03/27/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"ç½‘ç»œæµ24é¢˜ ç®€è¦é¢˜è§£","text":"æ´›è°· LOJ ä¸‹é¢ç”¨åˆ°çš„ (flow,cost) è¡¨ç¤ºè¾¹çš„å®¹é‡å’Œè´¹ç”¨ï¼ŒSè¡¨ç¤ºæºç‚¹ï¼ŒTè¡¨ç¤ºæ±‡ç‚¹ AC 23/24 é¢˜è§£ 6/23 1.é¤å·¾è®¡åˆ’é—®é¢˜è´¹ç”¨æµ é¦–å…ˆå»ºç«‹ 2*n ä¸ªèŠ‚ç‚¹ï¼Œ1~n ä»£è¡¨æ¯æ—¥çš„é¤å·¾éœ€æ±‚é‡ï¼Œn+1 ~ 2*n ä»£è¡¨æ¯æ—¥å¯ä»¥æä¾›çš„è„æ¯›å·¾ã€‚ ä» S åˆ° 1~n åˆ†åˆ«è¿ (inf,p) çš„è¾¹è¡¨ç¤ºæ¯æ—¥å¯ä»¥è´­ä¹°æ— é™é‡çš„æ¯›å·¾ ä» 1~n åˆ° T åˆ†åˆ«è¿ (w[i],0) çš„è¾¹è¡¨ç¤ºæ¯æ—¥éœ€æ±‚æ¯›å·¾é‡ ä» S åˆ° n+i (1&lt;=i&lt;=n) è¿ (w[i],0) çš„è¾¹ä»£è¡¨æ¯æ—¥å¯æä¾› w[i] çš„è„æ¯›å·¾ ä» n+i åˆ° i+m (1&lt;=i&lt;=n) è¿ (w[i],f) çš„è¾¹ä»£è¡¨å¿«æ´—éƒ¨ï¼Œæ…¢æ´—åŒç† æœ€åä» i åˆ° i+1 (1&lt;=i&lt;=n-1) è¿ (inf,0) çš„è¾¹ä»£è¡¨æ´—å¥½çš„æ¯›å·¾å¯ä»¥ç•™åˆ°ä¸‹ä¸€å¤© 2.[CTSC1999]å®¶å›­æœ€å¤§æµ å…ˆåˆ¤æ–­æ˜¯å¦ä¼˜è§£ï¼Œå¹¶æŸ¥é›†åˆå¹¶æ‰€æœ‰é£èˆ¹å¯åˆ°è¾¾ç‚¹ï¼Œåˆ¤æ–­èµ·ç‚¹ç»ˆç‚¹æ˜¯å¦è”é€š åœ°çƒæœˆçƒå¯çœ‹ä½œä¸¤ä¸ªç‰¹æ®Šçš„ç©ºé—´ç«™ï¼Œç„¶åå¯¹æ¯ä¸ªæ—¶é—´ç‚¹éƒ½å»ºä¸€å¥—å…¨æ–°çš„ç©ºé—´ç«™å’Œé£èˆ¹ æ¯ä¸ªæ—¶é—´çš„é£èˆ¹å’Œåœé ç«™(å½“å‰æ—¶é—´ä¸‹)è¿ inf çš„åŒå‘è¾¹ï¼Œè¡¨ç¤ºäººå¯ä¸Šä¸‹é£èˆ¹ ä¸Šä¸€æ—¶é—´çš„é£èˆ¹å‘å½“å‰æ—¶é—´çš„é£èˆ¹è¿ hpi çš„è¾¹ï¼Œä»£è¡¨é£èˆ¹æœ€å¤šå¯è¿é€ hpi çš„äºº ä¸Šä¸€æ—¶é—´çš„ç©ºé—´ç«™å‘å½“å‰æ—¶é—´çš„ç©ºé—´ç«™è¿ inf çš„è¾¹ï¼Œè¡¨ç¤ºäººç•™åœ¨ç©ºé—´ç«™ä¸åŠ¨ æºç‚¹å‘åˆå§‹æ—¶é—´çš„åœ°çƒè¿ k çš„è¾¹ï¼Œè¡¨ç¤ºå…±æœ‰ k äººéœ€è¦è¿è¾“ æ¯ä¸ªæ—¶é—´ç‚¹çš„æœˆçƒå‘æ±‡ç‚¹è¿ k çš„è¾¹ï¼Œè¡¨ç¤ºåˆ°è¾¾ç»ˆç‚¹ å»ºå®Œå›¾åä¸æ–­å¢åŠ æ—¶é—´ï¼Œå¢å¹¿ï¼Œç›´åˆ°æœ€å¤§æµ == k 3.é£è¡Œå‘˜é…å¯¹æ–¹æ¡ˆé—®é¢˜äºŒåˆ†å›¾æœ€å¤§åŒ¹é… ç”¨æœ€å¤§æµåšçš„è¯å°±æ˜¯ S å‘å·¦è¾¹ç‚¹è¿å®¹é‡ 1 çš„è¾¹ï¼Œå·¦è¾¹ç‚¹å‘å³è¾¹ç‚¹èƒ½é…å¯¹çš„è¿å®¹é‡ 1 çš„è¾¹ï¼Œå³è¾¹ç‚¹å‘ T è¿å®¹é‡ 1 çš„è¾¹ çœ‹é¢˜è§£è¯´ Dinic æ¯” åŒˆç‰™åˆ©å¿«ä¸çŸ¥çœŸå‡ã€‚ã€‚æœ‰æ—¶é—´æµ‹æµ‹ 4.è½¯ä»¶è¡¥ä¸é—®é¢˜æœ€çŸ­è·¯(ç”¨æœ€çŸ­è·¯è½¬ç§»çš„dpï¼Œç±»ä¼¼åˆ†å±‚å›¾) æ¯ä¸ªç‚¹çš„ç¼–å· id è¡¨ç¤º bug çš„ä¿®è¡¥çš„çŠ¶æ€ï¼Œå³äºŒè¿›åˆ¶ä¸Šè¿™ä½æ˜¯ 0 ä»£è¡¨å·²ä¿®å¤ï¼Œ1 ä»£è¡¨æœªä¿®å¤ï¼Œèƒ½ç”¨è¡¥ä¸çš„ç‚¹ä¹‹é—´è¿æœ‰å‘è¾¹ï¼Œæƒå€¼ä¸ºæ‰“è¡¥ä¸æ‰€éœ€æ—¶é—´ï¼Œæ±‚ä¸ªä» $2^n-1$ åˆ° $0$ çš„æœ€çŸ­è·¯ æ³¨æ„è¾¹å­˜ä¸ä¸‹ï¼Œæ¾å¼›çš„æ—¶å€™åŠ¨æ€å»ºè¾¹ 5.å¤ªç©ºé£è¡Œè®¡åˆ’é—®é¢˜æœ€å°å‰² æœ€å¤§æƒé—­åˆå­å›¾ ä¸€èˆ¬çš„æœ€å¤§æƒé—­åˆå­å›¾é—®é¢˜ï¼šç»™å®šä¸€ä¸ªè”é€šçš„ DAGï¼Œæ¯ä¸ªç‚¹æœ‰æƒé‡ï¼Œé€‰ä¸€ä¸ªç‚¹å°±å¿…é¡»é€‰ä»¥è¯¥ç‚¹ä¸ºå‡ºè¾¹çš„æ‰€æœ‰ç‚¹(ä¾èµ–å…³ç³»)ï¼Œæ±‚ä¸€ä¸ªåˆæ³•çš„é€‰ç‚¹æ–¹æ¡ˆä½¿å¾—ç‚¹æƒå’Œæœ€å¤§ã€‚ è€ƒè™‘æœ€å°å‰²å»ºæ¨¡ï¼Œç‚¹æƒä¸ºæ­£çš„ç‚¹ä¸ºå·¦éƒ¨å›¾ï¼Œç‚¹æƒä¸ºè´Ÿçš„ç‚¹ä¸ºåˆéƒ¨å›¾ï¼ŒS å‘å·¦éƒ¨ç‚¹ç»ƒ wi çš„è¾¹ï¼Œå³éƒ¨å›¾å‘ T è¿ -wi çš„è¾¹ï¼Œå¯¹äºåŸå›¾ä¸­çš„è¾¹ ä»ç‚¹ u å‘ç‚¹ v è¿ inf çš„è¾¹ï¼Œè®°æœ€å°å‰²ä¸º cutï¼Œç­”æ¡ˆå³ä¸ºæ‰€æœ‰æ­£ç‚¹æƒä¹‹å’Œå‡å» cutã€‚ ç®€å•è¯´ä¸€ä¸‹ä¸ªäººçš„ç†è§£ï¼Œé¦–å…ˆæ–°å›¾çš„ä¸€ä¸ªå‰²å¯¹åº”ç€åŸå›¾çš„ä¸€ç§é€‰æ‹©æ–¹æ¡ˆï¼Œå‰²æ‰å·¦è¾¹çš„è¾¹ç›¸å½“äºå¼ƒæ‰æŸä¸ªæ­£æƒçš„ç‚¹ï¼Œå‰²æ‰å³è¾¹çš„è¾¹ç›¸å½“äºé€‰æ‹©æŸä¸ªè´Ÿæƒç‚¹ æ¥ä¸‹æ¥è€ƒè™‘æ–¹æ¡ˆçš„åˆæ³•æ€§ï¼Œåè¯ä»¥ä¸‹ï¼Œå‡è®¾é€‰äº† u æ²¡é€‰ v ä¸” å¯¹åº”åŸå›¾çš„ä¸€ä¸ªæœ‰å‘è¾¹ï¼š è‹¥ uã€v åˆ†åˆ«ä½äºæ–°å›¾çš„ä¸¤ä¾§ï¼Œè®¾w[u]&gt;0ï¼Œw[v]","link":"/2020/02/10/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98-%E7%AE%80%E8%A6%81%E9%A2%98%E8%A7%A3/"},{"title":"æœ€å¤§æµ&amp;&amp;è´¹ç”¨æµ æ¿å­æ•´ç†","text":"3 ç§è´¹ç”¨æµåœ¨ loj ä¸Šæµ‹è¯•çš„ç»“æœï¼š EK + dij 5584ms Dinic + spfa 4649ms Dinic + dij 4870ms æ¨èä½¿ç”¨ dinic + dijï¼Œå‡ºé¢˜äººäººå‡å¡ spfa â€¦ ç½‘ç»œæµæ³¨æ„ä»¥ä¸‹æ¨¡æ¿é»˜è®¤ç¼–å·èŒƒå›´ä¸º 1~nï¼Œè¯·ç¡®ä¿æ‰€æœ‰ç¼–å·ï¼ˆåŒ…æ‹¬æºæ±‡ç‚¹ï¼‰éƒ½åœ¨æ­¤èŒƒå›´å†…ï¼Œä»¥é˜²åˆå§‹åŒ–ä¸å…¨ã€‚ æœ€å¤§æµDinic ç”¨å®¹é‡ä¸ä¸º 0 çš„è¾¹æ„å»ºå±‚æ¬¡å›¾ï¼Œåœ¨å±‚æ¬¡å›¾ä¸Šæœ‰æ–¹å‘çš„è¿›è¡Œå¤šè·¯å¢å¹¿ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465int n,m,S,T;struct edge{ int u,v,next; LL flow;}e[N*2];int pre[MAXN],cur[MAXN],cnt=1;void add(int u,int v,LL flow){ e[++cnt]={u,v,pre[u],flow},pre[u]=cnt;}int dis[MAXN],q[MAXN];bool bfs() //æ„å»ºåˆ†å±‚å›¾{ int h=1,t=0; mst(dis,0),q[++t]=S,dis[S]=1; while(h&lt;=t) { int u=q[h++]; for(int i=pre[u];i;i=e[i].next) { int v=e[i].v; if(!dis[v]&amp;&amp;e[i].flow) dis[v]=dis[u]+1,q[++t]=v; } } return dis[T];}LL dfs(int u,LL flow) //å¤šè·¯å¢å¹¿{ if(u==T||!flow)return flow; LL ret=0,d=0; for(int i=cur[u];i;i=e[i].next) { int v=e[i].v; cur[u]=i; //å½“å‰å¼§ä¼˜åŒ– if(dis[v]==dis[u]+1&amp;&amp;e[i].flow) { d=dfs(v,min(flow-ret,e[i].flow)); if(d)ret+=d,e[i].flow-=d,e[i^1].flow+=d; if(ret==flow)return ret; } } return ret;}LL dinic(){ LL ans=0; while(bfs()) { fp(i,1,n)cur[i]=pre[i]; ans+=dfs(S,linf); } return ans;}int work(){ scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;S,&amp;T); fp(i,1,m) { int u,v;LL flow; scanf(&quot;%d%d%lld&quot;,&amp;u,&amp;v,&amp;flow); add(u,v,flow),add(v,u,0); } return printf(&quot;%lld\\n&quot;,dinic());} è´¹ç”¨æµ1. Dinic Bfsæ”¹æœ€çŸ­è·¯ç®—æ³•å°† Dinic ä¸­çš„ bfs æ„å»ºå±‚æ¬¡å›¾æ”¹æˆæœ€çŸ­è·¯ç®—æ³•ï¼ˆSpfaæˆ–å¸¦åŠ¿å‡½æ•°çš„Dijkstraï¼‰ï¼Œæ¯æ¬¡æ²¿ç€æœ€çŸ­è·¯å›¾çš„æ–¹å‘è¿›è¡Œå¢å¹¿ã€‚ Spfa123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int n,m,S,T;struct edge{int u,v,next;LL flow,w;}e[N];int pre[MAXN],cur[MAXN],cnt=1;void add(int u,int v,LL flow,LL w){e[++cnt]={u,v,pre[u],flow,w},pre[u]=cnt;}bool vis[MAXN];int q[MAXN],h,t; LL dis[MAXN];bool spfa()//å»ºè®®ç”¨stl queue æ‰‹å†™è¦æ¢æˆå¾ªç¯é˜Ÿåˆ—é˜²è¶Šç•Œ{ fp(i,1,n)dis[i]=linf; mst(vis,0); h=1,t=0,vis[S]=1,dis[S]=0,q[++t]=S; while(h&lt;=t) { int u=q[(h++)%MAXN]; vis[u]=0; gow(u)if(e[i].flow&amp;&amp;dis[v]&gt;dis[u]+w) { dis[v]=dis[u]+w; if(!vis[v])vis[v]=1,q[(++t)%MAXN]=v; } } return dis[T]&lt;linf;}lpr ans;LL dfs(int u,LL flow){ if(u==T||!flow) return ans.fi+=flow,ans.se+=dis[u]*flow,flow; LL ret=0,d; vis[u]=1; //visæ ‡è®° é˜²æ­¢åœ¨è´¹ç”¨ä¸º 0 çš„è¾¹ä¸Šåå¤è·³ for(int i=cur[u];i;i=e[i].next) { int v=e[i].v;LL w=e[i].w; cur[u]=i; if(e[i].flow&amp;&amp;dis[u]+w==dis[v]&amp;&amp;!vis[v]) { d=dfs(v,min(e[i].flow,flow-ret)); if(d) e[i].flow-=d,e[i^1].flow+=d,ret+=d; if(ret==flow)return ret; } } return ret;}void mcf(){ while(spfa()) { mst(vis,0); fp(i,1,n)cur[i]=pre[i]; dfs(S,linf); }}int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); scanf(&quot;%d%d&quot;,&amp;S,&amp;T); fp(i,1,m) { int u,v; LL f,w; scanf(&quot;%d%d%lld%lld&quot;,&amp;u,&amp;v,&amp;f,&amp;w); add(u,v,f,w),add(v,u,0,-w); } mcf(); return printf(&quot;%lld %lld\\n&quot;,ans.fi,ans.se);} Dijkstra1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465int n,m,S,T;struct edge{int u,v,next;LL flow,w;}e[N];int pre[MAXN],cur[MAXN],cnt=1;void add(int u,int v,LL flow,LL w){ e[++cnt]={u,v,pre[u],flow,w},pre[u]=cnt;}bool vis[MAXN];LL dis[MAXN],h[MAXN];bool dij(){ priority_queue&lt;lpr&gt; q; fp(i,1,n)dis[i]=linf; dis[S]=0,q.push({0,S}); while(!q.empty()) { int u=q.top().se; LL d=-q.top().fi; q.pop(); if(d!=dis[u])continue; gow(u)if(e[i].flow&amp;&amp;dis[u]+w+h[u]-h[v]&lt;dis[v]) dis[v]=dis[u]+w+h[u]-h[v],q.push({-dis[v],v}); } //fp(i,1,n)cout&lt;&lt;dbgs2(i,dis[i])&lt;&lt;endl; return dis[T]&lt;linf;}lpr ans;LL dfs(int u,LL flow){ //cout &lt;&lt; dbgs(u) &lt;&lt; endl; if(u==T||!flow) return ans.fi+=flow,ans.se+=(dis[u]+h[u])*flow,flow; LL ret=0,d; vis[u]=1; for(int i=cur[u];i;i=e[i].next) { int v=e[i].v;LL w=e[i].w; cur[u]=i; if(e[i].flow&amp;&amp;dis[u]+w+h[u]-h[v]==dis[v]&amp;&amp;!vis[v]) { d=dfs(v,min(e[i].flow,flow-ret)); if(d) e[i].flow-=d,e[i^1].flow+=d,ret+=d; if(ret==flow)return ret; } } return ret;}void mcf(){ while(dij()) { mst(vis,0); fp(i,1,n)cur[i]=pre[i]; dfs(S,linf); fp(i,1,n)if(dis[T]&lt;linf)h[i]+=dis[i]; //ç»´æŠ¤åŠ¿å‡½æ•° }}int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); scanf(&quot;%d%d&quot;,&amp;S,&amp;T); fp(i,1,m) { int u,v; LL f,w; scanf(&quot;%d%d%lld%lld&quot;,&amp;u,&amp;v,&amp;f,&amp;w); add(u,v,f,w),add(v,u,0,-w); } mcf(); return printf(&quot;%lld %lld\\n&quot;,ans.fi,ans.se);} 2.EKDijkstra12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int n,m,S,T;struct edge{int u,v,next;LL flow,w;}e[N];int pre[MAXN],cur[MAXN],cnt=1;void add(int u,int v,LL flow,LL w){ e[++cnt]={u,v,pre[u],flow,w},pre[u]=cnt;}bool vis[MAXN];LL dis[MAXN],h[MAXN];int from[MAXN];bool dij(){ priority_queue&lt;lpr&gt; q; fp(i,1,n)dis[i]=linf; dis[S]=0,q.push({0,S}); while(!q.empty()) { int u=q.top().se; LL d=-q.top().fi; q.pop(); if(d!=dis[u])continue; gow(u)if(e[i].flow&amp;&amp;dis[u]+w+h[u]-h[v]&lt;dis[v]) dis[v]=dis[u]+w+h[u]-h[v],q.push({-dis[v],v}),from[v]=i; } return dis[T]&lt;linf;}lpr ans;void mcf(){ while(dij()) { LL flow=linf; for(int u=T;u!=S;u=e[from[u]].u) flow=min(flow,e[from[u]].flow); ans.fi+=flow,ans.se+=(dis[T]+h[T])*flow; for(int u=T;u!=S;u=e[from[u]].u) e[from[u]].flow-=flow, e[from[u]^1].flow+=flow; fp(i,1,n)if(dis[i]&lt;linf)h[i]+=dis[i]; }}int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); scanf(&quot;%d%d&quot;,&amp;S,&amp;T); fp(i,1,m) { int u,v; LL f,w; scanf(&quot;%d%d%lld%lld&quot;,&amp;u,&amp;v,&amp;f,&amp;w); add(u,v,f,w),add(v,u,0,-w); } mcf(); return printf(&quot;%lld %lld\\n&quot;,ans.fi,ans.se);}","link":"/2020/02/06/%E6%9C%80%E5%A4%A7%E6%B5%81-%E8%B4%B9%E7%94%A8%E6%B5%81-%E6%9D%BF%E5%AD%90%E6%95%B4%E7%90%86/"},{"title":"çº¿æ®µæ ‘åˆ†æ²»å°ç»“","text":"æ ‡è®°æ°¸ä¹…åŒ–æ ‡è®°æ°¸ä¹…åŒ–æ˜¯ä¸€ç§çº¿æ®µæ ‘ä¸Šæ‰“æ ‡è®°çš„æŠ€å·§ï¼Œç”¨æ¥åœ¨æŸäº›åœºåˆä»£æ›¿ pushup å’Œ pusdown æ“ä½œï¼Œä½†æ— æ³•å¤„ç†æ ‡è®°åœ¨æ—¶é—´ä¸Šçš„å…ˆåé¡ºåºå’Œæ ‡è®°çš„å åŠ ï¼Œå…·ä½“å¯ä»¥è§ çº¿æ®µæ ‘æ ‡è®°æ°¸ä¹…åŒ–ä¸ªäººç†è§£ &amp; BZOJ 1513 [POI2006]Tet-Tetris 3D é¡ºä¾¿é‡å†™äº†ä¸€ä¸‹è¿™ä¸ªé¢˜ï¼Œå¯ä»¥ç•™ç€åšæ¿å­äº†ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364int n=1000;struct seg{ int val[MAXN],cov[MAXN]; void docov(int v,int cnt) { val[cnt]=max(val[cnt],v); cov[cnt]=max(cov[cnt],v); } void down(int cnt) { if(cov[cnt]) docov(cov[cnt],ls), docov(cov[cnt],rs), cov[cnt]=0; } bool update(int l,int r,int nl,int nr,int v,int cnt) { if(l==nl&amp;&amp;r==nr) return docov(v,cnt),0; down(cnt),val[cnt]=max(val[cnt],v); if(nr&lt;=mid)return update(l,mid,nl,nr,v,ls); if(nl&gt; mid)return update(mid+1,r,nl,nr,v,rs); return update(l,mid,nl,mid,v,ls),update(mid+1,r,mid+1,nr,v,rs); } int query(int l,int r,int nl,int nr,int cnt) { if(l==nl&amp;&amp;r==nr)return val[cnt];down(cnt); if(nr&lt;=mid)return query(l,mid,nl,nr,ls); if(nl&gt; mid)return query(mid+1,r,nl,nr,rs); return max(query(l,mid,nl,mid,ls),query(mid+1,r,mid+1,nr,rs)); }}val[MAXN],cov[MAXN];int query(int l,int r,int nl,int nr,int y1,int y2,int cnt){ int ans=cov[cnt].query(1,n,y1,y2,1); if(l==nl&amp;&amp;r==nr)return max(ans,val[cnt].query(1,n,y1,y2,1)); if(nr&lt;=mid)return max(ans,query(l,mid,nl,nr,y1,y2,ls)); if(nl&gt; mid)return max(ans,query(mid+1,r,nl,nr,y1,y2,rs)); return max({ans, query(l,mid,nl,mid,y1,y2,ls), query(mid+1,r,mid+1,nr,y1,y2,rs) });}bool update(int l,int r,int nl,int nr,int y1,int y2,int v,int cnt){ val[cnt].update(1,n,y1,y2,v,1); if(l==nl&amp;&amp;r==nr) return cov[cnt].update(1,n,y1,y2,v,1),0; if(nr&lt;=mid)return update(l,mid,nl,nr,y1,y2,v,ls); if(nl&gt; mid)return update(mid+1,r,nl,nr,y1,y2,v,rs); return update(l,mid,nl,mid,y1,y2,v,ls),update(mid+1,r,mid+1,nr,y1,y2,v,rs);}int work(){ int a,b,q;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;q); while(q--) { int d,s,w,x,y; scanf(&quot;%d%d%d%d%d&quot;,&amp;d,&amp;s,&amp;w,&amp;x,&amp;y); int x1=x+1,x2=x+d,y1=y+1,y2=y+s; int h=query(1,n,x1,x2,y1,y2,1)+w; update(1,n,x1,x2,y1,y2,h,1); } return printf(&quot;%d\\n&quot;,query(1,n,1,n,1,n,1));} çº¿æ®µæ ‘åˆ†æ²»çº¿æ®µæ ‘å¸¸ç”¨æ¥ç»´æŠ¤é¡ºåºåºåˆ—ä¸Šçš„åŒºé—´ä¿¡æ¯(å¦‚åŒºé—´å’Œï¼ŒåŒºé—´æœ€å¤§å€¼ç­‰)ï¼Œè€Œçº¿æ®µæ ‘åˆ†æ²»åˆ™åˆ©ç”¨çº¿æ®µæ ‘æ¥ç»´æŠ¤æ—¶é—´è½´(æ“ä½œçš„å…ˆåå…³ç³»)ï¼Œå¹¶åˆ©ç”¨æ ‡è®°æ°¸ä¹…åŒ–çš„æ€æƒ³æ¥è§£å†³ä¸€äº›éœ€è¦æ’¤é”€æ“ä½œçš„æ•°æ®ç»“æ„é—®é¢˜ã€‚ ä¾‹é¢˜1: BZOJ 4184 shallotæœ¬é¢˜ä¸­éœ€è¦ä½ ç»´æŠ¤ä¸€ä¸ªæ”¯æŒåˆ é™¤çš„çº¿æ€§åŸºï¼Œè„‘è¡¥å¯çŸ¥çº¿æ€§åŸºçš„åˆ é™¤å¾ˆéº»çƒ¦(orä¸å¯åš)ã€‚ æˆ‘ä»¬æŠŠæ¯æ¬¡æ“ä½œ(åŒ…æ‹¬è¯¢é—®åœ¨å†…)çœ‹ä½œæ˜¯ä¸€ä¸ªæ—¶é—´ç‚¹ï¼Œé‚£ä¹ˆæ¯ä¸€ä¸ªæ•° $a_{i}$ éƒ½æœ‰ä¸€ä¸ªå¯ç”¨çš„æ—¶é—´åŒºé—´ã€‚ç±»ä¼¼äºçº¿æ®µæ ‘æ‰“æ ‡è®°çš„åšæ³•ï¼Œæˆ‘ä»¬å°†è¿™ä¸ªåŒºé—´æ‹†æˆ $logn$ ä¸ªåŒºé—´å¹¶è¦†ç›–åœ¨çº¿æ®µæ ‘ä¸Šå¯¹åº”çš„èŠ‚ç‚¹ä¸Šï¼Œå…·ä½“æ¥è®²æ˜¯çº¿æ®µæ ‘çš„æ¯ä¸ªèŠ‚ç‚¹ç»´æŠ¤ä¸€ä¸ª vector æ¥å­˜è¿™ä¸ªæ ‡è®°ã€‚ ç„¶åæˆ‘ä»¬è€ƒè™‘å¦‚ä½•å¤„ç†è¯¢é—®æ“ä½œï¼Œæ¯æ¬¡è¯¢é—®å¯ä»¥çœ‹ä½œæ˜¯æ ¹èŠ‚ç‚¹åˆ°æŸä¸ªå¶å­èŠ‚ç‚¹çš„ä¸€æ¡è·¯å¾„ï¼Œæˆ‘ä»¬åªè¦å°†è¿™æ¡è·¯å¾„ä¸Šçš„æ‰€æœ‰æ ‡è®°ä¸¢åˆ°ä¸€ä¸ªçº¿æ€§åŸºé‡Œåšä¸€æ¬¡æŸ¥è¯¢å³å¯ã€‚ å…·ä½“æ¥è®²å°±æ˜¯é€’å½’å¤„ç†åˆ°æŸä¸ªèŠ‚ç‚¹æ—¶å…ˆå¤åˆ¶ä¸€ä»½ä¿®æ”¹å‰çš„çº¿æ€§åŸº(è¿™ä¸€æ­¥O(logn))ï¼Œç„¶åæŠŠå½“å‰èŠ‚ç‚¹ä¸Šçš„æ ‡è®°æ’å…¥åˆ°çº¿æ€§åŸºé‡Œï¼Œé€’å½’å¤„ç†å·¦å³å„¿å­ï¼Œç»“æŸåå†å¤åˆ¶å›æ¥å°±å®ç°äº†çº¿æ€§åŸºçš„æ’¤é”€æ“ä½œã€‚ å¤æ‚åº¦çš„è¯ï¼Œæ¯ä¸ªæ—¶é—´åŒºé—´æœ€å¤šè´¡çŒ® $logn$ ä¸ªæ ‡è®°ï¼Œçº¿æ€§åŸºæ’å…¥å¤æ‚åº¦ $logn$ æ€»å¤æ‚åº¦ $O(nlognlogn)$ã€‚ 123456void solve(int l,int r,linearbase s=linearbase(),int cnt=1){ for(auto x:cov[cnt])s.insert(x); if(l==r){ans[l]=s.query();return;} solve(l,mid,s,ls),solve(mid+1,r,s,rs);} å®Œæ•´ä»£ç : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465struct linearbase{ int a[35]; linearbase(){mst(a,0);} void insert(int x) { fd(i,30,0)if(x&amp;(1&lt;&lt;i)) { if(!a[i]){a[i]=x;break;} else x^=a[i]; } } int query(int ans=0) { fd(i,30,0)if((ans^a[i])&gt;ans)ans^=a[i]; return ans; } void print() { fd(i,30,0)cout&lt;&lt;dbgs2(i,a[i])&lt;&lt;endl; }};int n;int a[MAXN],ans[MAXN];vector&lt;int&gt; cov[MAXN*4];map&lt;int,int&gt; tim,cnt;void cover(int l,int r,int nl,int nr,int val,int cnt){ if(l==nl&amp;&amp;r==nr){cov[cnt].pb(val);return;} if(nr&lt;=mid)cover(l,mid,nl,nr,val,ls); else if(nl&gt;mid)cover(mid+1,r,nl,nr,val,rs); else cover(l,mid,nl,mid,val,ls),cover(mid+1,r,mid+1,nr,val,rs);}void solve(int l,int r,linearbase s=linearbase(),int cnt=1){ for(auto x:cov[cnt])s.insert(x); if(l==r){ans[l]=s.query();return;} solve(l,mid,s,ls),solve(mid+1,r,s,rs);}int work(){ scanf(&quot;%d&quot;,&amp;n); fp(i,1,n) { scanf(&quot;%d&quot;,&amp;a[i]); if(a[i]&gt;0) { if(cnt[a[i]]==0)tim[a[i]]=i; cnt[a[i]]++; } else { cnt[-a[i]]--; if(cnt[-a[i]]==0) cover(1,n,tim[-a[i]],i-1,-a[i],1); } } for(auto x:cnt)if(x.se!=0) cover(1,n,tim[x.fi],n,x.fi,1); solve(1,n); fp(i,1,n)printf(&quot;%d\\n&quot;,ans[i]); return 0;} ä¾‹é¢˜2ï¼šLOJ121 ã€Œç¦»çº¿å¯è¿‡ã€åŠ¨æ€å›¾è¿é€šæ€§ç±»ä¼¼äºä¸Šä¸€é¢˜ï¼Œå°†æ¯æ¡è¾¹çš„å­˜æ´»çš„æ—¶é—´åŒºé—´è¦†ç›–åˆ°çº¿æ®µæ ‘ä¸Šï¼Œæä¸€ä¸ªå¹¶æŸ¥é›†ï¼Œè¿›å…¥æŸä¸ªèŠ‚ç‚¹æ—¶åˆå¹¶ä¸€ä¸‹å½“å‰èŠ‚ç‚¹ä¸Šçš„æ ‡è®°ï¼Œé€’å½’ç»“æŸæ—¶å€’ç€æ’¤é”€æ‰åˆå¹¶æ“ä½œå³å¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int n,m;int f[MAXN],siz[MAXN];vector&lt;pr&gt; cov[N*4];struct query{int t,x,y,ans;}q[N];int find(int x){return x==f[x]?x:find(f[x]);}void merge(int x,int y,vector&lt;pr&gt; &amp;a){ x=find(x),y=find(y);if(x==y)return; if(siz[x]&gt;siz[y])swap(x,y); f[x]=y,siz[y]+=siz[x],a.pb({x,y});}void undo(pr opt){ int x=opt.fi,y=opt.se; f[x]=x,siz[y]-=siz[x];}#define ls (cnt&lt;&lt;1)#define rs (cnt&lt;&lt;1|1)void cover(int l,int r,int nl,int nr,pr e,int cnt){ if(l==nl&amp;&amp;r==nr){cov[cnt].pb(e);return;} if(nr&lt;=mid)cover(l,mid,nl,nr,e,ls); else if(nl&gt;mid)cover(mid+1,r,nl,nr,e,rs); else cover(l,mid,nl,mid,e,ls),cover(mid+1,r,mid+1,nr,e,rs);}void solve(int l,int r,int cnt){ vector&lt;pr&gt; seq; for(auto e:cov[cnt])merge(e.fi,e.se,seq); if(l==r)q[l].ans=(find(q[l].x)==find(q[l].y)); if(l!=r)solve(l,mid,ls),solve(mid+1,r,rs); reverse(all(seq));for(auto x:seq)undo(x);}map&lt;pr,int&gt; tim;int work(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); fp(i,1,n)siz[i]=1,f[i]=i; fp(i,1,m) { scanf(&quot;%d%d%d&quot;,&amp;q[i].t,&amp;q[i].x,&amp;q[i].y); if(q[i].x&gt;q[i].y)swap(q[i].x,q[i].y); pr t={q[i].x,q[i].y}; if(q[i].t==0)tim[t]=i; if(q[i].t==1)cover(1,m,tim[t],i,t,1),tim.erase(t); } for(auto p:tim)cover(1,m,p.se,m,p.fi,1); solve(1,m,1); fp(i,1,m)if(q[i].t==2)puts(q[i].ans?&quot;Y&quot;:&quot;N&quot;); return 0;}","link":"/2020/02/04/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB%E5%B0%8F%E7%BB%93/"},{"title":"Solution for ZZQ&#39;s Catforces","text":"ZZQâ€™s Catforces idea by Nanako &amp; bakapiano prepared by bakapiano &amp; zzq é¢˜æ„æœ¬é¢˜çš„èƒŒæ™¯ä¸ºä¸€ä¸ªç®€åŒ–ç‰ˆçš„ CF èµ›åˆ¶ï¼Œ$n$ é“é¢˜æœ‰ä¸€ä¸ªåˆå§‹åˆ†æ•° $a[i]$ï¼Œæ‰åˆ†é€Ÿåº¦ä¸º $b[i]$/æ¯åˆ†é’Ÿ ä¸ä¸è§£é¢˜æ‰€éœ€æ—¶é—´ $t[i]$ï¼Œè¯·ä½ å®‰æ’ä¸€ä¸ªè§£é¢˜é¡ºåºä½¿å¾—å¾—åˆ†ï¼š score = \\sum_{i=1}^{n} (a_{i} - b_{i}*\\sum_{j=1}^{i}t_{j})æœ€å¤§ã€‚ é¢˜è§£é¢˜ç›®éš¾åº¦ medium- æ³¨æ„åˆ° $\\sum_{i=1}^{n}a_{i}$ é¡¹ä¸è§£é¢˜é¡ºåºæ— å…³ï¼Œæˆ‘ä»¬åªéœ€è¦æœ€å°åŒ–æ€»æ‰åˆ†æ•°å³å¯ã€‚ é¦–å…ˆæˆ‘ä»¬ä»»æ„å®‰æ’ä¸€ä¸ªè§£é¢˜é¡ºåº $p_{1},â€¦,p_{n}$ï¼Œå¹¶å°è¯•å¯¹å½“å‰å¾—åˆ°çš„ç­”æ¡ˆè¿›è¡Œæ”¹è¿›ã€‚è®¾ $p$ æ•°ç»„ä¸­ç›¸é‚»çš„ä¸¤é¡¹ä¸º $x,y(1 \\leq x &lt; y \\leq n)$ï¼Œæ˜“çŸ¥äº¤æ¢ç›¸é‚»ä¸¤é¡¹å¯¹å…¶ä»–é¢˜ç›®çš„å¾—åˆ†æ²¡æœ‰å½±å“(å› ä¸ºå¯¹äºé™¤ $x,y$ çš„ä»»æ„é¢˜ç›® $i$ æ¥è¯´ $\\sum_{j=1}^{i}t_{j}$ ä¸å˜)ï¼Œä¸‹é¢æˆ‘ä»¬æ¥æ¨å¯¼åœ¨ä»€ä¹ˆæƒ…å†µä¸‹äº¤æ¢ $x,y$ ä¸¤é¡¹èƒ½ä½¿å¾—ç­”æ¡ˆå˜å¾—æ›´ä¼˜ã€‚ é¦–å…ˆè®¾ $pre = \\sum_{j=1}^{x-1}t_{j}$ è®¾äº¤æ¢å‰ $x,y$ ä¸¤é¡¹å¯¹ç­”æ¡ˆçš„è´¡çŒ®ï¼š ans_{1}=a_{x}-b_{x}*(pre+t_{x})+a_{y}-b_{y}*(pre+t_{x}+t_{y})äº¤æ¢åçš„è´¡çŒ®ï¼š ans_{2}=a_{y}-b_{y}*(pre+t_{y})+a_{x}-b_{x}*(pre+t_{y}+t_{x})ä½¿ç­”æ¡ˆæ›´ä¼˜çš„æ¡ä»¶ï¼š ans1 < ans2åŒ–ç®€å¯å¾—ï¼š b_{x}*t_{y} t_{y}/b_{y}è®¾$k_{i}=t_{i}/b_{i}$ï¼Œæ³¨æ„åˆ°å½“ $k_{y}&lt;k_{x}$ æ—¶äº¤æ¢ç›¸é‚»ä¸¤é¡¹ä¼šä½¿ç­”æ¡ˆæ›´ä¼˜ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥é€‰æ‹©åºåˆ—ä¸­ $k_{i}$ æœ€å°çš„ä¸€é¡¹å¹¶æŠŠå®ƒä¸æ–­å¾€å‰äº¤æ¢æ¥ä½¿ç­”æ¡ˆå˜çš„æ›´ä¼˜ï¼Œç„¶åé€‰ $k_{i}$ æ¬¡å°çš„ä¸€é¡¹ â€¦ é‡å¤ä¸Šè¿°æ“ä½œç›´è‡³åºåˆ—ä¸­çš„ $k_{i}$ å˜å¾—éé€’å‡ï¼Œæ­¤ä½¿å¾—åˆ°çš„æ’åˆ—ä¾¿æ˜¯æœ€ä¼˜è§£é¢˜é¡ºåºã€‚ å› æ­¤åªéœ€å°†æ‰€æœ‰é¢˜ç›®æŒ‰ $t_{i}/b_{i}$ çš„é¡ºåºæ’åºï¼Œ$O(n)$ è®¡ç®—ç­”æ¡ˆå³å¯ï¼Œæ€»å¤æ‚åº¦ $O(nlogn+n)$ å¯ä»¥åœ¨è§„å®šæ—¶é™å†…é€šè¿‡æœ¬é¢˜ã€‚ tag: è´ªå¿ƒ sort æ ‡ç§°æ³¨æ„ä½¿ç”¨ $double$ è®¡ç®—æ–œç‡å¯èƒ½ä¼šé€ æˆç²¾åº¦è¯¯å·®ï¼Œsort æ—¶ä½¿ç”¨è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°å³å¯é¿å…è¿™ä¸€é—®é¢˜ã€‚ 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt; using namespace std;typedef long long LL;const int MAXN = 1e5+5;/*----------head----------*/int n;struct pro{LL a,b,t;}p[MAXN];LL s[MAXN],ans;int main(){ scanf(&quot;%d&quot;,&amp;n); fp(i,1,n) scanf(&quot;%lld%lld%lld&quot;,&amp;p[i].a,&amp;p[i].b,&amp;p[i].t),ans+=p[i].a; sort(p+1,p+1+n,[](pro a,pro b){return a.t*b.b&lt;b.t*a.b;}); fp(i,1,n) { s[i]=s[i-1]+p[i].t; ans-=s[i]*p[i].b; } printf(&quot;%lld\\n&quot;,ans); return 0;}","link":"/2020/01/16/Solution-for-ZZQ-s-Catforces/"},{"title":"Solution for ZZQ&#39;s Maximum AND","text":"ZZQâ€™s Maximum AND idea by bakapiano prepared by bakapiano é¢˜æ„åœ¨ $n$ ä¸ªæ•°ä¸­é€‰æ°å¥½ $k$ ä¸ªä½¿å¾—è¿™ $k$ ä¸ªæ•° $and$ èµ·æ¥çš„å’Œæœ€å¤§ã€‚ é¢˜è§£é¢˜ç›®éš¾åº¦ easy+ æ³¨æ„åˆ°ä½è¿ç®—æ—¶å„ä½çš„è¿ç®—æ˜¯ç›¸äº’ç‹¬ç«‹çš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°†è¿™ $n$ ä¸ªæ•°æ‹†æˆäºŒè¿›åˆ¶å¹¶ä»é«˜ä½åˆ°ä½ä½ä¾æ¬¡è€ƒè™‘ã€‚å‡è®¾å½“å‰å¤„ç†çš„æ˜¯ç¬¬ $i$ ä½ï¼Œæˆ‘ä»¬é¦–å…ˆç»Ÿè®¡åœ¨äºŒè¿›åˆ¶ä¸‹è¿™ä¸€ä½æ˜¯ $1$ çš„æ•°çš„ä¸ªæ•° $num$ï¼Œç„¶åæˆ‘ä»¬åˆ†ä¸¤ç§æƒ…å†µè¿›è¡Œè®¨è®ºï¼š è‹¥ $k \\leq num$ï¼Œè¯´æ˜å­˜åœ¨ä¸€ç§é€‰æ•°çš„æ–¹æ¡ˆä½¿å¾—è¿™ä¸€ä½æ˜¯ $1$ï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥æŠ›å¼ƒè¿™ä¸€ä½æ˜¯ $0$ çš„é‚£äº›æ•°è€Œä»…ä¿ç•™è¿™ä¸€ä½æ˜¯ $1$ çš„æ•°ï¼Œå¯ä»¥è¿™ä¹ˆåšçš„ä¾æ®æ˜¯å¦‚æœæˆ‘ä»¬é€‰æ‹©äº†æŸä¸€ä¸ªè¯¥ä½æ˜¯ $0$ çš„æ•°ä½œä¸º $k$ ä¸ªæ•°ä¸­çš„ä¸€ä¸ªï¼Œé‚£ä¹ˆè¿™ä¸€ä½ $and$ èµ·æ¥çš„ç»“æœå¿…ç„¶æ˜¯ $0$ï¼Œä½†æ˜¯è€ƒè™‘åˆ°ä½ä½æ— è®ºå¦‚ä½•ç»„åˆéƒ½ä¸å¯èƒ½æ¯”è¿™ä¸€ä½æ˜¯ $1$ çš„ç»“æœæ›´ä¼˜ï¼Œå› æ­¤æˆ‘ä»¬ä¸å¯èƒ½é€‰æ‹©è¿™ä¸€ä½æ˜¯ $0$ çš„é‚£äº›æ•°ä½œä¸ºæˆ‘ä»¬é€‰æ‹©çš„ç»“æœä¹‹ä¸€ã€‚ è‹¥ $k &gt; num$ï¼Œè¯´æ˜æ— è®ºæ€ä¹ˆé€‰è¿™ä¸€ä½ $and$ çš„ç»“æœéƒ½å¿…ä¸º $0$ï¼Œå› æ­¤ä¿ç•™æ‰€æœ‰æ•°å¹¶ç»§ç»­å¤„ç†ä¸‹ä¸€ä½å³å¯ã€‚ æ—¶é—´å¤æ‚åº¦ $O(nlogn)$ï¼Œå¯ä»¥åœ¨è§„å®šæ—¶é™å†…é€šè¿‡æœ¬é¢˜ã€‚ æ­¤å¤–å¯ä»¥è€ƒè™‘ä¸€ä¸‹ $m$ ç»„è¯¢é—®ï¼Œæ¯æ¬¡è¯¢é—®ç»™å‡º $k$ çš„åŠ å¼ºç‰ˆæ€ä¹ˆåšï¼šï¼‰ tag: è´ªå¿ƒ ä½è¿ç®— æ ‡ç§°123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt; using namespace std;const int MAXN = 1e5+5;int n,k;int val[MAXN];int solve(){ int ans=0; vector&lt;int&gt; a,b; for(int i=1;i&lt;=n;i++) a.push_back(val[i]); for(int i=20;i&gt;=0;i--) { int cnt=0; for(auto x:a) if(x&amp;(1&lt;&lt;i)) cnt++; if(cnt&gt;=k) { ans+=(1&lt;&lt;i); b.clear(); for(auto x:a) if(x&amp;(1&lt;&lt;i)) b.push_back(x); swap(a,b); } } return ans;} int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;val[i]); printf(&quot;%d\\n&quot;,solve()); return 0;}","link":"/2020/01/15/Solution-for-ZZQ-s-Maximum-AND-0/"},{"title":"é«˜ç»´å‰ç¼€å’Œ&amp;å­é›†æšä¸¾","text":"å‚è€ƒèµ„æ–™é«˜ç»´å‰ç¼€å’Œæ€»ç»“ heyuhhh å­é›†æšä¸¾$O(4^{n})$ åˆ° $O(3^{n})$ çš„ä¸€ä¸ªä¼˜åŒ–12345678for(int s=0;s&lt;(1&lt;&lt;n);s++){ for(int i=s;;i=(i-1)&amp;s) { //code here... if(!i) break; }} é¦–å…ˆï¼Œå¯¹äºä¸€ä¸ªäºŒè¿›åˆ¶ä¸‹å…¨æ˜¯1çš„æ•°ä¸æ–­å‡1å¯ä»¥éå†ä»–çš„æ‰€æœ‰å­é›†ï¼Œi-1ä¼šæŠŠæœ«å°¾çš„0éƒ½å˜æˆ1ï¼Œè€Œ&amp;såˆ™ä¿è¯äº†åŸå…ˆsä¸Šæ˜¯0çš„ä½ä»æ˜¯0ï¼Œæ•´ä¸ªå¾ªç¯ç›¸å½“äºä¸€ä¸ªå¿½ç•¥sä¸­æ˜¯0çš„ä½è€Œä¸æ–­å‡1çš„è¿‡ç¨‹ã€‚ å¤æ‚åº¦è¯æ˜ é«˜ç»´å‰ç¼€å’Œä¸€ç»´å‰ç¼€å’Œ12for(int i=1;i&lt;=n;i++) a[i]+=a[i-1]; äºŒç»´å‰ç¼€å’Œ123456for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a[i][j]+=a[i-1][j];for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a[i][j]+=a[i][j-1]; ç›¸å½“äºå…ˆå¯¹åˆ—æ±‚å’Œï¼Œåœ¨å¯¹è¡Œæ±‚å’Œ ä¸‰ç»´å‰ç¼€å’Œ123456789101112for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) a[i][j][k]+=a[i-1][j][k];for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) a[i][j][k]+=a[i][j-1][k];for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) a[i][j][k]+=a[i][j][k-1]; å¯ä»¥ç”»ä¸ªå›¾ç†è§£ä¸‹ï¼Œï¼Œï¼Œ Nç»´å‰ç¼€å’Œï¼Ÿä»¿ç…§ä¸Šé¢çš„å†™æ³•ï¼Œ$n$ ä¸ª $n$ é‡å¾ªç¯ï¼Œæ¯æ¬¡å¯¹ä¸€ä¸ªç»´åº¦æ±‚å’Œå³å¯ã€‚ çŠ¶å‹ &amp; ä¸å­é›†æšä¸¾çš„è”ç³»å¯¹äºä¸€ä¸ª $n$ ç»´æ•°ç»„ï¼Œè®¾å®ƒæ‰€æœ‰ç»´åº¦ä¸Šçš„æœ€å¤§å€¼ä¸º $k$ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠ $n$ ç»´ä¸Šçš„æ¯ä¸€ä¸ªç‚¹å‹æˆä¸€ä¸ª $k+1$ è¿›åˆ¶çš„æ•°ï¼Œæ±‚é«˜ç»´å‰ç¼€å’Œæ—¶ç”¨ä¸Šé¢çš„æ–¹æ³•å³å¯ã€‚ äºŒè¿›åˆ¶ä¸­çš„å­é›†å…³ç³»($i \\subset j$)å¯ä»¥çœ‹ä½œæ˜¯æ¯ä¸€ä½ä¸Šçš„ååºå…³ç³»ï¼Œè€Œ $n$ ç»´å‰ç¼€å’Œåˆšå¥½æ˜¯æ»¡è¶³è¿™ç§ååºå…³ç³»çš„ã€‚ æ‰€ä»¥ï¼Œå¯¹äºç±»ä¼¼äºè¿™ç±»é—®é¢˜ï¼š S_i = \\sum_{j\\subset i}A_jF_i = \\min_{}\\{A_j\\}, j\\subset iF_i = \\max_{}\\{A_j\\}, j\\subset iéƒ½å¯ä»¥ä½¿ç”¨é«˜ä½å‰ç¼€å’Œçš„æŠ€å·§å°†å¤æ‚åº¦ç”± $O(3^{n})$ é™åˆ° $O(n*2^{n})$ ä»£ç ä¹Ÿå¾ˆå¥½å†™ï¼š 1234for(int i=1;i&lt;=n;i++) for(int s=0;s&lt;(1&lt;&lt;n);s++) if((1&lt;&lt;(i-1))&amp;s) f[i]+=f[s^(1&lt;&lt;(i-1))]; ä¾‹é¢˜1.CF1221G Graph And Numbersé¢˜è§£å…ˆå‘ç€ï¼Œï¼Œï¼Œ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132LL n,m,c;vector&lt;int&gt; G[MAXN]; LL fpow(LL x,LL k){ LL ans=1; while(k) { if(k&amp;1) ans=ans*x; x=x*x,k=k&gt;&gt;1; } return ans;} namespace paint{ bool flag=1; int col[MAXN]; void dfs(int u) { for(auto v:G[u]) { if(!col[v]) col[v]=-col[u],dfs(v); else if(col[u]+col[v]!=0) flag=0; } } LL solve() { fp(i,1,n)if(!col[i])c++,col[i]=1,dfs(i); //fp(i,1,n)cout &lt;&lt; dbgs2(i,col[i]) &lt;&lt; endl; return flag?fpow(2,c):0; }} LL solve0() //åªæœ‰0{ int cnt=0; fp(i,1,n)if(G[i].size()==0)cnt++;//,cout&lt;&lt;dbgs(i)&lt;&lt;endl; return fpow(2,cnt);} LL solve1() //åªæœ‰1{ return paint::solve();} LL solve2() //åªæœ‰2{ return solve0();} bool check1(int s){ fp(u,1,n/2)for(auto v:G[u])if(v&lt;=n/2) { bool a=(1&lt;&lt;(u-1))&amp;s,b=(1&lt;&lt;(v-1))&amp;s; if(a&amp;&amp;b) return 0; } return 1;} bool check2(int s){ fp(u,n/2+1,n)for(auto v:G[u])if(v&gt;n/2) { bool a=(1&lt;&lt;(u-n/2-1))&amp;s,b=(1&lt;&lt;(v-n/2-1))&amp;s; if(a&amp;&amp;b) return 0; } return 1;} LL f[1&lt;&lt;25];LL solve01() //åªæœ‰0 1{ LL ans=0; mst(f,0); fp(s,0,(1&lt;&lt;(n/2))-1) f[s]+=check1(s);//,cout&lt;&lt;dbgs2(bitset&lt;3&gt;(s),f[s])&lt;&lt;endl; fp(i,1,n/2)fp(s,0,(1&lt;&lt;(n/2))-1) if((1&lt;&lt;(i-1))&amp;s) f[s]+=f[s^(1&lt;&lt;(i-1))]; //cout &lt;&lt; endl; fp(s,0,(1&lt;&lt;(n/2))-1) cout&lt;&lt;dbgs2(bitset&lt;3&gt;(s),f[s])&lt;&lt;endl; fp(s,0,(1&lt;&lt;(n-n/2))-1)if(check2(s)) { int t=(1&lt;&lt;(n/2))-1; fp(u,n/2+1,n)if((1&lt;&lt;(u-n/2-1))&amp;s)for(auto v:G[u])if(v&lt;=n/2&amp;&amp;t&amp;(1&lt;&lt;(v-1))) t-=(1&lt;&lt;(v-1)); ans+=f[t]; } return ans;} LL solve02() //åªæœ‰0 2{ return fpow(2,c);} LL solve12() //åªæœ‰1 2{ return solve01();} int work(){ scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); if(m==0) return printf(&quot;0&quot;); fp(i,1,m) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); G[u].pb(v),G[v].pb(u); } LL ans=0; ans+=fpow(2,n);/* cout &lt;&lt; dbgs(solve0() ) &lt;&lt; endl; cout &lt;&lt; dbgs(solve1() ) &lt;&lt; endl; cout &lt;&lt; dbgs(solve2() ) &lt;&lt; endl; cout &lt;&lt; dbgs(solve01()) &lt;&lt; endl; cout &lt;&lt; dbgs(solve02()) &lt;&lt; endl; cout &lt;&lt; dbgs(solve12()) &lt;&lt; endl;*/ ans+=solve0(); ans+=solve1(); ans+=solve2(); ans-=solve01(); ans-=solve02(); ans-=solve12(); return printf(&quot;%lld\\n&quot;,ans);} 2.CF449D Jzzhu and Numbersé¢˜æ„ï¼š ç»™å®šæ•°åˆ— $a_{1}â€¦a_{n}$ï¼Œè®¡ç®—ä»ä¸­å–ä¸€æ®µå­åºåˆ—ä½¿å…¶ $And$ èµ·æ¥çš„å’Œä¸º $0$ çš„æ–¹æ¡ˆæ•°ã€‚ SOL: è€ƒè™‘å®¹æ–¥è®¡ç®—ä¸åˆæ³•çš„æ–¹æ¡ˆæ•°ï¼Œ$And$ åæœ‰ä¸€ä½ä¸º1çš„æ–¹æ¡ˆæ•° - æœ‰ä¸¤ä½ä¸º1çš„æ–¹æ¡ˆæ•°â€¦ ç„¶åè€ƒè™‘å¦‚ä½•è®¡ç®— $n$ ä½ä¸º1çš„æ–¹æ¡ˆæ•°ï¼Œè®¾ $f[s]$ ç­‰äºæ»¡è¶³ä¸‹é¢æ¡ä»¶çš„ $a_{i}$ çš„ä¸ªæ•°ï¼š $s$ ä¸º1çš„äºŒè¿›åˆ¶ä½ä¸Š $a_{i}$ ä¹Ÿä¸º1 å…¶ä»–ä½ä¸Šä»»æ„ å¯ä»¥å‘ç°è¿™æ˜¯ä¸ªè¶…é›†(å–ååçš„å­é›†)ï¼Œæ±‚å‡º $f$ æ•°ç»„åå°±å¯ä»¥æ„‰å¿«çš„å®¹æ–¥è¾£ 123456789101112131415161718192021222324252627282930313233343536373839int lowbit(int x){return x&amp;-x;}int bitcount(int x,int cnt=0){while(x)x-=lowbit(x),cnt++;return cnt;} const LL MOD = 1000000007;LL fpow(LL x,LL k){ LL ans=1; while(k) { if(k&amp;1) ans=ans*x%MOD; x=x*x%MOD,k=k&gt;&gt;1; } return ans;}LL C(LL n,LL m){ if(n&lt;m) return 0; LL s1=1,s2=1; for(LL i=1;i&lt;=m;i++) s1=s1*((n-i+1)%MOD)%MOD; for(LL i=1;i&lt;=m;i++) s2=s2*i%MOD; return s1*fpow(s2,MOD-2)%MOD;} int n;LL s,f[MAXN],ans=0; int work(){ scanf(&quot;%d%lld&quot;,&amp;n,&amp;s); fp(i,1,n)scanf(&quot;%lld&quot;,&amp;f[i]); for(int k=0;k&lt;(1&lt;&lt;n);k++) { LL sum=s+n; for(int i=1;i&lt;=n;i++)if((1&lt;&lt;(i-1))&amp;k)sum-=f[i]+1; ans+=pow(-1,bitcount(k))*C(sum-1,n-1); ans%=MOD,ans+=MOD,ans%=MOD; } return printf(&quot;%lld\\n&quot;,ans);} 3.CF1234F Yet Another Substring Reverseé¢˜æ„ï¼š ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä½ å¯ä»¥ç¿»è½¬ä¸€æ®µå­ä¸²(æˆ–è€…ä¸)ï¼Œä¹‹åæ±‚åŸå­—ç¬¦ä¸²ä¸­æ»¡è¶³å­—ç¬¦ä¸¤ä¸¤ä¸åŒçš„å­ä¸²çš„æœ€é•¿é•¿åº¦ã€‚ å­—ç¬¦åªæœ‰ â€˜aâ€™~â€™tâ€™ (20ä¸ª) SOLï¼š é¦–å…ˆè€ƒè™‘ä¸€ä¸‹æ‰§è¡Œç¿»è½¬æ“ä½œåç­”æ¡ˆé•¿å•¥æ ·ï¼Œä¸€å®šæ˜¯ä¸€æ®µæ²¡ç¿»è½¬æ‹¼ä¸Šä¸€æ®µç¿»è½¬è¿‡çš„ï¼Œæ‰€ä»¥å¯ä»¥å°†é—®é¢˜è½¬åŒ–ä¸º é€‰ä¸¤ä¸ªå­ä¸²æ‹¼èµ·æ¥å¾—åˆ°ä¸€ä¸ªæ–°ä¸²ä¸”æ»¡è¶³å­—ç¬¦ä¸¤ä¸¤ä¸åŒï¼Œæ±‚è¿™ä¸ªæ–°ä¸²æœ€é•¿æ˜¯å¤šå°‘ã€‚ è€ƒè™‘çŠ¶å‹ï¼Œ$s$äºŒè¿›åˆ¶ä½ä¸Šçš„1/0ä»£è¡¨è¿™ä¸ªå­—ç¬¦å‡ºç°/æ²¡å‡ºç°ã€‚è‹¥ $i$ æƒ³å’Œ $s$ æ‹¼åˆ°ä¸€èµ·çš„è¯ï¼Œ $s$ æ˜¯1çš„ä½ç½®ä¸Š $i$ ä¸èƒ½æ˜¯1ï¼Œè€Œå…¶ä»–ä½ä¸Šæ²¡æœ‰é™åˆ¶ï¼Œç”¨é«˜ç»´å‰ç¼€å’Œå¤„ç†å‡ºæ»¡è¶³ä¸Šè¿°æ¡ä»¶çš„å­ä¸²çš„æœ€é•¿é•¿åº¦ $f[i]$ ä¹‹åæš´åŠ›æšä¸¾å³å¯ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738int n;int f[1&lt;&lt;21],g[1&lt;&lt;21];char s[MAXN]; int lowbit(int x){return x&amp;-x;}int bitcount(int x){ int cnt=0; while(x) x-=lowbit(x),cnt++; return cnt;}void in(int f[],int pos,int len){ int t=0; for(int i=pos;i&lt;pos+len;i++) { int c=s[i]-'a'; if((1&lt;&lt;c)&amp;t) return; t|=(1&lt;&lt;c); } f[t]=bitcount(t);} int work(){ scanf(&quot;%s&quot;,s+1),n=strlen(s+1); fd(i,n,1)fp(l,1,min(n-i,20))in(f,i+1,l); fp(i,0,19)fp(j,0,(1&lt;&lt;20)-1) if((1&lt;&lt;i)&amp;j) f[j]=max(f[j],f[j-(1&lt;&lt;i)]); reverse(s+1,s+1+n); fd(i,n,1)fp(l,1,min(n-i,20))in(g,i+1,l); int ans=1; fp(s,0,(1&lt;&lt;20)-1) if(g[s]) ans=max(ans,f[((1&lt;&lt;20)-1)^s]+bitcount(s)); return printf(&quot;%d\\n&quot;,ans);} é¢˜å¤–è¯ï¼šæœ‰ç”Ÿä¹‹å¹´ç»ˆäºAKäº†DIV3","link":"/2019/10/03/%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C-%E5%AD%90%E9%9B%86%E6%9E%9A%E4%B8%BE/"},{"title":"SAM åç¼€è‡ªåŠ¨æœºå°ç»“","text":"åç¼€è‡ªåŠ¨æœºèµ„æ–™ é™ˆç«‹æ°å†¬ä»¤è¥SAMè®²ç¨¿ åç¼€è‡ªåŠ¨æœºï¼ˆSAMï¼‰å­¦ä¹ ç¬”è®° ouuan OI wiki SAM åç¼€è‡ªåŠ¨æœºå­¦ä¹ ç¬”è®° Menci ç¬”è®°åç¼€è‡ªåŠ¨æœºä¸Šæ¯ä¸ªç‚¹ä»£è¡¨çš„æ˜¯ä¸€äº› $endpos$ ç›¸åŒä¸”é•¿åº¦è¿ç»­çš„ä¸€äº›å­—ç¬¦ä¸²ï¼ŒçŠ¶æ€ $u$ è¡¨ç¤ºçš„å­—ç¬¦ä¸²çš„é•¿åº¦èŒƒå›´ä¸º $[min(u),max(v)]$ æ¯ä¸ªç»“ç‚¹çš„ $par$ æ˜¯æ‰€æœ‰æ»¡è¶³ $endpos[u] \\in endpos[v]$ çš„ $v$ ä¸­ä¸” $endpos[v]$ å¤§å°æœ€å°çš„çŠ¶æ€ $v$ã€‚ æœ‰å…³ $par$ çš„ä¸€äº›æ€§è´¨ï¼š $min(u)=max(par[u])+1$ $par[u]$ æ‰€è¡¨ç¤ºçš„å­—ç¬¦ä¸²éƒ½æ˜¯ $u$ çš„åç¼€ã€‚ è‡ªåŠ¨æœºæ¥å—çš„å­—ç¬¦ä¸²ä¸º $S$ çš„æ‰€æœ‰å­ä¸²ã€‚ è¡¨ç¤ºå­—ç¬¦ä¸²å‰ç¼€ $Pre$ çš„çŠ¶æ€ $u$ çš„ $max(u) = |Pre|$ï¼Œä» $u$ è·³ $par$ çš„è¯å¯ä»¥éå† $Pre$ çš„æ‰€æœ‰åç¼€ã€‚ æ¨¡æ¿123456789101112131415161718192021222324252627282930313233343536373839404142434445464748namespace SAM{ int cnt=0,root,last; int len[MAXN*2],par[MAXN*2]; LL sum[MAXN*2]; map&lt;char,int&gt; nx[MAXN*2]; void newnode(int &amp;x) { x=++cnt; len[cnt]=par[cnt]=sum[cnt]=0; nx[cnt].clear(); } void init(){cnt=0,newnode(root),last=root;} void extend_sam(char c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; nx [n]=nx [q]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur,sum[cur]=1; } void build_sam(char s[]) { int n=strlen(s+1); for(int i=1;i&lt;=n;i++) extend_sam(s[i]);//,debug(); }}; æŠ€å·§ &amp; åº”ç”¨æ±‚ $endpos$ é›†åˆçš„å¤§å°/æœ€å¤§å€¼/æœ€å°å€¼è€ƒè™‘ $par$ æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œ$endpos$ ä¸­ å«æœ‰ $i$ çš„æ·±åº¦æœ€å¤§çš„èŠ‚ç‚¹ä¸€å®šæ˜¯è¡¨ç¤ºå‰ç¼€ $Pre_{i}$ çš„çŠ¶æ€ï¼Œæ ‡è®°è¿™ä¸ªèŠ‚ç‚¹åç”¨ dfs/æ‹“æ‰‘/åŸºæ’ é€†æ¨å³å¯ã€‚ å¦‚æœè¦æ±‚æ¯ä¸ªç‚¹ $endpos$ çš„å…·ä½“å€¼å¯èƒ½éœ€è¦ çº¿æ®µæ ‘åˆå¹¶/å¹³è¡¡æ ‘å¯å‘å¼åˆå¹¶ã€‚ 1234567891011121314151617int seq[MAXN*2],buc[N];void sort_by_len(){ fp(i,1,cnt) buc[len[i]]++; fp(i,1,N-1) buc[i]+=buc[i-1]; fp(i,1,cnt) seq[buc[len[i]]--]=i;}void solve(){ fp(i,1,cnt) { int cur=seq[i]; f[par[cur]]+=f[cur]; //f[par[cur]]=min(f[par[cur]],f[cur]); //f[par[cur]]=max(f[par[cur]],f[cur]); }} $logn$ æŸ¥æ‰¾æŸä¸ªå­ä¸²åœ¨ $SAM$ ä¸Šå¯¹åº”çš„çŠ¶æ€è€ƒè™‘å€å¢ï¼Œé¢„å¤„ç†å‡ºæ¯ä¸ªèŠ‚ç‚¹åœ¨ $par$ æ ‘ä¸Šçš„$2^j$ ç¥–å…ˆï¼Œä»è¡¨ç¤º $S[1â€¦r]$ çš„å¶å­å¾€ä¸Šè·³æ‰¾åˆ°æ·±åº¦æœ€å°ä¸”æ»¡è¶³ $max(u)&gt;=(r-l+1)$çš„ $u$ å³å¯ã€‚ 1234567891011121314void init(){ for(int i=1;i&lt;=cnt;i++) nx[i][0]=par[i]; fp(k,1,20)fp(i,1,cnt)nx[i][k]=nx[nx[i][k-1]][k-1];}LL count(int l,int r){ int cur=suf[r]; fd(k,20,0) if(nx[cur][k]&amp;&amp;len[nx[cur][k]]&gt;=r-l+1) cur=nx[cur][k]; return sum[cur];} ä¸¤ä¸ªä¸²çš„LCSå¯¹ $S$ ä¸²å»ºç«‹ $SAM$ï¼Œæ‹¿ $T$ ä¸²åˆ° $SAM$ ä¸Šâ€œè¿è¡Œâ€ å…·ä½“æ¥è®²å°±æ˜¯è€ƒè™‘ $T$ çš„æ¯ä¸ªå‰ç¼€ $pre_{i}$ æœ‰å¤šé•¿çš„åç¼€æ˜¯ $S$ çš„ä¸€ä¸ªå­ä¸²ï¼Œä» $pre_{i}$ è½¬ç§»åˆ° $pre_{i+1}$ æ—¶çœ‹ä¸‹å½“å‰çŠ¶æ€æ˜¯å¦å­˜åœ¨åˆ° $T[i+1]$ çš„è½¬ç§»è¾¹ï¼Œè‹¥ä¸å­˜åœ¨å°±ä¸æ–­è·³ $par$ (åˆ æ‰å‰é¢çš„ä¸€éƒ¨åˆ†) ç›´åˆ°æ‰¾åˆ°å­˜åœ¨è½¬ç§»è¾¹çš„çŠ¶æ€ï¼ŒåŒæ—¶ç»´æŠ¤åœ¨æ¯ä¸ªçŠ¶æ€ä¸‹çš„åŒ¹é…é•¿åº¦ï¼Œæœ€åå–ä¸ª $max$ å°±æ˜¯ç­”æ¡ˆã€‚ åŒ¹é…è¿‡ç¨‹ååˆ†ç±»ä¼¼äº $kmp$ å’Œ $AC$è‡ªåŠ¨æœº å•Šï¼Œï¼Œï¼Œ 12345678910111213void solve(char s[]){ int L=0,ans=0,cur=root,n=strlen(s+1); for(int i=1;i&lt;=n;i++) { int c=s[i]-'a'; while(cur!=root&amp;&amp;!nx[cur][c]) cur=par[cur],L=len[cur]; if(nx[cur][c]) cur=nx[cur][c],L++; ans=max(ans,L); } printf(&quot;%d\\n&quot;,ans);} æœ¬è´¨ä¸åŒçš„å­ä¸²ä¸ªæ•°ç›¸åŒçš„å­ä¸²ä¸€å®šè¢«åŒä¸€ä¸ªçŠ¶æ€æ‰€è¡¨ç¤ºï¼Œæ‰€ä»¥å¯¹åç¼€è‡ªåŠ¨æœºä¸Šæ¯ä¸ªçŠ¶æ€æ‰€è¡¨ç¤ºçš„å­ä¸²é•¿åº¦æ±‚å’Œå³æ˜¯ç­”æ¡ˆã€‚ ans = \\sum_{i=1}^{cnt}len[i]-len[par[i]]æœ€å°è¡¨ç¤ºæ³•å…ˆå°†å­—ç¬¦ä¸² $S$ å¤åˆ¶ä¸€å€åå¾—åˆ° $T$ï¼Œå¯ä»¥å‘ç° $T$ çš„é•¿åº¦ä¸º $n$ çš„å­ä¸²åŒ…å«äº† $S$ é€šè¿‡å¾ªç¯ç§»ä½æ‰€èƒ½å¾—åˆ°çš„æ‰€æœ‰å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥é—®é¢˜è½¬åŒ–ä¸ºæ±‚ $T$ çš„é•¿åº¦ä¸º $n$ çš„å­ä¸²ä¸­å­—å…¸åºæœ€å°çš„ä¸€ä¸ªã€‚ å¯¹ $T$ å»ºç«‹ $SAM$ åä» $root$ å¼€å§‹è´ªå¿ƒèµ°è½¬ç§»è¾¹ä¸­å­—ç¬¦æœ€å°çš„é‚£æ¡å³å¯ã€‚ å­—å…¸åºkå¤§å­ä¸²ç»Ÿè®¡å‡ºåœ¨æ¯ä¸ªçŠ¶æ€é€šè¿‡è½¬ç§»è¾¹èƒ½åˆ°è¾¾çš„çŠ¶æ€çš„æ•°é‡ $f[u]$ ï¼Œä»æ ¹èŠ‚ç‚¹å¼€å§‹ä»å°åˆ°å¤§æšä¸¾è½¬ç§»è¾¹ $v$ è‹¥ $f[v]&gt;=k$ åˆ™ä» $u$ è½¬ç§»åˆ° $v$ï¼Œå¦åˆ™å°† $k$ å‡å» $f[v]$ åç»§ç»­å°è¯•å­—ç¬¦æ›´å¤§çš„è½¬ç§»è¾¹ã€‚ 12345678910111213141516171819202122232425262728293031323334void print(int cur,int k,int t,LL f[]){ if(!k) return; for(auto trans:nx[cur]) { if(f[trans.se]&gt;=k) { putchar(trans.fi),print(trans.se,k-(t?sum[trans.se]:1),t,f); break; } else k-=f[trans.se]; }}void solve(int k,int t){ fp(i,1,cnt) buc[len[i]]++; fp(i,1,N-1) buc[i]+=buc[i-1]; fp(i,1,cnt) seq[buc[len[i]]--]=i; fd(i,cnt,1) sum[par[seq[i]]]+=sum[seq[i]]; fd(i,cnt,1) { int cur=seq[i]; f[0][cur]=1,f[1][cur]=sum[cur]; for(auto trans:nx[cur]) { f[0][cur]+=f[0][trans.se]; f[1][cur]+=f[1][trans.se]; } } if(f[t][root]-(t==1?sum[root]:1)&lt;k) printf(&quot;-1\\n&quot;); else print(root,k,t,f[t]),putchar('\\n');} å¤šä¸ªä¸²çš„LCSå¯¹å…¶ä¸­ä¸€ä¸ªä¸²å»ºç«‹ $SAM$ æŠŠå‰©ä¸‹æ‰€æœ‰ä¸²æ”¾åˆ° $SAM$ ä¸Šè¿è¡Œï¼Œç±»ä¼¼äºæ±‚ä¸¤ä¸ªä¸²çš„ $LCS$ çš„è¿‡ç¨‹ï¼Œè¿è¡Œæ¯ä¸€ä¸ªä¸²çš„æ—¶å€™è®°å½•å®ƒåœ¨å½“å‰çŠ¶æ€ä¸Šçš„æœ€å¤§åŒ¹é…é•¿åº¦ï¼Œæ³¨æ„ä¸åŒä¸²åœ¨åŒä¸€ä¸ªçŠ¶æ€ä¸Šçš„åŒ¹é…é•¿åº¦è¦å– $min$,æœ€åç»Ÿè®¡ç­”æ¡ˆå³å¯ã€‚ 1234567891011121314151617181920212223242526void run(string &amp;s,int id){ mst(f,0); int cur=root,L=0; fp(i,0,s.size()-1) { int c=s[i]-'a'; while(cur!=root&amp;&amp;!nx[cur][c]) cur=par[cur],L=len[cur]; if(nx[cur][c]) cur=nx[cur][c],L++; f[cur]=max(f[cur],L); } fd(i,cnt,1) { int cur=seq[i]; if(f[cur]) f[par[cur]]=len[par[cur]]; } if(id==2) fp(i,1,cnt) ans[i]=f[i]; else fp(i,1,cnt) ans[i]=min(ans[i],f[i]);}void solve(){ int L=0; fp(i,1,cnt) L=max(ans[i],L); cout &lt;&lt; L &lt;&lt; endl;} å¹¿ä¹‰SAMå°† $SAM$ æ¨å¹¿åˆ°å­—å…¸æ ‘ä¸Šçš„äº§ç‰©ï¼Œç›®å‰ä¸å¤ªç†è§£ï¼Œï¼Œï¼Œ å®šä¹‰ $Trie$ æ ‘çš„ä¸€ä¸ªå­ä¸²ä¸ºèŠ‚ç‚¹ $u$ åˆ°å®ƒå­æ ‘ä¸­çš„èŠ‚ç‚¹ $v$ çš„è·¯å¾„æ‰€å½¢æˆçš„å­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆå¹¿ä¹‰ $SAM$ æ¥å—çš„çŠ¶æ€ä¸º $Tire$ æ ‘ä¸Šçš„æ‰€æœ‰å­ä¸²ã€‚ $endpos$ å¯è§†ä¸º $Trie$ æ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œ$par$ çš„å®šä¹‰ä¸å˜ã€‚ æ¨¡æ¿ç¦»çº¿æ„é€ ï¼Œéœ€è¦é¢„å…ˆçŸ¥é“ $Tire$ æ ‘çš„å½¢æ€ï¼Œä»æ ¹èŠ‚ç‚¹å¼€å§‹ $bfs$ï¼Œå»ºç«‹æ–°èŠ‚ç‚¹æ—¶æ‹¿ä»–çˆ¶äº²çš„çŠ¶æ€ä½œä¸º $last$ æ‰§è¡Œæ™®é€š $SAM$ çš„ $extend$ å³å¯ã€‚ è¿˜æœ‰ä¸€ç§åšæ³•æ˜¯æ¯æ’å…¥ä¸€ä¸ªä¸²å°±æŠŠ $last$ æŒ‡å‘ $root$ï¼Œä½†è¿™æ ·å¯èƒ½å»ºå‡ºä¸€äº›æ— ç”¨çš„èŠ‚ç‚¹(è€ƒè™‘ä¸€ä¸ªå­—ç¬¦ä¸²å®Œå…¨åŒ…å«å¦ä¸€ä¸ªçš„æƒ…å†µ)ã€‚ [ZJOI2015]è¯¸ç¥çœ·é¡¾çš„å¹»æƒ³ä¹¡ æ±‚å¤šä¸ªä¸²æœ¬è´¨ä¸åŒçš„å­ä¸²ä¸ªæ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103const int K = 10;namespace SAM{ int root,cnt; int len[MAXN*2],par[MAXN*2]; int nx[MAXN*2][K+1]; void newnode(int &amp;x){x=++cnt;} void init(){cnt=0,newnode(root);} int extend(int c,int last) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; memcpy(nx[n],nx[q],sizeof(nx[q])); while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } return cur; } void solve() { LL ans=0; fp(i,1,cnt) ans+=len[i]-len[par[i]]; io.write(ans); io.push('\\n'); }}namespace Trie{ int root,cur,cnt; int nx[MAXN][K+1],fa[MAXN],last[MAXN]; void newnode(int &amp;x){x=++cnt;} void init(){cnt=0,newnode(root),cur=root;} void insert(int c) { if(!nx[cur][c]) newnode(nx[cur][c]),fa[nx[cur][c]]=cur; cur=nx[cur][c]; } void back(){cur=fa[cur];} void build_sam() { SAM::init(); queue&lt;int&gt; q; q.push(root); last[root]=SAM::root; while(!q.empty()) { int cur=q.front(); q.pop(); fp(i,0,K)if(nx[cur][i]) last[nx[cur][i]]=SAM::extend(i,last[cur]), q.push(nx[cur][i]); } }};struct edge{int u,v,next;};vector&lt;edge&gt; e;int n,c;int pre[MAXN],col[MAXN],in[MAXN];void addedge(int u,int v){e.pb({u,v,pre[u]}),pre[u]=e.size()-1;}void dfs(int u,int fa){ Trie::insert(col[u]); go(u) if(v!=fa) dfs(v,u); Trie::back();}int work(){ io.read(n),io.read(c),e.pb(edge()); fp(i,1,n) io.read(col[i]); fp(i,1,n-1) { static int u,v; io.read(u),io.read(v); addedge(u,v),addedge(v,u); in[u]++,in[v]++; } Trie::init(); fp(i,1,n) if(in[i]==1) dfs(i,-1); Trie::build_sam(); SAM::solve(); return 0;} ç»ƒä¹ Luogu P3804 ã€æ¨¡æ¿ã€‘åç¼€è‡ªåŠ¨æœºç»Ÿè®¡æ¯ä¸ªçŠ¶æ€ $u$ çš„ $endpos$ é›†åˆçš„å¤§å° $siz[u]$ï¼Œæ‰€æœ‰çš„ $siz[u]*len[u]$ å–ä¸ª $max$ å°±æ˜¯ç­”æ¡ˆ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990namespace SAM{ int cnt=0,root,last; int len[MAXN*2],par[MAXN*2]; LL sum[MAXN*2]; map&lt;char,int&gt; nx[MAXN*2]; void debug() { cout &lt;&lt; dbgs2(root,last) &lt;&lt; endl; for(int i=1;i&lt;=cnt;i++) { cout &lt;&lt; dbgs3(i,len[i],par[i]) &lt;&lt; endl; for(auto t:nx[i]) cout &lt;&lt; dbgs2(t.fi,t.se) &lt;&lt; endl; } cout &lt;&lt; endl; } void newnode(int &amp;x) { x=++cnt; len[cnt]=par[cnt]=sum[cnt]=0; nx[cnt].clear(); } void init(){cnt=0,newnode(root),last=root;} void extend_sam(char c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; nx [n]=nx [q]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur,sum[cur]=1; } void build_sam(char s[]) { int n=strlen(s+1); for(int i=1;i&lt;=n;i++) extend_sam(s[i]);//,debug(); }};char s[MAXN];struct edge{int u,v,next;};vector&lt;edge&gt; e={edge()};int pre[MAXN*2];void addedge(int u,int v){e.pb({u,v,pre[u]}),pre[u]=e.size()-1;}LL ans=0;void dfs(int u){ go(u) dfs(v),SAM::sum[u]+=SAM::sum[v]; //cout &lt;&lt; dbgs3(u,SAM::len[u],SAM::sum[u]) &lt;&lt; endl; if(SAM::sum[u]&gt;1) ans=max(ans,SAM::len[u]*SAM::sum[u]);}void solve(){ fp(i,2,SAM::cnt) addedge(SAM::par[i],i); dfs(1);}int work(){ scanf(&quot;%s&quot;,s+1); SAM::init(); SAM::build_sam(s); solve(); printf(&quot;%lld\\n&quot;,ans); return 0;} Luogu P1368 å·¥è‰ºæ±‚å­—ç¬¦ä¸²çš„æœ€å°è¡¨ç¤ºæ³• 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172namespace SAM{ const int K = 26; int cnt=0,root,last; int len[MAXN*2],par[MAXN*2]; map&lt;int,int&gt; nx[MAXN*2]; void newnode(int &amp;x) { x=++cnt; len[cnt]=par[cnt]=0; nx[cnt].clear(); } void init(){cnt=0,newnode(root),last=root;} void extend_sam(int c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; nx [n]=nx [q]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur; } void build_sam(int s[],int n){fp(i,1,n) extend_sam(s[i]);} void solve(int n) { int cur=root; while(n--) { io.write((nx[cur].begin())-&gt;fi); io.push(' '); cur=(nx[cur].begin())-&gt;se; } io.push('\\n'); }}int n;int s[MAXN];int work(){ io.read(n); fp(i,1,n) io.read(s[i]),s[i+n]=s[i]; n*=2; SAM::init(); SAM::build_sam(s,n); SAM::solve(n/2); return 0;} luogu P3804 ã€æ¨¡æ¿ã€‘åç¼€è‡ªåŠ¨æœº ç»Ÿè®¡ $endpos$ é›†åˆçš„å¤§å°ï¼Œæ‰¾åˆ°æœ€å¤§çš„ $sum[i]*len[i]$ å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990namespace SAM{ int cnt=0,root,last; int len[MAXN*2],par[MAXN*2]; LL sum[MAXN*2]; map&lt;char,int&gt; nx[MAXN*2]; void debug() { cout &lt;&lt; dbgs2(root,last) &lt;&lt; endl; for(int i=1;i&lt;=cnt;i++) { cout &lt;&lt; dbgs3(i,len[i],par[i]) &lt;&lt; endl; for(auto t:nx[i]) cout &lt;&lt; dbgs2(t.fi,t.se) &lt;&lt; endl; } cout &lt;&lt; endl; } void newnode(int &amp;x) { x=++cnt; len[cnt]=par[cnt]=sum[cnt]=0; nx[cnt].clear(); } void init(){cnt=0,newnode(root),last=root;} void extend_sam(char c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; nx [n]=nx [q]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur,sum[cur]=1; } void build_sam(char s[]) { int n=strlen(s+1); for(int i=1;i&lt;=n;i++) extend_sam(s[i]);//,debug(); }};char s[MAXN];struct edge{int u,v,next;};vector&lt;edge&gt; e={edge()};int pre[MAXN*2];void addedge(int u,int v){e.pb({u,v,pre[u]}),pre[u]=e.size()-1;}LL ans=0;void dfs(int u){ go(u) dfs(v),SAM::sum[u]+=SAM::sum[v]; //cout &lt;&lt; dbgs3(u,SAM::len[u],SAM::sum[u]) &lt;&lt; endl; if(SAM::sum[u]&gt;1) ans=max(ans,SAM::len[u]*SAM::sum[u]);}void solve(){ fp(i,2,SAM::cnt) addedge(SAM::par[i],i); dfs(1);}int work(){ scanf(&quot;%s&quot;,s+1); SAM::init(); SAM::build_sam(s); solve(); printf(&quot;%lld\\n&quot;,ans); return 0;} SPOJ 1811 LCSä¸¤ä¸ªä¸²çš„ $LCS$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576namespace SAM{ int cnt=0,root,last; int len[MAXN*2],par[MAXN*2]; int nx[MAXN*2][K]; void newnode(int &amp;x) { x=++cnt; len[cnt]=par[cnt]=0; for(int i=0;i&lt;K;i++) nx[cnt][i]=0; } void init(){cnt=0,newnode(root),last=root;} void extend_sam(int c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; for(int i=0;i&lt;K;i++) nx[n][i]=nx[q][i]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur; } void build_sam(char s[]) { int n=strlen(s+1); for(int i=1;i&lt;=n;i++) extend_sam(s[i]-'a'); } void solve(char s[]) { int L=0,ans=0,cur=root,n=strlen(s+1); for(int i=1;i&lt;=n;i++) { int c=s[i]-'a'; while(cur!=root&amp;&amp;!nx[cur][c]) cur=par[cur],L=len[cur]; if(nx[cur][c]) cur=nx[cur][c],L++; ans=max(ans,L); } printf(&quot;%d\\n&quot;,ans); }};char a[MAXN],b[MAXN];int work(){ scanf(&quot;%s&quot;,a+1); scanf(&quot;%s&quot;,b+1); SAM::init(); SAM::build_sam(a); SAM::solve(b); return 0;} Luogu P3649 [APIO2014]å›æ–‡ä¸²é©¬æ‹‰è½¦ + SAMä¸Šå€å¢ å…¶å®æ˜¯PAMæ¨¡æ¿é¢˜ é¦–å…ˆè€ƒè™‘å¦‚ä½•ç”¨é©¬æ‹‰è½¦æ±‚å‡ºæœ¬è´¨ä¸åŒçš„å›æ–‡ä¸²ï¼Œå¯ä»¥å‘ç°å½“æ‰©å±•æœ€é•¿å›æ–‡ä¸²çš„å³è¾¹ç•Œæ—¶æ‰ä¼šäº§ç”Ÿæ–°çš„å›æ–‡ä¸²ï¼Œç”¨ $SAM$ ç»Ÿè®¡å‡ºç°æ¬¡æ•°å³å¯ã€‚ æ³¨æ„æ‰©å±•å³è¾¹ç•Œæ—¶å¾—åˆ°çš„å›æ–‡ä¸²ä¸ä¸€å®šå°±åœ¨ä¹‹å‰ä»æœªå‡ºç°è¿‡ï¼Œå¦‚ $abadeaba$ï¼Œæ‰€ä»¥ç”¨é©¬æ‹‰è½¦æ±‚æœ¬è´¨ä¸åŒå›æ–‡ä¸²éœ€è¦é…ä¸Š $hash$ æ¥å»é‡ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125namespace SAM{ const int K = 26; int cnt=0,root,last; int len[MAXN*2],par[MAXN*2],suf[MAXN]; LL sum[MAXN*2]; int nx[MAXN*2][K]; //int f [MAXN*2][21]; struct edge{int u,v,next;}; vector&lt;edge&gt; e={edge()}; int pre[MAXN*2]; void addedge(int u,int v){e.pb({u,v,pre[u]}),pre[u]=e.size()-1;} void dfs(int u){go(u)dfs(v),sum[u]+=sum[v];} void build_graph(){fp(i,2,cnt) addedge(par[i],i);} void newnode(int &amp;x) { x=++cnt; len[cnt]=par[cnt]=sum[cnt]=0; fp(i,0,K-1) nx[cnt][i]=0; } void init(){cnt=0,newnode(root),last=root;} void extend_sam(int i,int c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; fp(i,0,K-1) nx[n][i]=nx[q][i]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur,sum[cur]=1,suf[i]=cur; } void build_sam(char s[]) { int n=strlen(s+1); fp(i,1,n) extend_sam(i,s[i]-'a'); build_graph(),dfs(root); for(int i=1;i&lt;=cnt;i++) nx[i][0]=par[i]; fp(k,1,20)fp(i,1,cnt)nx[i][k]=nx[nx[i][k-1]][k-1]; } void debug() { for(int i=1;i&lt;=cnt;i++) { cout &lt;&lt; dbgs4(i,len[i],par[i],sum[i]) &lt;&lt; endl; } } LL count(int l,int r) { int cur=suf[r]; fd(k,20,0) if(nx[cur][k]&amp;&amp;len[nx[cur][k]]&gt;=r-l+1) cur=nx[cur][k]; return sum[cur]; }}LL ans=0;void calc(int l,int r){ans=max(ans,LL(r-l+1)*SAM::count(l,r));}namespace manacher{ int p[MAXN*2]; string a; void run(char s[]) { int m=strlen(s+1); a.pb('$'),a.pb('#'); for(int i=1;i&lt;=m;i++) a.pb(s[i]),a.pb('#'); a.pb('\\0'); int n=a.size()-1,id=0,mx=0; for(int i=1;i&lt;=n;i++) { if(mx&gt;i) p[i]=min(p[2*id-i],mx-i+1); else p[i]=1; while(a[i+p[i]]==a[i-p[i]]) { if(a[i+p[i]]!='#') calc((i-p[i])/2,(i+p[i])/2); p[i]++; } if(i+p[i]-1&gt;mx) mx=i+p[i]-1,id=i; } }}int n;char s[MAXN];int work(){ scanf(&quot;%s&quot;,s+1); n=strlen(s+1); SAM::init(); SAM::build_sam(s); //SAM::debug(); manacher::run(s); for(int i=1;i&lt;=n;i++) calc(i,i); return printf(&quot;%lld\\n&quot;,ans);} Luogu P4070 [SDOI2016]ç”Ÿæˆé­”å’’é¢˜æ„ï¼šæ±‚ç»™å®šå­—ç¬¦ä¸²æ¯ä¸ªå‰ç¼€çš„æœ¬è´¨ä¸åŒå­ä¸²ä¸ªæ•° æ‰©å±• $SAM$ æ—¶åŠ ä¸Šæ–°èŠ‚ç‚¹çš„è´¡çŒ®å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172namespace SAM{ const int K = 26; int cnt=0,root,last; int len[MAXN*2],par[MAXN*2]; LL sum[MAXN*2],ans=0; map&lt;int,int&gt; nx[MAXN*2]; struct edge{int u,v,next;}; vector&lt;edge&gt; e={edge()}; int pre[MAXN*2]; void addedge(int u,int v){e.pb({u,v,pre[u]}),pre[u]=e.size()-1;} void dfs(int u){go(u) dfs(v),sum[u]+=sum[v];} void newnode(int &amp;x) { x=++cnt; len[cnt]=par[cnt]=0; nx[cnt].clear(); } void init(){cnt=0,newnode(root),last=root;} void extend_sam(int c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; nx [n]=nx [q]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur,sum[cur]=1; ans+=len[last]-len[par[last]]; io.write(ans); io.push('\\n'); } void build_sam(int s[],int n) { fp(i,1,n) extend_sam(s[i]); }}int n;int a[MAXN];int work(){ io.read(n); fp(i,1,n) io.read(a[i]); SAM::init(); SAM::build_sam(a,n); return 0;} Luogu P3975 [TJOI2015]å¼¦è®ºKå°å­ä¸² 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105namespace SAM{ int cnt=0,root,last; int len[MAXN*2],par[MAXN*2]; LL sum[MAXN*2],f[2][MAXN*2]; map&lt;char,int&gt; nx[MAXN*2]; void newnode(int &amp;x) { x=++cnt; len[x]=par[x]=sum[x]=f[0][x]=f[1][x]=0; nx[x].clear(); } void init(){cnt=0,newnode(root),last=root;} void extend_sam(char c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; nx [n]=nx [q]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur,sum[cur]=1; } void build_sam(char s[]) { int n=strlen(s+1); fp(i,1,n) extend_sam(s[i]); } int seq[MAXN*2],buc[N]; void print(int cur,int k,int t,LL f[]) { if(!k) return; //cout &lt;&lt; dbgs2(cur,k) &lt;&lt; endl; for(auto trans:nx[cur]) { if(f[trans.se]&gt;=k) { putchar(trans.fi),print(trans.se,k-(t?sum[trans.se]:1),t,f); break; } else k-=f[trans.se]; } } void solve(int k,int t) { fp(i,1,cnt) buc[len[i]]++; fp(i,1,N-1) buc[i]+=buc[i-1]; fp(i,1,cnt) seq[buc[len[i]]--]=i; //fp(i,1,cnt) cout &lt;&lt; dbgs3(seq[i],len[seq[i]],par[seq[i]]) &lt;&lt; endl; fd(i,cnt,1) sum[par[seq[i]]]+=sum[seq[i]]; fd(i,cnt,1) { int cur=seq[i]; //cout &lt;&lt; dbgs2(cur,sum[cur]) &lt;&lt; endl; f[0][cur]=1,f[1][cur]=sum[cur]; for(auto trans:nx[cur]) { f[0][cur]+=f[0][trans.se]; f[1][cur]+=f[1][trans.se]; } //cout &lt;&lt; dbgs3(cur,f[0][cur],f[1][cur]) &lt;&lt; endl; } if(f[t][root]-(t==1?sum[root]:1)&lt;k) printf(&quot;-1\\n&quot;); else print(root,k,t,f[t]),putchar('\\n'); }}int n,t,k;char s[MAXN];int work(){ scanf(&quot;%s&quot;,s+1); n=strlen(s+1); scanf(&quot;%d%d&quot;,&amp;t,&amp;k); SAM::init(); SAM::build_sam(s); SAM::solve(k,t); return 0;} Luogu P2463 [SDOI2008]Sandyçš„å¡ç‰‡å¤šä¸ªä¸²LCS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103namespace SAM{ int cnt=0,root,last; int len[MAXN*2],par[MAXN*2]; int f[MAXN*2],ans[MAXN*2]; map&lt;int,int&gt; nx[MAXN*2]; void newnode(int &amp;x){x=++cnt;} void init(){cnt=0,newnode(root),last=root;} void extend_sam(int c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; nx [n]=nx [q]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur; } int seq[MAXN*2],buc[N]; void sort_by_len() { fp(i,1,cnt) buc[len[i]]++; fp(i,1,N-1) buc[i]+=buc[i-1]; fp(i,1,cnt) seq[buc[len[i]]--]=i; } void build_sam(vector&lt;int&gt; &amp;s) { int n=s.size(); fp(i,0,n-1) extend_sam(s[i]); sort_by_len(); } void run(vector&lt;int&gt; &amp;s,int id) { mst(f,0); int cur=root,L=0; fp(i,0,s.size()-1) { int c=s[i]; while(cur!=root&amp;&amp;!nx[cur][c]) cur=par[cur],L=len[cur]; if(nx[cur][c]) cur=nx[cur][c],L++; f[cur]=max(f[cur],L); } fd(i,cnt,1) { int cur=seq[i]; if(f[cur]) f[par[cur]]=len[par[cur]]; } if(id==2) fp(i,1,cnt) ans[i]=f[i]; else fp(i,1,cnt) ans[i]=min(ans[i],f[i]); } void solve() { int L=0; fp(i,1,cnt) if(ans[i]!=inf) L=max(ans[i],L); io.write(L+1); }}int n,m;vector&lt;int&gt; s[MAXN];int work(){ io.read(m); fp(i,1,m) { static int tmp; io.read(n); fp(j,1 ,n) io.read(tmp),s[i].pb(tmp); fd(j,n-1,1) s[i][j]-=s[i][j-1]; s[i].erase(s[i].begin()); //cout &lt;&lt; dbgs(i) &lt;&lt; endl; } SAM::init(); SAM::build_sam(s[1]); //cout &lt;&lt; &quot;done&quot; &lt;&lt; endl; fp(i,2,m) SAM::run(s[i],i); SAM::solve(); return 0;} BZOJ 1396 è¯†åˆ«å­ä¸²è®¾æ¯ä¸ªä½ç½® $i$ çš„æœ€çŸ­è¯†åˆ«å­ä¸²é•¿åº¦ä¸º $len[i]$ è€ƒè™‘é‚£äº› $endpos$ é›†åˆå¤§å°ä¸º $1$ çš„å¶å­èŠ‚ç‚¹ $u$ï¼Œè®¾å®ƒå”¯ä¸€çš„ $endpos$ ä¸º $i$ï¼Œåˆ™è¿™ä¸ªèŠ‚ç‚¹å¯¹æ¯ä¸ªä½ç½®çš„è´¡çŒ®å¯åˆ†ä¸¤ç§æƒ…å†µè®¨è®ºï¼š æ»¡è¶³ $j\\in[i-min(u) + 1,i]$ çš„ $len[j]$ å’Œ $min(u)$ å– $min$ æ»¡è¶³ $j\\in[1,i-min(i)]$ çš„ $len[j]$ å’Œ $i-j+1$ å– $min$ è€ƒè™‘ä¸¤ç§æƒ…å†µåˆ†åˆ«ç”¨çº¿æ®µæ ‘ç»´æŠ¤ï¼Œé‚£ä¹ˆç¬¬ä¸€ç§çŠ¶æ€çš„æ›´æ–°ç›¸å½“äºåŒºé—´æ¯ä¸ªæ•°å¯¹ $min(u)$ å– $min$ï¼Œç¬¬äºŒç§æ›´æ–° $i-j+1$ ä¸­çš„ $j$ å¯ä»¥æå‡ºæ¥ï¼ŒåŒæ ·çš„åšæ³•ç»´æŠ¤æœ€å°çš„ $i+1$ å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137struct sgt{ int mn[MAXN*4],v[MAXN*4]; void doMin(int cnt,int &amp;val) { mn[cnt]=min(mn[cnt],val); v [cnt]=min(v [cnt],val); } void pushdown(int cnt) { if(mn[cnt]!=inf) { doMin(ls,mn[cnt]); doMin(rs,mn[cnt]); mn[cnt]=inf; } } void build(int l,int r,int cnt) { mn[cnt]=inf,v[cnt]=inf; if(l==r) return; build(l,mid,ls); build(mid+1,r,rs); } void update(int l,int r,int nl,int nr,int v,int cnt) { if(l==nl&amp;&amp;r==nr){doMin(cnt,v);return;} pushdown(cnt); if(nr&lt;=mid) update(l,mid,nl,nr,v,ls); else if(nl&gt;mid) update(mid+1,r,nl,nr,v,rs); else update(l,mid,nl,mid,v,ls),update(mid+1,r,mid+1,nr,v,rs); } void get_val(int a[],int l,int r,int cnt) { if(l==r){a[l]=v[cnt];return;} pushdown(cnt); get_val(a,l,mid,ls); get_val(a,mid+1,r,rs); }}T1,T2;const int K = 26;namespace SAM{ int cnt=0,root,last; int len[MAXN*2],par[MAXN*2],s[MAXN*2]; int nx[MAXN*2][K],pre[MAXN]; void newnode(int &amp;x){x=++cnt;} void init(){cnt=0,newnode(root),last=root;} void extend_sam(int c,int index) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; for(int i=0;i&lt;K;i++) nx[n][i]=nx[q][i]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur,pre[index]=cur,s[cur]=1; } int seq[MAXN*2],buc[N]; void sort_by_len() { fp(i,1,cnt) buc[len[i]]++; fp(i,1,N-1) buc[i]+=buc[i-1]; fp(i,1,cnt) seq[buc[len[i]]--]=i; } void build_sam(char s[]) { int n=strlen(s+1); fp(i,1,n) extend_sam(s[i]-'a',i); } void solve(int n) { sort_by_len(); fd(i,cnt,1) { int cur=seq[i]; s[par[cur]]+=s[cur]; } fp(i,1,n) { int cur=pre[i]; if(s[cur]==1) { int l=len[par[cur]]+1,r=len[cur]; T1.update(1,n,i-r+1,i-l+1,i,1); if(i-l+2&lt;=i) T2.update(1,n,i-l+2,i,l,1); } } }}int n;char s[MAXN];int v1[MAXN],v2[MAXN];int work(){ scanf(&quot;%s&quot;,s+1); n=strlen(s+1); T1.build(1,n,1); T2.build(1,n,1); SAM::init(); SAM::build_sam(s); SAM::solve(n); T1.get_val(v1,1,n,1); T2.get_val(v2,1,n,1); fp(i,1,n) printf(&quot;%d\\n&quot;,min(v2[i],v1[i]-i+1)); return 0;} Luogu P3346 [ZJOI2015]è¯¸ç¥çœ·é¡¾çš„å¹»æƒ³ä¹¡ç”±äºå¶å­æœ€å¤šåªæœ‰ $20$ ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæ¯ä¸ªå¶å­å½“ä½œæ ¹è·‘å‡ºä¸€é¢— $Trie$ å‡ºæ¥ï¼Œé‚£ä¹ˆ 20 ä¸ª $Trie$ åˆå¹¶èµ·æ¥å°±åŒ…å«äº†æ‰€æœ‰åŸæ ‘ä¸Šä»»æ„ä¸¤ä¸ªè·¯å¾„æ‰€æ„æˆçš„å­—ç¬¦ä¸² ç„¶åå»ºç«‹å¹¿ä¹‰ $SAM$ï¼Œæœ€ååœ¨æ±‚ä¸€æ³¢æœ¬è´¨ä¸åŒå­ä¸²å³å¯ ä»£ç è§ä¸Šé¢ BZOJ 3277 ä¸²è´´ä¸ªåˆ«äººçš„é¢˜è§£ï¼Œï¼Œï¼Œ ä¸€ä¸ªç”¨SAMç»´æŠ¤å¤šä¸ªä¸²çš„æ ¹å·ç‰¹æŠ€ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899int n,k;string s[MAXN]; const int K = 26; namespace SAM{ int cnt=0,root,last; int len[MAXN*2],par[MAXN*2],sum[MAXN*2]; map&lt;char,int&gt; nx[MAXN*2]; int vis[MAXN*2]; LL f[MAXN*2]; void newnode(int &amp;x){x=++cnt;} void init(){cnt=0,newnode(root),last=root;} void extend_sam(char c,int index) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; nx[n]=nx[q]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur; } int seq[MAXN*2],buc[N]; void sort_by_len() { fp(i,1,cnt) buc[len[i]]++; fp(i,1,N-1) buc[i]+=buc[i-1]; fd(i,cnt,1) seq[buc[len[i]]--]=i; } void build_sam(string &amp;s) { int n=s.size(); fp(i,0,n-1) extend_sam(s[i],i); last=root; } void mark(int cur,int id) { while(cur!=root&amp;&amp;vis[cur]!=id) sum[cur]++,vis[cur]=id,cur=par[cur]; } void solve() { sort_by_len(); fp(i,1,cnt) if(sum[i]&gt;=k) f[i]+=len[i]-len[par[i]]; fp(i,1,cnt) { int cur=seq[i]; f[cur]+=f[par[cur]]; } } void run(string &amp;s,int id,bool flag=0) { int cur=root,n=s.size(); LL ans=0; fp(i,0,n-1) { cur=nx[cur][s[i]]; if(!flag) mark(cur,id); else ans+=f[cur]; } if(flag) cout &lt;&lt; ans &lt;&lt; &quot; &quot;; }} int work(){ cin &gt;&gt; n &gt;&gt; k; SAM::init(); fp(i,1,n) cin &gt;&gt; s[i],SAM::build_sam(s[i]); fp(i,1,n) SAM::run(s[i],i,0); SAM::solve(); fp(i,1,n) SAM::run(s[i],i,1); return 0;} CF235C Cyclical Questé¢˜æ„ï¼šå½“ä¸¤ä¸ªå­—ç¬¦ä¸²å¯ä»¥é€šè¿‡å¾ªç¯ç§»ä½å˜æˆå®Œå…¨ä¸€æ ·æ—¶æˆ‘ä»¬ç§°è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²â€œç›¸ç­‰â€ã€‚ ç»™å®šæ–‡æœ¬ä¸²ï¼Œå¤šä¸ªæ¨¡å¼ä¸²ï¼Œè¯¢é—®æ–‡æœ¬ä¸²ä¸­ä¸æ¨¡å¼ä¸²â€œç›¸ç­‰â€çš„å­ä¸²æœ‰å¤šå°‘ SOLï¼šå…ˆå¯¹æ–‡æœ¬ä¸²å»ºç«‹ $SAM$ï¼Œè€ƒè™‘è®¡ç®—æ¨¡å¼ä¸²çš„æ‰€æœ‰å¾ªç¯ç§»ä½åœ¨æ–‡æœ¬ä¸²ä¸­çš„å‡ºç°æ¬¡æ•° æŠŠæ¨¡å¼ä¸²æ‹¿åˆ° $SAM$ ä¸Šè¿è¡Œå¹¶è®°å½•åœ¨æ¯ä¸ªçŠ¶æ€çš„åŒ¹é…é•¿åº¦ Lï¼Œæ¯æ¬¡å»æ‰é¦–å­—æ¯å¹¶æŠŠä»–åŠ åˆ°å­—ç¬¦ä¸²æœ«å°¾ï¼Œè‹¥ $L-1&lt;min(u)$ æˆ–æ²¡æœ‰è½¬ç§»è¾¹å°±æš´åŠ›è·³ $par$å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116namespace SAM{ const int K = 26; int cnt=0,root,last; int len[MAXN*2],par[MAXN*2]; LL sum[MAXN*2]; bool calc[MAXN*2]; map&lt;int,int&gt; nx[MAXN*2]; struct edge{int u,v,next;}; vector&lt;edge&gt; e={edge()}; int pre[MAXN*2]; void addedge(int u,int v){e.pb({u,v,pre[u]}),pre[u]=e.size()-1;} void dfs(int u){go(u) dfs(v),sum[u]+=sum[v];} void newnode(int &amp;x) { x=++cnt; len[cnt]=par[cnt]=0; nx[cnt].clear(); } void init(){cnt=0,newnode(root),last=root;} void extend_sam(int c) { int cur; newnode(cur); len[cur]=len[last]+1; int p=last; while(p&amp;&amp;!nx[p][c]) nx[p][c]=cur,p=par[p]; if(!p) par[cur]=root; else { int q=nx[p][c]; if(len[q]==len[p]+1) par[cur]=q; else { int n; newnode(n); len[n]=len[p]+1; par[n]=par[q]; nx [n]=nx [q]; while(p&amp;&amp;nx[p][c]==q) nx[p][c]=n,p=par[p]; par[q]=par[cur]=n; } } last=cur,sum[cur]=1; } void build_sam(char s[]) { int n=strlen(s+1); fp(i,1,n) extend_sam(s[i]-'a'); fp(i,2,cnt) addedge(par[i],i); dfs(root); //fp(i,2,cnt) cout &lt;&lt; dbgs2(i,sum[i]) &lt;&lt; endl; } stack&lt;int&gt; stk; void match(char s[],LL ans=0) { while(!stk.empty()) calc[stk.top()]=0,stk.pop(); int n=strlen(s+1); int cur=root,l=0; fp(i,1,n) { int c=s[i]-'a'; while(cur!=root&amp;&amp;!nx[cur][c]) cur=par[cur],l=len[cur]; if(nx[cur][c]) cur=nx[cur][c],l++; } fp(i,1,n) { //cout &lt;&lt; dbgs2(i,cur) &lt;&lt; endl; if(l==n) l--; if(cur!=root&amp;&amp;len[par[cur]]&gt;=l) cur=par[cur]; int c=s[i]-'a'; while(cur!=root&amp;&amp;!nx[cur][c]) cur=par[cur],l=len[cur]; if(nx[cur][c]) cur=nx[cur][c],l++; if(l==n&amp;&amp;!calc[cur]) ans+=sum[cur],calc[cur]=1,stk.push(cur); //cout &lt;&lt; dbgs3(i,l,ans) &lt;&lt; endl; } printf(&quot;%I64d\\n&quot;,ans); } } int n,m;char s[N]; int work(){ scanf(&quot;%s&quot;,s+1); n=strlen(s+1); SAM::init(); SAM::build_sam(s); scanf(&quot;%d&quot;,&amp;m); while(m--) { scanf(&quot;%s&quot;,s+1); n=strlen(s+1); SAM::match(s); } return 0;} æˆ‘æ•´ä¸ªäººéƒ½è‡ªåŠ¨æœºè¾£","link":"/2019/09/10/SAM-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%B0%8F%E7%BB%93/"},{"title":"HDU6701 2019å¤šæ ¡å1011 å¯å‘å¼åˆ†æ²»","text":"LinkMake Rounddog Happy é¢˜æ„ç»™ä½  $k$ å’Œä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ•°ç»„å’Œï¼Œæ±‚æ»¡è¶³ max\\{a_{l},a_{l+1}...a_{r}\\}-(r-l+1)>=kä¸” $a_{l}â€¦a_{r}$ ä¸¤ä¸¤ä¸åŒçš„ $(l,r)$ çš„å¯¹æ•°ã€‚ é¢˜è§£æ‰“çš„æ—¶å€™ä¹±å†™äº†ä¸ªå°ºå–+çº¿æ®µæ ‘ï¼Œåˆ°æœ€åä¹Ÿæ²¡è°ƒå‡ºï¼Œï¼Œï¼Œ ç”¨å°ºå–é¢„å¤„ç†å‡ºåœ¨ä¿è¯åŒºé—´æ•°ä¸é‡å¤çš„æƒ…å†µä¸‹æ¯ä¸ªä½ç½®ä½œä¸ºå·¦/å³è¾¹ç•Œæ—¶èƒ½æ‰©å±•çš„æœ€å¤§è·ç¦»ã€‚ è€ƒè™‘åˆ†æ²»ï¼Œ$solve(l,r)$ è¡¨ç¤ºè®¡ç®— $l$ åˆ° $r$ ä¸­è·¨è¶Š $mid$ çš„åˆæ³•åŒºé—´å¯¹æ•°ï¼Œä½†å¼å­ä¸­çš„ $max$ é‚£ä¸€é¡¹ä¸èƒ½å›ºå®šï¼Œå› æ­¤è€ƒè™‘é€‰æ‹©æ»¡è¶³ $a_{mid} = max\\{a_{l}â€¦a_{r}\\}$ çš„ $mid$ ä½œä¸ºåˆ†æ²»çš„ä¸­ç‚¹ï¼Œè¿™æ ·å¯ä»¥æŠŠå¼å­ä¸­ $max\\{a_{l},a_{l+1}â€¦a_{r}\\}$ å›ºå®šä¸º $a_{mid}$ï¼Œå¯¹åŒºé—´é•¿åº¦çš„é™åˆ¶ä¹Ÿå¯ä»¥å˜ä¸º $(r-l+1)&gt;=a_{mid}-k$ ã€‚ è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œè®¡ç®—ç­”æ¡ˆæ—¶æˆ‘ä»¬æœ‰ä¸¤ç§é€‰æ‹©ï¼Œä¸€ä¸ªæ˜¯æšä¸¾å·¦ç«¯ç‚¹ $l,l+1,â€¦mid$ ç»Ÿè®¡å³ç«¯ç‚¹çš„å¯è¡Œä½ç½®ï¼Œå¦ä¸€ç§æ˜¯æšä¸¾å³ç«¯ç‚¹ç»Ÿè®¡å·¦ç«¯ç‚¹çš„å¯è¡Œä½ç½®ï¼Œä½†æˆ‘ä»¬çš„ $mid$ ä¸æ˜¯ $(l+r)/2$ï¼Œæ‰€ä»¥æˆ‘ä»¬æ¯æ¬¡é€‰æ‹©é•¿åº¦å°çš„ä¸€è¾¹è®¡ç®—ç­”æ¡ˆä»¥ä¿è¯å¤æ‚åº¦é‡Œçš„ $logn$ ä¸ä¼šé€€åŒ–æˆ $n$ï¼ˆå¯å‘åœ¨è¿™é‡Œï¼‰ã€‚ åŒºé—´æœ€å¤§å€¼çš„ä½ç½®ç”¨ $ST$ è¡¨å°±å¥½ ï¼Œå¤šä¸ª $log$ ä¼°è®¡å†²ä¸è¿‡ï¼Œï¼Œï¼Œ ç»†èŠ‚è¿˜è›®å¤šçš„ï¼Œå¤§æ¦‚è¦ç»†å¿ƒç‚¹è°ƒ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384namespace st{ int f[MAXN][20]; int pos[MAXN][20]; void init(int a[],int n) { fp(i,1,n)f[i][0]=a[i]; fp(i,1,n)pos[i][0]=i; for(int j=1;(1&lt;&lt;j)&lt;=n;j++) { for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) { f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); if(f[i][j-1]&gt;=f[i+(1&lt;&lt;(j-1))][j-1]) pos[i][j]=pos[i][j-1]; else pos[i][j]=pos[i+(1&lt;&lt;(j-1))][j-1]; } } } int query(int l,int r) { int k=log2(r-l+1),ans=max(f[l][k],f[r-(1&lt;&lt;k)+1][k]); return f[l][k]&gt;=f[r-(1&lt;&lt;k)+1][k]?pos[l][k]:pos[r-(1&lt;&lt;k)+1][k]; }}int n,k;int L[MAXN],R[MAXN];int a[MAXN];LL solve(int l,int r){ if(l&gt;r ) return 0; if(l==r) return a[l]-1&lt;=k; int mid=st::query(l,r),len=max(1,a[mid]-k); LL ans=0; if(mid-l&lt;r-mid) { fp(i,l,mid) if(max(i+len-1,mid)&lt;=min(r,R[i])) ans+=min(r,R[i])-max(i+len-1,mid)+1; } else { fp(i,mid,r) if(min(i-len+1,mid)&gt;=max(l,L[i])) ans+=min(i-len+1,mid)-max(l,L[i])+1; } //cout &lt;&lt; dbgs3(l,r,mid) &lt;&lt; endl; //cout &lt;&lt; dbgs2(len,ans) &lt;&lt; endl; return ans+solve(l,mid-1)+solve(mid+1,r);}map&lt;int,bool&gt; m;void init(){ m.clear(); for(int r=1,l=1;r&lt;=n;r++) { while(l&lt;r&amp;&amp;m[a[r]]==1) m[a[l]]=0,l++; m[a[r]]=1,L[r]=l; //cout &lt;&lt; dbgs2(r,L[r]) &lt;&lt; endl; } m.clear(); for(int l=n,r=n;l&gt;=1;l--) { while(l&lt;r&amp;&amp;m[a[l]]==1) m[a[r]]=0,r--; m[a[l]]=1,R[l]=r; //cout &lt;&lt; dbgs2(l,R[l]) &lt;&lt; endl; }}int work(){ int T=read(); while(T--) { n=read(),k=read(); fp(i,1,n)a[i]=read(); init(),st::init(a,n); write(solve(1,n)),putchar('\\n'); } return 0;}","link":"/2019/08/26/HDU6701-2019%E5%A4%9A%E6%A0%A1%E5%8D%811011-%E5%90%AF%E5%8F%91%E5%BC%8F%E5%88%86%E6%B2%BB/"},{"title":"CF1207F æ ¹å·åˆ†æ²»","text":"LinkCF1207F. Remainder Problem é¢˜æ„ç»™ä½ ä¸€ä¸ªåŒ…å« $n$ ä¸ªæ•°çš„æ•°ç»„ï¼Œä¸€å¼€å§‹æ¯ä¸€ä½ä¸Šéƒ½æ˜¯ $0$ã€‚$q$ æ¬¡æ“ä½œï¼Œç¬¬ä¸€ä¸ªæ“ä½œæ˜¯å•ç‚¹ä¿®æ”¹ï¼Œç¬¬äºŒä¸ªæ“ä½œæ˜¯å¯¹äºæ‰€æœ‰æ»¡è¶³ $i$ % $y=x$ çš„ $a_{i}$ æ±‚å’Œã€‚ $n=500000$ $q&lt;=500000$ é¢˜è§£æ‰“CFæ—¶çœ‹æ¸…ç¥ç§’äº†è¿™é¢˜æˆ‘è¿˜ä»¥ä¸ºæ˜¯æ•°æ®ç»“æ„ï¼Œï¼Œï¼Œç»“æœæƒ³äº†åŠå¤©ä¹Ÿæƒ³ä¸å‡ºå’‹ç»´æŠ¤ï¼Œï¼Œï¼Œ ä¸€ç§æš´åŠ›çš„åšæ³•æ˜¯å¯¹äºæ¯ä¸€ä¸ªå¯¹ $y$ å’Œ $x$ éƒ½å¼€ä¸€ä¸ªæ•°ç»„è®°å½•ä¸€ä¸‹ï¼Œä½†å•ç‚¹æ›´æ–° $O(n)$ï¼ŒæŸ¥è¯¢æ—¶ $O(1)$ã€‚ å¦ä¸€ä¸ªç§æš´åŠ›åšæ³•å°±æ˜¯ç›´æ¥æ±‚ $a_{x}+a_{x+y}+a_{x+2y}+a_{x+3y}â€¦$ æœ€å·®æƒ…å†µä¸‹ä¹Ÿæ˜¯ $O(n)$ çš„ï¼Œæ›´æ–°æ—¶ $O(1)$ã€‚ å½“ $n$ å¾ˆå°çš„æ—¶å€™ç¬¬ä¸€ç§æš´åŠ›å¾ˆæœ‰æ•ˆï¼Œå½“ $n$ å¾ˆå¤§æ—¶ç¬¬äºŒç§æš´åŠ›ä¹Ÿå¾ˆä¼šå¿«ï¼Œå› æ­¤æˆ‘ä»¬è€ƒè™‘å®šä¸€ä¸ªä¸Šç•Œ $m$ï¼Œå¯¹äºå°äº $m$ çš„ $x$ æˆ‘ä»¬é€‰æ‹©ç¬¬ä¸€ç§æš´åŠ›æ–¹å¼ï¼Œå¤§äº $m$ æˆ‘ä»¬ç”¨ç¬¬äºŒç§æš´åŠ›ã€‚ è¿™æ ·å•æ¬¡è¯¢é—®æˆ–æŸ¥è¯¢çš„å¤æ‚åº¦æ˜¯$O(m+n/(n-m))$çš„ï¼Œæ˜¾ç„¶ $m$ å– $sqrt{n}$ æ—¶å¤æ‚åº¦æœ€ä¼˜ã€‚ è¿™ä¸œè¥¿å°±æ˜¯æ ¹å·åˆ†æ²» çœŸæ˜¯å¤ªæš´åŠ›äº† Code123456789101112131415161718192021222324const int sqrtn=sqrt(MAXN); int n=5e5,q;LL s[sqrtn+5][sqrtn+5];LL a[MAXN]; int work(){ q=read(); while(q--) { int t=read(),x=read(),y=read(); if(t==1){a[x]+=y;fp(i,1,sqrtn)s[i][x%i]+=y;} else { LL ans=0; if(x&gt;sqrtn){for(int i=y;i&lt;=n;i+=x)ans+=a[i];} else ans=s[x][y]; write(ans),putchar('\\n'); } } return 0;}","link":"/2019/08/24/CF1207F-%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"},{"title":"19.8.24ç®€å•å­—ç¬¦ä¸²è®²è¯¾","text":"PPTå­—ç¬¦ä¸² bakapiano ç¥ç§˜ä»£ç  frhd å‡ é“æ¿å­é¢˜å­—ç¬¦ä¸² ç¥ç§˜ä»£ç  heuacm","link":"/2019/08/24/19-8-24%E7%AE%80%E5%8D%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%B2%E8%AF%BE/"}],"tags":[{"name":"ç½‘ç»œæµ è´¹ç”¨æµ æœ€å¤§æµ","slug":"ç½‘ç»œæµ-è´¹ç”¨æµ-æœ€å¤§æµ","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E8%B4%B9%E7%94%A8%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"çº¿æ®µæ ‘","slug":"çº¿æ®µæ ‘","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"æ•°æ®ç»“æ„ çº¿æ®µæ ‘","slug":"æ•°æ®ç»“æ„-çº¿æ®µæ ‘","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"categories":[]}